/*
 Navicat Premium Data Transfer

 Source Server         : 83
 Source Server Type    : MySQL
 Source Server Version : 50739
 Source Host           : 192.168.1.83:3306
 Source Schema         : terminal_bbs

 Target Server Type    : MySQL
 Target Server Version : 50739
 File Encoding         : 65001

 Date: 12/10/2023 09:41:12
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `content_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `status` int(11) NULL DEFAULT NULL,
  `share` tinyint(1) NOT NULL,
  `source_url` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `view_count` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `update_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_status`(`status`) USING BTREE,
  INDEX `idx_view_count`(`view_count`) USING BTREE,
  INDEX `idx_article_create_time`(`create_time`) USING BTREE,
  INDEX `idx_article_user_id`(`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (6, 2, 'Mysql 自增主键', '1、创建\n​ 在创建主键的时候可以使用AUTO_INCREMENT关键字进行自增主键设置，设置之后，每插入一条数据之后主键都会自动累加1\n​ 使用AUTO_INCREMENT=100可以在表级别设定偏移量，比如这里设定为100，即从100开始累加\n2、修改', '### 1、创建\n\n​ 在创建主键的时候可以使用`AUTO_INCREMENT`关键字进行自增主键设置，设置之后，每插入一条数据之后主键都会自动累加1\n\n​ 使用`AUTO_INCREMENT=100`可以在表级别设定偏移量，比如这里设定为100，即从100开始累加\n\n### 2、修改AUTO\\_INCREMENT值\n\n```\nALTER TABLE tableName AUTO_INCREMENT = n\n\n```\n\n### 3、自增主键在innodb引擎与myisam引擎差别\n\n**现象**\n\n​ 重启后，innodb采用当前最大索引值，myisam采用建表以来最大索引值。\n\n​ 比如，table\\_innodb当前最大索引为8，删除最后一条，当前最大为7，重启，table\\_innodb索引会从8开始，而不是9。\n\n​ 同样的操作，table\\_myisam重启之后会从9开始\n\n​ **Mysql8.0之后得以修复，innodb与myisam引擎表现一致**\n\n**原因**\n\n​ innodb将AUTO\\_INCREMENT值存储在内存里面，并没有做持久化\n\n​ myisam会将AUTO\\_INCREMENT持久化存放在磁盘里', 'markdown', 0, 0, NULL, 6, 1655861837277, 1655861837277);
INSERT INTO `t_article` VALUES (7, 2, '韦伯首次探测到超新星，垂死恒星大爆炸，距离地球30亿光年', '美国宇航局（NASA）的詹姆斯·韦伯太空望远镜（JWST）首次探测到一颗超新星，即一颗垂死的恒星大爆炸，距离地球 30 亿光年。2011 年用哈勃望远镜观察同一个星系时，这个爆炸并不存在。\n \n韦伯发现的超新星就在上图的红圈内，是一个明亮的小点。\n据报道，', '美国宇航局（NASA）的詹姆斯·韦伯太空望远镜（JWST）首次探测到一颗超新星，即一颗垂死的恒星大爆炸，距离地球 30 亿光年。2011 年用哈勃望远镜观察同一个星系时，这个爆炸并不存在。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056933-52cc-27a4-9ad6-b6d045899e3c_66372-20220801083717635-1988728034.jpg)\n\n韦伯发现的超新星就在上图的红圈内，是一个明亮的小点。\n\n据报道，这颗超新星位于 SDSS.J141930.11+5251593 星系，JWST 拍摄的图像显示一个物体的光线在五天内变得越来越暗，这条线索引发了超新星的推测。\n\n据悉，当恒星耗尽燃料时，压力下降，恒星会膨胀到至少是我们太阳质量的五倍，相当于 33.3 万个地球的大小，然后发生大爆炸，释放出成吨的碎片和颗粒。这一现象被称为“超新星”。\n\n太空望远镜科学研究所（STSCI）的恩格泽尔（Mike Engesser）表示，令人兴奋的是，JWST 的设计并不是为了寻找和探测新的瞬变体。这颗潜在的超新星是由 NIRCam 仪器捕获的，该仪器旨在通过使用广泛的红外光来探测最早的恒星和星系的光线。\n\nNIRCam 配备了日冕仪，这些仪器允许天文学家拍摄中心明亮物体周围光线非常微弱的物体，比如恒星系统，或者在这种情况下恒星爆炸的照片。\n\nJWST 正在调查这个遥远的星系，所以捕捉到这颗超新星“纯属运气”。\n\n这颗垂死的恒星在图像中显示为一个小亮点。2011 年用哈勃望远镜观察同一个星系时，这个爆炸并不存在。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05693b-cf4d-4fac-d27f-42137d1472c6_66372-20220801083717661-1613613741.jpg)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05693c-425b-41d7-0af8-36df6d8d7aff_66372-20220801083717597-2048811142.jpg)\n\n研究团队用软件分析发现了超新星。\n\n恩格泽尔和他的团队使用了旨在发现照片差异的软件，这导致了这个明亮的斑点被发现。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05693d-433c-bf27-6572-02be6100083e_66372-20220801083717654-1110404902.jpg)\n\n韦伯发现人类眼睛能看到的宇宙中最古老的星系。\n\nJWST 已经证明 NASA 为它花的 100 亿美元很值。它不仅在 7 月 12 日提供了第一张正式的深空照片，而且一周后，科学家们宣布它发现了一个有 135 亿年历史的星系，现在是人类眼睛看到的宇宙中最古老的星系。\n\n文/南都记者陈林\n\n来自: 网易科技  [原文链接](https://www.163.com/dy/article/HDI79ECR05129QAF.html)', 'markdown', 0, 0, NULL, 9, 1659317498854, 1659318214433);
INSERT INTO `t_article` VALUES (8, 2, '中国商飞宣布C919完成取证试飞，距离商业运营还有多久', ' \n中国商飞官微 8 月 1 日宣布，国产大飞机 C919 完成取证试飞。\nC919 大型客机是我国自行研制、具有自主知识产权的大型喷气式民用飞机，采用单通道窄体布局，座级 158 至 168 座，航程 4075 至 5555 公里，与目前国际航空市场上最', '![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056e98-9ed7-1c53-82cf-8618862b99d1_66372-20220801181918026-821491685.jpg)\n中国商飞官微 8 月 1 日宣布，国产大飞机 C919 完成取证试飞。\n\nC919 大型客机是我国自行研制、具有自主知识产权的大型喷气式民用飞机，采用单通道窄体布局，座级 158 至 168 座，航程 4075 至 5555 公里，与目前国际航空市场上最为常见的空客 320、波音 737 机型同级别。\n\n由于商业大飞机领域行业壁垒高，此前只有少数国家能够独立承担大飞机的研制与生产，形成了波音和空客双寡头垄断的格局。\n\n2022 年 7 月 19 日，C919 大型客机六架试飞机完成全部试飞任务，标志着 C919 取证工作正式进入收官阶段，开始全力向取证冲锋。2022 年 5 月 14 日，即将交付的首架 C919 国产大飞机首次飞行试验完成。\n\n2022 年 1 月上海两会期间，上海市政协委员、中国商用飞机有限责任公司副总经理、总会计师吴永良在接受澎湃新闻采访时表示，国产 C919 项目预计将于 2022 年完成交付。“具体的交付将等到取证完成后才具备条件。”\n\n距离商业运行还有哪几步？\n\n民航专家李瀚明告诉澎湃新闻记者，“完成取证试飞是中国大飞机 C919 投入商业运用的前提条件之一。在这一过程中，飞机制造商需要向监管当局就飞机的安全性进行一系列的理论和实际论证。这相当于考生在考试中用试卷和实验操作向考官证明自己的能力，完成取证试飞相当于走出了考场。”\n\n中国航空学会会员、河南省航空业协会专家委员会秘书长乔善勋告诉记者，C919 完成取证试飞，意味着取得中国民航局的适航证书只是时间问题，现在还不能进行商业运营，但是距离最后的商业运营只是“临门一脚”了。\n\n乔善勋告诉澎湃新闻记者，理论上讲，颁证当天就可进行商业运营。中国商飞新支线飞机 ARJ21 从首飞到完成试飞，历时 6 年 1 个月。C919 从首飞到完成试飞，历时 5 年 2 个月。以 ARJ21 的取证过程来看，2014 年 12 月 16 号完成所有试飞后，在 2014 年 12 月 30 日获得局方颁发的型号合格证（PC），参考这个时间点，若过程顺利，C919 预计将会在 8 月至 9 月获得局方的型号合格证。但 C919 还需要取得生产许可证（PC）和航空器适航证（AC，airworthiness certificate），而拿到适航证也就相当于局方认可 C919 处于安全飞行状态，也就是适航状态。拿下全部三个证，适航取证才算全部结束。\n\n资深机长陈建国向澎湃新闻记者表示，接下去 C919 还需要等待中国民用航空局航空器适航审定司走文书审查程序，颁发航空器适航证，取得适航证便意味着 C919 可以正式在国内投入商业运营飞行。而除了拿下中国民航局下发的适航证外，商飞未来也还需要争取欧洲航空安全局（EASA）适航证以及美国航空管理局（FAA）适航证，才能在国外投入商业运营。\n\n超 800 架订单在手\n\n2015 年 11 月 2 日，C919 首架机在上海浦东基地完成总装下线，标志着 C919 首架机的机体大部段对接和机载系统安装工作正式完成。2017 年 5 月 5 日 C919 在上海浦东机场完成首飞任务，意味着我国已具备了生产干线喷气式客机的实力。\n\n订单方面，据商飞官网介绍，C919 累计 28 家客户 815 架订单。\n\n2021 年中国商飞公司营销委主任张小光在接受澎湃新闻记者在内的媒体采访时表示，目前，C919 已累积有 815 架订单数，这里面包括确认订单和意向订单，后续会陆续落实确认订单。\n\nC919 全球首家客户为三大航中的一家。早在 2010 年，中国东方航空（以下简称为“东航”）与中国商飞签署了 C919 大型客机启动用户协议和采购意向。2016 年 11 月，在第十一届中国国际航空航天博览会上，东航与中国商飞签署合作框架协议，成为 C919 大型客机的全球首家用户。\n\n2021 年 3 月 1 日，C919 全球首单正式落地。中国东航与中国商飞在上海正式签署了 C919 大型客机购机合同，首批引进 5 架，东航将成为全球首家运营 C919 大型客机的航空公司。\n\n今年 5 月 10 日，中国东航拟非公开发行募集资金总额不超过 150 亿元，105 亿元用于引进 38 架飞机项目，机型中包括 4 架 C919 飞机，飞机项目预计于 2022 年至 2024 年交付。\n\n其中 C919 首次披露目录单价，目录单价为 6.53 亿元（9900 万美元）。\n\n[原文链接](https://www.163.com/dy/article/HDM5ATN00514R9P4.html)', 'markdown', 0, 0, NULL, 4, 1659407950154, 1659407994279);
INSERT INTO `t_article` VALUES (9, 11, 'SQL中instr和like的使用区别', '1、instr函数\ninstr函数是一个字符串处理函数，它在Oracle/PLSQL中是返回子字符串在源字符串中的位置，如果在源串中没有找到子串，则返回0。\ninstr函数定义如下：\n /*  \n * 返回子字符串在源字符串中的位置(字符串位置从1开始，而', '1、instr函数\n\n instr函数是一个字符串处理函数，它在Oracle/PLSQL中是返回子字符串在源字符串中的位置，如果在源串中没有找到子串，则返回0。\n\ninstr函数定义如下：\n\n``` \n /*  \n * 返回子字符串在源字符串中的位置(字符串位置从1开始，而不是从0开始)  \n * @param str 源字符串  \n * @param substr 子字符串  \n * @param position 检索位置，可省略(默认为1),参数为正时，从左向右检索，参数为负时，从右向左检索  \n * @param occurrence 检索子串出现次数(即子串在源串第几次出现)，可省略(默认为1),值只能为正整数，否则会报错  \n * @return 返回子字符串在源字符串中出现的位置（没找到返回0）  \n */  \ninstr(str, substr, position, occurrence); \n```\n例如：\n``` \nSELECT INSTR(\'hello world\', \'l\') FROM DUAL;        --结果：3  \nSELECT INSTR(\'hello world\', \'l\', 5) FROM DUAL;     --结果：10 (从左向右第5位开始检索\'l\'在\'hello world\'中出现的位置) \nSELECT INSTR(\'hello world\', \'l\', -1) FROM DUAL;    --结果：10 (从右向左第1位开始检索\'l\'在\'hello world\'中出现的位置) \nSELECT INSTR(\'hello world\', \'l\', 2, 2) FROM DUAL;  --结果：4  (从左向右第2位开始检索\'l\'在\'hello world\'中第2次出现的位置) \nSELECT INSTR(\'hello world\', \'l\', -3, 3) FROM DUAL; --结果：0  (从右向左第3位开始检索\'l\'在\'hello world\'中第3次出现的位置)\n```\n\n2、like关键字\n like关键字也可称为通配符，在SQL中用于模糊查询。可以使用“%”和“_”通配符，其中“%”代表0个或多个字符，“_”代表1个字符。\n例如：\n\n``` \nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'%张%\'; --在STUDENTTAB表中查询STUNAME中含有字符“张”的学员\nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'张_\';  --在STUDENTTAB表中查询STUNAME中以“张”开头，名字长度为2的学员(即“张三”、“张四”，而不会检测出“张三三”)\n```\n\n3、instr和like的使用：\n``` \nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'%张%\';\n就相当于 \nSELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, \'张\') > 0;\n \nSELECT * FROM STUDENTTAB WHERE STUNAME NOT LIKE \'%张%\';\n就相当于 \nSELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, \'张\') = 0;\n```\n\n4、总结\n<1> instr>0 和like、instr=0 和not like 一般来说查询的结果相同(不考虑特殊字符)\n<2> instr是一个函数，可以建立函数索引，如果过滤的条件有索引，那么instr就可以提高性能。\n<3> like查询时，以\'%\'开头，列所加的索引是不起作用的。\n<4> 在没有索引的前提下，当数据量比较大时，instr要比like效率高。 ', 'markdown', 0, 0, NULL, 8, 1659680940133, 1659685151027);

-- ----------------------------
-- Table structure for t_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_article_tag`;
CREATE TABLE `t_article_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_article_id`(`article_id`) USING BTREE,
  INDEX `idx_article_tag_tag_id`(`tag_id`) USING BTREE,
  INDEX `idx_article_tag_status`(`status`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_article_tag
-- ----------------------------
INSERT INTO `t_article_tag` VALUES (28, 7, 15, 0, 1659318214434);

-- ----------------------------
-- Table structure for t_check_in
-- ----------------------------
DROP TABLE IF EXISTS `t_check_in`;
CREATE TABLE `t_check_in`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `latest_day_name` bigint(20) NOT NULL,
  `consecutive_days` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `update_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_user_id`(`user_id`) USING BTREE,
  INDEX `idx_latest`(`latest_day_name`, `update_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_check_in
-- ----------------------------
INSERT INTO `t_check_in` VALUES (4, 2, 20231007, 1, 1656493940615, 1696667622961);
INSERT INTO `t_check_in` VALUES (5, 11, 20230324, 1, 1659336117390, 1679643170562);
INSERT INTO `t_check_in` VALUES (6, 10, 20230316, 1, 1659339247346, 1678930398173);
INSERT INTO `t_check_in` VALUES (7, 12, 20220805, 1, 1659410224878, 1659661458925);
INSERT INTO `t_check_in` VALUES (8, 19, 20221013, 1, 1665648816246, 1665648816246);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `entity_type` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `entity_id` bigint(20) NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `image_list` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `content_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `quote_id` bigint(20) NOT NULL,
  `like_count` bigint(20) NOT NULL DEFAULT 0,
  `comment_count` bigint(20) NOT NULL DEFAULT 0,
  `user_agent` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `ip` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `status` bigint(20) NULL DEFAULT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_comment_user_id`(`user_id`) USING BTREE,
  INDEX `idx_comment_entity_type`(`entity_type`) USING BTREE,
  INDEX `idx_comment_entity_id`(`entity_id`) USING BTREE,
  INDEX `idx_comment_status`(`status`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 79 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (46, 7, 'topic', 19, '话题详情代码没有高亮显示', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1659321257491);
INSERT INTO `t_comment` VALUES (47, 9, 'topic', 19, 'hello word', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 0, 1659335472158);
INSERT INTO `t_comment` VALUES (48, 11, 'topic', 25, '猴赛雷1', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1659336078178);
INSERT INTO `t_comment` VALUES (49, 2, 'comment', 46, '已完成', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1659343300202);
INSERT INTO `t_comment` VALUES (50, 2, 'topic', 28, 'linux 写错了~', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1659412403608);
INSERT INTO `t_comment` VALUES (51, 9, 'comment', 50, '哦豁~\n', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659412631482);
INSERT INTO `t_comment` VALUES (52, 2, 'topic', 30, 'mark', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659422208185);
INSERT INTO `t_comment` VALUES (53, 12, 'topic', 25, '后面可以针对各个项目的大屏设计，做一个收集的帖子置顶', '', 'text', 0, 0, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659424000150);
INSERT INTO `t_comment` VALUES (54, 2, 'comment', 53, '可以放在推荐里面，没有那么多置顶席位', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659429220870);
INSERT INTO `t_comment` VALUES (55, 2, 'comment', 53, '后台可以设置推荐', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659429238305);
INSERT INTO `t_comment` VALUES (56, 10, 'topic', 19, '这里可以加个返回上一页按钮吗，因为目前返回好像只能点浏览器退回键返回>.<', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a058dbc-4ec8-9236-7c12-fca13da7c327_96a73b43a2ff720de079eabe035d0b3.jpg\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a058dbc-4ec8-9236-7c12-fca13da7c327_96a73b43a2ff720de079eabe035d0b3.jpg\"}]', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 0, 1659930376865);
INSERT INTO `t_comment` VALUES (57, 2, 'comment', 56, '加返回按钮可能不好加，可以改成在新标签页打开', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 0, 1659938161298);
INSERT INTO `t_comment` VALUES (58, 11, 'topic', 19, 'http://192.168.1.83:5000/topic/47\n加个点击图片放大的功能吧', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1660202437143);
INSERT INTO `t_comment` VALUES (59, 11, 'topic', 47, '求置顶 求推荐 求一键三连！', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1660202571962);
INSERT INTO `t_comment` VALUES (60, 2, 'comment', 58, 'ok', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 0, 1660202931751);
INSERT INTO `t_comment` VALUES (61, 2, 'comment', 59, '给你加到推荐板块吧', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 0, 1660203088219);
INSERT INTO `t_comment` VALUES (62, 11, 'topic', 47, '点赞过 10 个，加更 Post 请求', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1660203104614);
INSERT INTO `t_comment` VALUES (63, 11, 'topic', 47, '点赞过 20 个，加更视频讲解', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 0, 1660203121216);
INSERT INTO `t_comment` VALUES (64, 2, 'topic', 47, '怎么感觉你的图片好糊啊，你的原图也是这样嘛', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 0, 1660206685382);
INSERT INTO `t_comment` VALUES (65, 10, 'topic', 47, '⭐⭐⭐⭐⭐', '', 'text', 0, 1, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 0, 1660209184585);
INSERT INTO `t_comment` VALUES (66, 19, 'topic', 19, '积分你负责换钱么?[手动狗头]', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 0, 1665648742448);
INSERT INTO `t_comment` VALUES (67, 2, 'comment', 66, '10000：1 ？[手动狗头]', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.42', '::ffff:172.17.0.1', 0, 1665648934211);
INSERT INTO `t_comment` VALUES (68, 19, 'topic', 69, '会报这个npm ERR node-sass@4.14.1 postinstall `node scriptsbuild.js`错误是吧?https://blog.csdn.net/m0_67393039/article/details/126113789', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 0, 1666316173014);
INSERT INTO `t_comment` VALUES (69, 19, 'topic', 69, '温总给了这个作参考\n', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 0, 1666316210914);
INSERT INTO `t_comment` VALUES (70, 11, 'topic', 64, '补充一下 ，执行完后如未解决改问题 可重启试试', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.50', '::ffff:172.17.0.1', 0, 1669348623662);
INSERT INTO `t_comment` VALUES (71, 2, 'topic', 75, '输出DTO属性里面建议增加一个 TypeName 字段来存对应名称的值~', '', 'text', 0, 0, 1, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.56', '::ffff:172.17.0.1', 0, 1669629355034);
INSERT INTO `t_comment` VALUES (72, 9, 'topic', 76, '6666', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.56', '::ffff:172.17.0.1', 0, 1669711591452);
INSERT INTO `t_comment` VALUES (73, 9, 'comment', 71, '可以的~~', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.62', '::ffff:172.17.0.1', 0, 1669864915224);
INSERT INTO `t_comment` VALUES (74, 12, 'topic', 78, '可以针对数据泵层面的也整合一份，针对oracle数据库的备份与还原做个总结呢。且需注明数据泵与exp/imp的使用场景的差距', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36', '::ffff:172.17.0.1', 0, 1674010567758);
INSERT INTO `t_comment` VALUES (75, 2, 'topic', 83, '可以用 datebox 控件？', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42', '::ffff:172.17.0.1', 0, 1684293720471);
INSERT INTO `t_comment` VALUES (76, 2, 'topic', 90, '1', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.200', '::ffff:172.17.0.1', 0, 1692066142433);
INSERT INTO `t_comment` VALUES (77, 2, 'topic', 94, '管理控制台地址：http://192.168.1.83:5500/', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62', '::ffff:172.17.0.1', 0, 1694053802092);
INSERT INTO `t_comment` VALUES (78, 2, 'topic', 90, '1', '', 'text', 0, 0, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.41', '::ffff:172.17.0.1', 0, 1695799959933);

-- ----------------------------
-- Table structure for t_email_code
-- ----------------------------
DROP TABLE IF EXISTS `t_email_code`;
CREATE TABLE `t_email_code`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `email` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `code` varchar(8) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `token` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `title` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `used` tinyint(1) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `token`(`token`) USING BTREE,
  INDEX `idx_user_score_log_user_id`(`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_email_code
-- ----------------------------

-- ----------------------------
-- Table structure for t_favorite
-- ----------------------------
DROP TABLE IF EXISTS `t_favorite`;
CREATE TABLE `t_favorite`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `entity_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `entity_id` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_favorite_user_id`(`user_id`) USING BTREE,
  INDEX `idx_favorite_entity_type`(`entity_type`) USING BTREE,
  INDEX `idx_favorite_entity_id`(`entity_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_favorite
-- ----------------------------
INSERT INTO `t_favorite` VALUES (7, 2, 'topic', 30, 1659422220068);
INSERT INTO `t_favorite` VALUES (8, 15, 'topic', 47, 1660296750220);

-- ----------------------------
-- Table structure for t_link
-- ----------------------------
DROP TABLE IF EXISTS `t_link`;
CREATE TABLE `t_link`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `url` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `summary` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `logo` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_link
-- ----------------------------
INSERT INTO `t_link` VALUES (2, 'http://www.winjoinit.com', '文景信息', '上海文景信息科技有限公司成立于2012年，是专注于智慧港口的建设，深耕全球港航信息化事业的一站式物流信息化解决方案服务商。我们致力于以用户需求为根本、依托于先进信息技术、为客户提供高效、灵活、涵盖港航业全过程的一站式综合解决方案。', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056586-e7af-0797-1a92-1d0c89b5a138_wj2.png', 0, 1653987169922);
INSERT INTO `t_link` VALUES (3, 'http://www.ilogisticsnet.com/', '智运网', '智运网通过打通港口、铁路、公路、口岸等多式联运运输场景及数据， 为客户提供一站式多式联运解决方案、智慧物流全景数据服务、智能 供应链云应用平台及其增值衍生产品通道（供应链金融）等综合性服务', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a15-4a6a-215e-aadd-4892ea3df470_智运.png', 0, 1659332229816);
INSERT INTO `t_link` VALUES (4, 'http://192.168.1.75:3030/', 'YApi', 'YApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API，YApi 还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056edb-071e-3e05-6f53-a31311ae557a_yapi222.png', 0, 1659409942775);
INSERT INTO `t_link` VALUES (5, 'https://doc.winjoinit.com:12479/', '文景日报管理系统', '文景日报管理系统', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056eb9-606a-79c7-2c8b-01b63aba35a6_wj2.png', 0, 1659410091422);
INSERT INTO `t_link` VALUES (6, 'http://www.cxy521.com/', '程序员导航', 'CXY521(程序员我爱你)是一个致力于一站式程序员学习工作娱乐导航网站，以让程序员更便捷为使命，始终围绕程序员需求，为程序员提供最新工具导航', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056ec7-9380-bd3d-fb0b-56bb3d724994_开发.png', 0, 1659410186453);
INSERT INTO `t_link` VALUES (7, 'https://tool.lu/', '在线工具', '在线工具,开发人员工具,代码格式化、压缩、加密、解密,下载链接转换,json格式化,正则测试工具,favicon在线制作,字帖工具,中文简繁体转换,迅雷下载链接转换,进制转换,二维码,照片压缩,pdf合并', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056ec9-17c2-d090-8ad9-a614bf4598ed_工具箱.png', 0, 1659410230703);
INSERT INTO `t_link` VALUES (8, 'http://192.168.1.8:18080/', 'GitLab', 'GitLab Community Edition', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056ec6-b6e8-0d17-d308-778b58758769_gitlab.png', 0, 1659410965766);
INSERT INTO `t_link` VALUES (9, 'http://192.168.1.83:5500/', 'AgileConfig', 'AgileConfig配置中心', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0d7fba-2985-3c34-7d56-d53acb0d2ca7_agileconfig.png', 0, 1694055096419);

-- ----------------------------
-- Table structure for t_message
-- ----------------------------
DROP TABLE IF EXISTS `t_message`;
CREATE TABLE `t_message`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `from_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `title` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `quote_content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `type` bigint(20) NOT NULL,
  `extra_data` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_message_user_id`(`user_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_message
-- ----------------------------
INSERT INTO `t_message` VALUES (11, 7, 2, '回复了你的话题', '话题详情代码没有高亮显示\n', '《BUG反馈和优化建议》', 0, '{\"entityType\":\"topic\",\"entityId\":19,\"commentId\":46,\"quoteId\":0}', 1, 1659321257577);
INSERT INTO `t_message` VALUES (12, 9, 2, '回复了你的话题', 'hello word\n', '《BUG反馈和优化建议》', 0, '{\"entityType\":\"topic\",\"entityId\":19,\"commentId\":47,\"quoteId\":0}', 1, 1659335472306);
INSERT INTO `t_message` VALUES (13, 2, 11, '点赞了你的话题', '', '《郴州国际陆港大屏》', 2, '{\"topicId\":25,\"userId\":2}', 1, 1659336723005);
INSERT INTO `t_message` VALUES (14, 10, 11, '点赞了你的话题', '', '《郴州国际陆港大屏》', 2, '{\"topicId\":25,\"userId\":10}', 1, 1659337890254);
INSERT INTO `t_message` VALUES (15, 2, 7, '回复了你的评论', '已完成\n', '《话题详情代码没有高亮显示\n》', 1, '{\"entityType\":\"comment\",\"entityId\":46,\"commentId\":49,\"quoteId\":0}', 0, 1659343300293);
INSERT INTO `t_message` VALUES (16, 2, 9, '回复了你的话题', 'linux 写错了~\n', '《部署baget 管理包》', 0, '{\"entityType\":\"topic\",\"entityId\":28,\"commentId\":50,\"quoteId\":0}', 1, 1659412403663);
INSERT INTO `t_message` VALUES (17, 9, 2, '回复了你的评论', '哦豁~\n', '《linux 写错了~\n》', 1, '{\"entityType\":\"comment\",\"entityId\":50,\"commentId\":51,\"quoteId\":0}', 1, 1659412631513);
INSERT INTO `t_message` VALUES (18, 2, 12, '回复了你的话题', 'mark\n', '《统一社会信用代码JS校验》', 0, '{\"entityType\":\"topic\",\"entityId\":30,\"commentId\":52,\"quoteId\":0}', 1, 1659422208242);
INSERT INTO `t_message` VALUES (19, 2, 12, '点赞了你的话题', '', '《统一社会信用代码JS校验》', 2, '{\"topicId\":30,\"userId\":2}', 1, 1659422210186);
INSERT INTO `t_message` VALUES (20, 2, 12, '收藏了你的话题', '', '《统一社会信用代码JS校验》', 3, '{\"topicId\":30,\"userId\":2}', 1, 1659422220125);
INSERT INTO `t_message` VALUES (21, 12, 11, '回复了你的话题', '后面可以针对各个项目的大屏设计，做一个收集的帖子置顶\n', '《郴州国际陆港大屏》', 0, '{\"entityType\":\"topic\",\"entityId\":25,\"commentId\":53,\"quoteId\":0}', 1, 1659424000198);
INSERT INTO `t_message` VALUES (22, 2, 12, '回复了你的评论', '可以放在推荐里面，没有那么多置顶席位\n', '《后面可以针对各个项目的大屏设计，做一个收集的帖子置顶\n》', 1, '{\"entityType\":\"comment\",\"entityId\":53,\"commentId\":54,\"quoteId\":0}', 1, 1659429220903);
INSERT INTO `t_message` VALUES (23, 2, 12, '回复了你的评论', '后台可以设置推荐\n', '《后面可以针对各个项目的大屏设计，做一个收集的帖子置顶\n》', 1, '{\"entityType\":\"comment\",\"entityId\":53,\"commentId\":55,\"quoteId\":0}', 1, 1659429238375);
INSERT INTO `t_message` VALUES (24, 10, 11, '点赞了你的话题', '', '《SQL中instr和like的使用区别》', 2, '{\"topicId\":43,\"userId\":10}', 1, 1659928112081);
INSERT INTO `t_message` VALUES (25, 10, 2, '点赞了你的话题', '', '《.NET 6 使用 log4net 记录日志》', 2, '{\"topicId\":41,\"userId\":10}', 1, 1659928217975);
INSERT INTO `t_message` VALUES (26, 10, 2, '回复了你的话题', '这里可以加个返回上一页按钮吗，因为目前返回好像只能点浏览器退回键返回>.<\n', '《BUG反馈和优化建议》', 0, '{\"entityType\":\"topic\",\"entityId\":19,\"commentId\":56,\"quoteId\":0}', 1, 1659930376948);
INSERT INTO `t_message` VALUES (27, 2, 10, '回复了你的评论', '加返回按钮可能不好加，可以改成在新标签页打开\n', '《这里可以加个返回上一页按钮吗，因为目前返回好像只能点浏览器退回键返回>.<\n》', 1, '{\"entityType\":\"comment\",\"entityId\":56,\"commentId\":57,\"quoteId\":0}', 1, 1659938161345);
INSERT INTO `t_message` VALUES (28, 11, 2, '回复了你的话题', 'http://192.168.1.83:5000/topic/47\n加个点击图片放大的功能吧\n', '《BUG反馈和优化建议》', 0, '{\"entityType\":\"topic\",\"entityId\":19,\"commentId\":58,\"quoteId\":0}', 1, 1660202437193);
INSERT INTO `t_message` VALUES (29, 2, 11, '回复了你的评论', 'ok\n', '《http://192.168.1.83:5000/topic/47\n加个点击图片放大的功能吧\n》', 1, '{\"entityType\":\"comment\",\"entityId\":58,\"commentId\":60,\"quoteId\":0}', 1, 1660202931782);
INSERT INTO `t_message` VALUES (30, 8, 11, '点赞了你的话题', '', '《KETTLE工具使用（给个一键三连不过分吧）》', 2, '{\"topicId\":47,\"userId\":8}', 1, 1660203055459);
INSERT INTO `t_message` VALUES (31, 2, 11, '回复了你的评论', '给你加到推荐板块吧\n', '《求置顶 求推荐 求一键三连！\n》', 1, '{\"entityType\":\"comment\",\"entityId\":59,\"commentId\":61,\"quoteId\":0}', 1, 1660203088247);
INSERT INTO `t_message` VALUES (32, 1, 11, '你的话题被设为推荐', '', '《KETTLE工具使用（给个一键三连不过分吧）》', 4, '{\"topicId\":47,\"userId\":1}', 1, 1660203147933);
INSERT INTO `t_message` VALUES (33, 2, 11, '回复了你的话题', '怎么感觉你的图片好糊啊，你的原图也是这样嘛\n', '《KETTLE工具使用（第一章节）（给个一键三连不过分吧）》', 0, '{\"entityType\":\"topic\",\"entityId\":47,\"commentId\":64,\"quoteId\":0}', 1, 1660206685427);
INSERT INTO `t_message` VALUES (34, 2, 11, '点赞了你的话题', '', '《KETTLE工具使用（第一章节）（给个一键三连不过分吧）》', 2, '{\"topicId\":47,\"userId\":2}', 1, 1660207059679);
INSERT INTO `t_message` VALUES (35, 10, 11, '回复了你的话题', '⭐⭐⭐⭐⭐\n', '《KETTLE工具使用（第一章节）（给个一键三连不过分吧）》', 0, '{\"entityType\":\"topic\",\"entityId\":47,\"commentId\":65,\"quoteId\":0}', 1, 1660209184611);
INSERT INTO `t_message` VALUES (36, 15, 11, '点赞了你的话题', '', '《果园港国家物流枢纽智慧多式联运信息服务平台--大屏》', 2, '{\"topicId\":49,\"userId\":15}', 1, 1660296118167);
INSERT INTO `t_message` VALUES (37, 15, 11, '收藏了你的话题', '', '《KETTLE工具使用（第一章节）（给个一键三连不过分吧）》', 3, '{\"topicId\":47,\"userId\":15}', 1, 1660296750287);
INSERT INTO `t_message` VALUES (38, 15, 11, '点赞了你的话题', '', '《KETTLE工具使用（第一章节）（给个一键三连不过分吧）》', 2, '{\"topicId\":47,\"userId\":15}', 1, 1660296751705);
INSERT INTO `t_message` VALUES (39, 10, 11, '点赞了你的话题', '', '《果园港国家物流枢纽智慧多式联运信息服务平台--大屏》', 2, '{\"topicId\":49,\"userId\":10}', 1, 1660724653025);
INSERT INTO `t_message` VALUES (40, 2, 16, '点赞了你的话题', '', '《文景·行业速递（2022年8月第3期，总第41期）》', 2, '{\"topicId\":51,\"userId\":2}', 0, 1661132904187);
INSERT INTO `t_message` VALUES (41, 11, 16, '点赞了你的话题', '', '《文景·行业速递（2022年8月第3期，总第41期）》', 2, '{\"topicId\":51,\"userId\":11}', 0, 1661220032000);
INSERT INTO `t_message` VALUES (42, 10, 16, '点赞了你的话题', '', '《文景·行业速递（2022年8月第3期，总第41期）》', 2, '{\"topicId\":51,\"userId\":10}', 0, 1661238079428);
INSERT INTO `t_message` VALUES (43, 10, 2, '点赞了你的话题', '', '《模式匹配概述》', 2, '{\"topicId\":57,\"userId\":10}', 1, 1661906587020);
INSERT INTO `t_message` VALUES (44, 17, 2, '点赞了你的话题', '', '《Oracle与DM无区别的函数》', 2, '{\"topicId\":56,\"userId\":17}', 1, 1663309782005);
INSERT INTO `t_message` VALUES (45, 19, 2, '回复了你的话题', '积分你负责换钱么?[手动狗头]\n', '《BUG反馈和优化建议》', 0, '{\"entityType\":\"topic\",\"entityId\":19,\"commentId\":66,\"quoteId\":0}', 1, 1665648742499);
INSERT INTO `t_message` VALUES (46, 2, 19, '回复了你的评论', '10000：1 ？[手动狗头]\n', '《积分你负责换钱么?[手动狗头]\n》', 1, '{\"entityType\":\"comment\",\"entityId\":66,\"commentId\":67,\"quoteId\":0}', 1, 1665648934243);
INSERT INTO `t_message` VALUES (47, 9, 2, '点赞了你的话题', '', '《SqlSugar 库表操作》', 2, '{\"topicId\":61,\"userId\":9}', 1, 1665650364410);
INSERT INTO `t_message` VALUES (48, 19, 9, '回复了你的话题', '会报这个npm ERR node-sass@4.14.1 postinstall node scriptsbuild.js错误是吧?https://blog.csdn.net/m0_67393039/article/details/126113789\n', '《node版本对应的  node-sass，sass-loader 版本》', 0, '{\"entityType\":\"topic\",\"entityId\":69,\"commentId\":68,\"quoteId\":0}', 1, 1666316173069);
INSERT INTO `t_message` VALUES (49, 19, 9, '回复了你的话题', '温总给了这个作参考\n', '《node版本对应的  node-sass，sass-loader 版本》', 0, '{\"entityType\":\"topic\",\"entityId\":69,\"commentId\":69,\"quoteId\":0}', 1, 1666316210952);
INSERT INTO `t_message` VALUES (50, 10, 2, '点赞了你的话题', '', '《EasyUI 中 datagrid 底部添加合计行前端实现方案》', 2, '{\"topicId\":71,\"userId\":10}', 1, 1667457705465);
INSERT INTO `t_message` VALUES (51, 9, 2, '点赞了你的话题', '', '《JS 支持多文件上传组件封装》', 2, '{\"topicId\":74,\"userId\":9}', 1, 1668681271382);
INSERT INTO `t_message` VALUES (52, 11, 2, '回复了你的话题', '补充一下 ，执行完后如未解决改问题 可重启试试\n', '《用SqlSugar连接达梦数据库，显示找不到方法Dm.DmCommand.get_Parameters()》', 0, '{\"entityType\":\"topic\",\"entityId\":64,\"commentId\":70,\"quoteId\":0}', 1, 1669348623709);
INSERT INTO `t_message` VALUES (53, 11, 9, '点赞了你的话题', '', '《列表返回的时候字典名称问题显示》', 2, '{\"topicId\":75,\"userId\":11}', 0, 1669600192552);
INSERT INTO `t_message` VALUES (54, 11, 2, '点赞了你的话题', '', '《JS 支持多文件上传组件封装》', 2, '{\"topicId\":74,\"userId\":11}', 1, 1669600232797);
INSERT INTO `t_message` VALUES (55, 2, 9, '点赞了你的话题', '', '《列表返回的时候字典名称问题显示》', 2, '{\"topicId\":75,\"userId\":2}', 0, 1669629273037);
INSERT INTO `t_message` VALUES (56, 2, 9, '回复了你的话题', '输出DTO属性里面建议增加一个 TypeName 字段来存对应名称的值~\n', '《列表返回的时候字典名称问题显示》', 0, '{\"entityType\":\"topic\",\"entityId\":75,\"commentId\":71,\"quoteId\":0}', 0, 1669629355071);
INSERT INTO `t_message` VALUES (57, 9, 2, '点赞了你的话题', '', '《多环境下Web.config配置》', 2, '{\"topicId\":76,\"userId\":9}', 1, 1669711588464);
INSERT INTO `t_message` VALUES (58, 9, 2, '回复了你的话题', '6666\n', '《多环境下Web.config配置》', 0, '{\"entityType\":\"topic\",\"entityId\":76,\"commentId\":72,\"quoteId\":0}', 1, 1669711591485);
INSERT INTO `t_message` VALUES (59, 9, 2, '回复了你的评论', '可以的~~\n', '《输出DTO属性里面建议增加一个 TypeName 字段来存对应名称的值~\n》', 1, '{\"entityType\":\"comment\",\"entityId\":71,\"commentId\":73,\"quoteId\":0}', 1, 1669864915247);
INSERT INTO `t_message` VALUES (60, 12, 2, '回复了你的话题', '可以针对数据泵层面的也整合一份，针对oracle数据库的备份与还原做个总结呢。且需注明数据泵与exp/imp的使用场景的差距\n', '《ORACLE使用exp和imp导入导出命令》', 0, '{\"entityType\":\"topic\",\"entityId\":78,\"commentId\":74,\"quoteId\":0}', 1, 1674010567815);
INSERT INTO `t_message` VALUES (61, 2, 11, '回复了你的话题', '可以用 datebox 控件？\n', '《datetimebox 日期控件绑定双击日期选择时间》', 0, '{\"entityType\":\"topic\",\"entityId\":83,\"commentId\":75,\"quoteId\":0}', 1, 1684293720532);

-- ----------------------------
-- Table structure for t_operate_log
-- ----------------------------
DROP TABLE IF EXISTS `t_operate_log`;
CREATE TABLE `t_operate_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `op_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `data_type` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `data_id` bigint(20) NOT NULL,
  `description` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `ip` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `user_agent` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `referer` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_operate_log_user_id`(`user_id`) USING BTREE,
  INDEX `idx_op_type`(`op_type`) USING BTREE,
  INDEX `idx_operate_log_data`(`data_type`, `data_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_operate_log
-- ----------------------------

-- ----------------------------
-- Table structure for t_project
-- ----------------------------
DROP TABLE IF EXISTS `t_project`;
CREATE TABLE `t_project`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `name` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `title` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `logo` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `doc_url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `download_url` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_project_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_project
-- ----------------------------

-- ----------------------------
-- Table structure for t_sys_config
-- ----------------------------
DROP TABLE IF EXISTS `t_sys_config`;
CREATE TABLE `t_sys_config`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `key` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `value` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `description` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `create_time` bigint(20) NOT NULL,
  `update_time` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `key`(`key`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_sys_config
-- ----------------------------
INSERT INTO `t_sys_config` VALUES (1, 'siteTitle', '文景社区', '站点标题', '站点标题', 1644198944000, 1659316647268);
INSERT INTO `t_sys_config` VALUES (2, 'siteDescription', '文景社区，文景内部社区交流平台', '站点描述', '站点描述', 1644198944000, 1659316647273);
INSERT INTO `t_sys_config` VALUES (3, 'siteKeywords', '[]', '站点关键字', '站点关键字', 1644198944000, 1659316647276);
INSERT INTO `t_sys_config` VALUES (4, 'siteNavs', '[{\"title\":\"话题\",\"url\":\"/topics\"},{\"title\":\"文章\",\"url\":\"/articles\"}]', '站点导航', '站点导航', 1644198944000, 1659316647294);
INSERT INTO `t_sys_config` VALUES (5, 'defaultNodeId', '5', '默认节点', '默认节点', 1644198944000, 1659316647285);
INSERT INTO `t_sys_config` VALUES (6, 'tokenExpireDays', '365', '用户登录有效期(天)', '用户登录有效期(天)', 1644198944000, 1659316647318);
INSERT INTO `t_sys_config` VALUES (7, 'scoreConfig', '{\"postTopicScore\":1,\"postCommentScore\":1,\"checkInScore\":1}', '积分配置', '积分配置', 1644198944000, 1659316647298);
INSERT INTO `t_sys_config` VALUES (8, 'userObserveSeconds', '0', '', '', 1644300874193, 1659316647315);
INSERT INTO `t_sys_config` VALUES (9, 'siteNotification', '', '', '', 1644300874197, 1659316647279);
INSERT INTO `t_sys_config` VALUES (10, 'topicCaptcha', 'True', '', '', 1644300874201, 1659316647301);
INSERT INTO `t_sys_config` VALUES (11, 'recommendTags', '[\"分享\",\"Java\",\".NET\",\"VUE\"]', '', '', 1644300874205, 1659316647282);
INSERT INTO `t_sys_config` VALUES (12, 'articlePending', 'False', '', '', 1644300874207, 1659316647313);
INSERT INTO `t_sys_config` VALUES (13, 'urlRedirect', 'True', '', '', 1644300874209, 1659316647291);
INSERT INTO `t_sys_config` VALUES (14, 'loginMethod', '{\"password\":true,\"qq\":false,\"github\":false,\"osc\":false}', '', '', 1644300874212, 1659316647288);
INSERT INTO `t_sys_config` VALUES (15, 'createTopicEmailVerified', 'False', '', '', 1644300874212, 1659316647304);
INSERT INTO `t_sys_config` VALUES (16, 'createArticleEmailVerified', 'False', '', '', 1644300874214, 1659316647307);
INSERT INTO `t_sys_config` VALUES (17, 'createCommentEmailVerified', 'False', '', '', 1644300874215, 1659316647310);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `description` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `update_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE,
  INDEX `idx_tag_status`(`status`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 71 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (1, 'Oracle', 'Oracle', 0, 1644301025418, 1650966910633);
INSERT INTO `t_tag` VALUES (6, 'Abp vNext', '现代web应用程序开发框架', 0, 1650966178742, 1651139012880);
INSERT INTO `t_tag` VALUES (7, '数据结构', '数据结构', 0, 1650971012364, 1650971012364);
INSERT INTO `t_tag` VALUES (8, 'C#', 'C#语言', 0, 1650971098376, 1650971098376);
INSERT INTO `t_tag` VALUES (9, 'Java', 'Java语言', 0, 1650971189142, 1650971189143);
INSERT INTO `t_tag` VALUES (11, 'MySql', 'mysql数据库', 0, 1651138834027, 1651138983258);
INSERT INTO `t_tag` VALUES (12, '武汉', '武汉', 0, 1653387800870, 1653387800870);
INSERT INTO `t_tag` VALUES (13, 'linux', 'linux', 0, 1653785602158, 1653785602158);
INSERT INTO `t_tag` VALUES (14, 'tmux', 'tmux', 0, 1653785602158, 1653785602158);
INSERT INTO `t_tag` VALUES (15, '文章', '文章', 0, 1654257916066, 1654257916066);
INSERT INTO `t_tag` VALUES (16, '测试', '测试', 0, 1655801391990, 1655801391990);
INSERT INTO `t_tag` VALUES (17, 'docker', 'docker', 0, 1655802116460, 1655802116460);
INSERT INTO `t_tag` VALUES (18, '分布式架构', '分布式架构', 0, 1655861355273, 1655861355273);
INSERT INTO `t_tag` VALUES (19, '国际', '国际', 0, 1655861690208, 1655861690208);
INSERT INTO `t_tag` VALUES (20, '俄乌形势', '俄乌形势', 0, 1655861690208, 1655861690208);
INSERT INTO `t_tag` VALUES (21, '俄乌局势', '俄乌局势', 0, 1655861690208, 1655861690208);
INSERT INTO `t_tag` VALUES (22, '建议', '建议', 0, 1655866522861, 1655866522861);
INSERT INTO `t_tag` VALUES (23, 'Go', 'Go', 0, 1656057105994, 1656057105994);
INSERT INTO `t_tag` VALUES (24, 'Hertz', 'Hertz', 0, 1656057105994, 1656057105994);
INSERT INTO `t_tag` VALUES (25, '反馈', '反馈', 0, 1659268305713, 1659268305713);
INSERT INTO `t_tag` VALUES (26, '分布式', '分布式', 0, 1659270926221, 1659270926221);
INSERT INTO `t_tag` VALUES (27, 'ID', 'ID', 0, 1659270926221, 1659270926221);
INSERT INTO `t_tag` VALUES (28, '.NET', '.NET', 0, 1659317088143, 1659317088143);
INSERT INTO `t_tag` VALUES (29, 'int', 'int', 0, 1659317088143, 1659317088143);
INSERT INTO `t_tag` VALUES (30, 'byte', 'byte', 0, 1659317088143, 1659317088143);
INSERT INTO `t_tag` VALUES (32, 'GUID', 'GUID', 0, 1659319121235, 1659319121235);
INSERT INTO `t_tag` VALUES (33, '模式', '模式', 0, 1659321115018, 1659321115018);
INSERT INTO `t_tag` VALUES (34, '模式匹配', '模式匹配', 0, 1659321115018, 1659321115018);
INSERT INTO `t_tag` VALUES (35, 'PLSQL', 'PLSQL', 0, 1659332439073, 1659332439073);
INSERT INTO `t_tag` VALUES (36, 'cron', 'cron', 0, 1659332620399, 1659332620399);
INSERT INTO `t_tag` VALUES (37, 'wsdl', 'wsdl', 0, 1659336646522, 1659336646522);
INSERT INTO `t_tag` VALUES (38, 'winsw', 'winsw', 0, 1659339231163, 1659339231163);
INSERT INTO `t_tag` VALUES (39, 'windows服务', 'windows服务', 0, 1659339231163, 1659339231163);
INSERT INTO `t_tag` VALUES (40, '社区', '社区', 0, 1659341690158, 1659341690158);
INSERT INTO `t_tag` VALUES (41, '分享', '分享', 0, 1659421045657, 1659421045657);
INSERT INTO `t_tag` VALUES (42, 'DM', 'DM', 0, 1659506699857, 1659506699857);
INSERT INTO `t_tag` VALUES (43, '迁移', '迁移', 0, 1659597746603, 1659597746603);
INSERT INTO `t_tag` VALUES (44, '移植', '移植', 0, 1659602302916, 1659602302916);
INSERT INTO `t_tag` VALUES (45, 'MD5', 'MD5', 0, 1659667631258, 1659667631258);
INSERT INTO `t_tag` VALUES (46, 'log4net', 'log4net', 0, 1659669431956, 1659669431956);
INSERT INTO `t_tag` VALUES (47, 'ETL', 'ETL', 0, 1660202178004, 1660202178004);
INSERT INTO `t_tag` VALUES (48, 'KETTLE', 'KETTLE', 0, 1660202178004, 1660202178004);
INSERT INTO `t_tag` VALUES (49, '集合', '集合', 0, 1660698992315, 1660698992315);
INSERT INTO `t_tag` VALUES (50, 'sqlsugar', 'sqlsugar', 0, 1661235598649, 1661235598649);
INSERT INTO `t_tag` VALUES (51, '达梦', '达梦', 0, 1661235598649, 1661235598649);
INSERT INTO `t_tag` VALUES (52, '.NET Standard', '.NET Standard', 0, 1663146282704, 1663146282704);
INSERT INTO `t_tag` VALUES (53, 'FreeRedis', 'FreeRedis', 0, 1663895290666, 1663895290666);
INSERT INTO `t_tag` VALUES (54, 'MQTT', 'MQTT', 0, 1665383531176, 1665383531176);
INSERT INTO `t_tag` VALUES (55, 'uniapp', 'uniapp', 0, 1665650932513, 1665650932513);
INSERT INTO `t_tag` VALUES (56, 'EasyUI', 'EasyUI', 0, 1666618303591, 1666618303591);
INSERT INTO `t_tag` VALUES (57, 'datagrid', 'datagrid', 0, 1666618303591, 1666618303591);
INSERT INTO `t_tag` VALUES (58, 'C#11', 'C#11', 0, 1668580292218, 1668580292218);
INSERT INTO `t_tag` VALUES (59, 'multiple', 'multiple', 0, 1668602410534, 1668602410534);
INSERT INTO `t_tag` VALUES (60, 'web.config', 'web.config', 0, 1669631568781, 1669631568781);
INSERT INTO `t_tag` VALUES (61, '导出', '导出', 0, 1671518725759, 1671518725759);
INSERT INTO `t_tag` VALUES (62, 'exp', 'exp', 0, 1672897512482, 1672897512482);
INSERT INTO `t_tag` VALUES (63, 'imp', 'imp', 0, 1672897512482, 1672897512482);
INSERT INTO `t_tag` VALUES (64, 'BLANK_PAD_MODE', 'BLANK_PAD_MODE', 0, 1677113498602, 1677113498602);
INSERT INTO `t_tag` VALUES (65, 'COMPATIBLE_MODE', 'COMPATIBLE_MODE', 0, 1677113813916, 1677113813916);
INSERT INTO `t_tag` VALUES (66, '扩展函数', '扩展函数', 0, 1679274180275, 1679274180275);
INSERT INTO `t_tag` VALUES (67, 'NPOI', 'NPOI', 0, 1684293622503, 1684293622503);
INSERT INTO `t_tag` VALUES (68, 'Span', 'Span', 0, 1684302471333, 1684302471333);
INSERT INTO `t_tag` VALUES (69, 'Random', 'Random', 0, 1689556627841, 1689556627841);
INSERT INTO `t_tag` VALUES (70, 'AgileConfig', 'AgileConfig', 0, 1694053718335, 1694053718335);

-- ----------------------------
-- Table structure for t_third_account
-- ----------------------------
DROP TABLE IF EXISTS `t_third_account`;
CREATE TABLE `t_third_account`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `avatar` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `nickname` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `third_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `third_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `extra_data` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `update_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_third`(`third_id`) USING BTREE,
  UNIQUE INDEX `idx_user_id_third_type`(`user_id`, `third_type`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_third_account
-- ----------------------------

-- ----------------------------
-- Table structure for t_topic
-- ----------------------------
DROP TABLE IF EXISTS `t_topic`;
CREATE TABLE `t_topic`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` bigint(20) NOT NULL,
  `node_id` bigint(20) NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `image_list` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `recommend` tinyint(1) NOT NULL,
  `recommend_time` bigint(20) NOT NULL,
  `view_count` bigint(20) NOT NULL,
  `comment_count` bigint(20) NOT NULL,
  `like_count` bigint(20) NOT NULL,
  `status` bigint(20) NULL DEFAULT NULL,
  `last_comment_time` bigint(20) NULL DEFAULT NULL,
  `last_comment_user_id` bigint(20) NULL DEFAULT NULL,
  `user_agent` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `ip` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `extra_data` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `sticky` bit(1) NULL DEFAULT b'0',
  `sticky_time` bigint(20) NOT NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_node_id`(`node_id`) USING BTREE,
  INDEX `idx_topic_user_id`(`user_id`) USING BTREE,
  INDEX `idx_recommend`(`recommend`) USING BTREE,
  INDEX `idx_topic_status`(`status`) USING BTREE,
  INDEX `idx_topic_last_comment_time`(`last_comment_time`) USING BTREE,
  INDEX `idx_topic_create_time`(`create_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 98 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_topic
-- ----------------------------
INSERT INTO `t_topic` VALUES (8, 0, 1, 2, 'CentOS安装Docker教程', '卸载老版本\n``` \n  yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine\n```\n安装依赖的包\n``` \n  yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n```\n设置存储库\n```\n  yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n安装最新版本的Docker CE\n```\n  yum install -y docker-ce\n```\n启动和停止Docker\n```\n  systemctl start docker\n  systemctl stop docker\n```\n验证Docker是否安装成功\n```\n  docker version\n  docker run hello-world\n```\n设置服务随系统重启后自动启动\n```\n  systemctl enable docker\n```\n', '', 0, 0, 28, 0, 0, 0, 1655802116460, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36 Edg/102.0.1245.41', '127.0.0.1', 1655802116460, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (10, 0, 1, 2, '9种分布式ID生成方案，让你一次学个够', '一、为什么要用分布式ID？\n=============\n\n在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？\n\n1、什么是分布式ID？\n===========\n\n拿MySQL数据库举个栗子：\n\n在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。\n\n但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。那么这个全局唯一ID就叫分布式ID。\n\n2、那么分布式ID需要满足哪些条件？\n==================\n\n*   全局唯一：必须保证ID是全局性唯一的，基本要求\n*   高性能：高可用低延时，ID生成响应要快，否则反倒会成为业务瓶颈\n*   高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性\n*   好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单\n*   趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求\n\n二、 分布式ID都有哪些生成方式？\n=================\n\n今天主要分析一下以下9种，分布式ID生成器方式以及优缺点：\n\n*   UUID\n*   数据库自增ID\n*   数据库多主模式\n*   号段模式\n*   Redis\n*   雪花算法（SnowFlake）\n*   滴滴出品（TinyID）\n*   百度 （Uidgenerator）\n*   美团（Leaf）\n\n那么它们都是如何实现？以及各自有什么优缺点？我们往下看\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05666a-33a8-5770-718b-867d7c7f4da9_3f6b42cd9596b438c1df052505c4d9cb!detail.png)\n\n> 以上图片源自网络，如有侵权联系删除\n\n1、基于UUID\n========\n\n在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？**答案是可以的，但是并不推荐！**\n\n``` Java\n\npublic static void main(String[] args) { \n       String uuid = UUID.randomUUID().toString().replaceAll(\"-\",\"\");\n       System.out.println(uuid);\n }\n\n```\n\nUUID的生成简单到只有一行代码，输出结果  \nc2b8c2b9e46c47e3b30dca3b0d447718，但UUID却并不适用于实际的业务需求。像用作订单号UUID这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。\n\n**优点：**\n\n*   生成足够简单，本地生成无网络消耗，具有唯一性\n\n**缺点：**\n\n*   无序的字符串，不具备趋势自增特性\n*   没有具体的业务含义\n*   长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。\n\n2、基于数据库自增ID\n===========\n\n基于数据库的auto\\_increment自增ID完全可以充当分布式ID，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：\n\n```\nCREATE DATABASE `SEQ_ID`;\nCREATE TABLE SEQID.SEQUENCE_ID (\n    id bigint(20) unsigned NOT NULL auto_increment,    value char(10) NOT NULL default \'\',    PRIMARY KEY (id),\n) ENGINE=MyISAM;\n\n```\n```\ninsert into SEQUENCE_ID(value) VALUES (\'values\');\n\n```\n\n当我们需要一个ID的时候，向表中插入一条记录返回主键ID，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！\n\n**优点：**\n\n*   实现简单，ID单调自增，数值类型查询速度快\n\n**缺点：**\n\n*   DB单点存在宕机风险，无法扛住高并发场景\n\n3、基于数据库集群模式\n===========\n\n前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。\n\n那这样还会有个问题，两个MySQL实例的自增ID都从1开始，**会生成重复的ID怎么办？**\n\n**解决方案**：设置起始值和自增步长\n\nMySQL\\_1 配置：\n\n```\nset @@auto_increment_offset = 1;     -- 起始值\nset @@auto_increment_increment = 2;  -- 步长\n\n```\n\nMySQL\\_2 配置：\n\n```\nset @@auto_increment_offset = 2;     -- 起始值\nset @@auto_increment_increment = 2;  -- 步长\n\n```\n\n这样两个MySQL实例的自增ID分别就是：\n\n> 1、3、5、7、9  \n> 2、4、6、8、10\n\n那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05666b-b052-c1c7-2ebf-8db43031568c_a1edecaae30ac3ae3d158b86761891aa!detail.png)\n\n从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。\n\n增加第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长，把第三台机器的ID起始生成位置设定在比现有最大自增ID的位置远一些，但必须在一、二两台MySQL实例ID还没有增长到第三台MySQL实例的起始ID值的时候，否则自增ID就要出现重复了，**必要时可能还需要停机修改**。\n\n**优点：**\n\n*   解决DB单点问题\n\n**缺点：**\n\n*   不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。\n\n4、基于数据库的号段模式\n============\n\n号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000\\] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：\n\n```\nCREATE TABLE id_generator (\n  id int(10) NOT NULL,  max_id bigint(20) NOT NULL COMMENT \'当前最大id\',  step int(20) NOT NULL COMMENT \'号段的布长\',  biz_type    int(20) NOT NULL COMMENT \'业务类型\',  version int(20) NOT NULL COMMENT \'版本号\',  PRIMARY KEY (`id`)\n)\n\n```\n\nbiz\\_type ：代表不同业务类型\n\nmax\\_id ：当前最大的可用id\n\nstep ：代表号段的长度\n\nversion ：是一个乐观锁，每次都更新version，保证并发时数据的正确性\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05666c-4c74-1f5b-de6b-c89c9a5bb933_7a2ac147904b913c32f856e8048121e4!detail.png)\n\n等这批号段ID用完，再次向数据库申请新号段，对max\\_id字段做一次update操作，update max\\_id= max\\_id + step，update成功则说明新号段获取成功，新的号段范围是(max\\_id ,max\\_id +step\\]。\n\n```\nupdate id_generator set max_id = #{max_id+step}, version = version + 1 where version = # {version} and biz_type = XXX\n\n```\n\n由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。\n\n5、基于Redis模式\n===========\n\nRedis也同样可以实现，原理就是利用redis的 incr命令实现ID的原子性自增。\n\n```\n127.0.0.1:6379> set seq_id 1     // 初始化自增ID为1\nOK\n127.0.0.1:6379> incr seq_id      // 增加1，并返回递增后的数值\n(integer) 2\n\n```\n\n用redis实现需要注意一点，要考虑到redis持久化的问题。redis有两种持久化方式RDB和AOF\n\n*   RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。\n\n6、基于雪花算法（Snowflake）模式\n=====================\n\n雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05666c-c661-8f15-24f6-b5829787a01d_167819d1f7f2cf96c1b98ea196e933f5!detail.png)\n\n> 以上图片源自网络，如有侵权联系删除\n\nSnowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。\n\nSnowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。\n\n*   第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。\n*   时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L << 41) / (1000L 60 60 24 365) = 69年\n*   工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。\n*   序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID\n\n根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。\n\n**Java版本的Snowflake算法实现：**\n\n``` Java\n\n/**\n * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL\n *\n * https://github.com/beyondfengyu/SnowFlake\n */\npublic class SnowFlakeShortUrl {\n    /**\n     * 起始的时间戳\n     */\n    private final static long START_TIMESTAMP = 1480166465631L;\n    /**\n     * 每一部分占用的位数\n     */\n    private final static long SEQUENCE_BIT = 12;   //序列号占用的位数\n    private final static long MACHINE_BIT = 5;     //机器标识占用的位数\n    private final static long DATA_CENTER_BIT = 5; //数据中心占用的位数\n    /**\n     * 每一部分的最大值\n     */\n    private final static long MAX_SEQUENCE = -1L ^ (-1L << SEQUENCE_BIT);\n    private final static long MAX_MACHINE_NUM = -1L ^ (-1L << MACHINE_BIT);\n    private final static long MAX_DATA_CENTER_NUM = -1L ^ (-1L << DATA_CENTER_BIT);\n    /**\n     * 每一部分向左的位移\n     */\n    private final static long MACHINE_LEFT = SEQUENCE_BIT;\n    private final static long DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;\n    private final static long TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;\n    private long dataCenterId;  //数据中心\n    private long machineId;     //机器标识\n    private long sequence = 0L; //序列号\n    private long lastTimeStamp = -1L;  //上一次时间戳\n    private long getNextMill() {\n        long mill = getNewTimeStamp();\n        while (mill <= lastTimeStamp) {\n            mill = getNewTimeStamp();\n        }\n        return mill;\n    }\n    private long getNewTimeStamp() {\n        return System.currentTimeMillis();\n    }\n    /**\n     * 根据指定的数据中心ID和机器标志ID生成指定的序列号\n     *\n     * @param dataCenterId 数据中心ID\n     * @param machineId    机器标志ID\n     */\n    public SnowFlakeShortUrl(long dataCenterId, long machineId) {\n        if (dataCenterId > MAX_DATA_CENTER_NUM || dataCenterId < 0) {\n            throw new IllegalArgumentException(\"DtaCenterId can\'t be greater than MAX_DATA_CENTER_NUM or less than 0！\");\n        }\n        if (machineId > MAX_MACHINE_NUM || machineId < 0) {\n            throw new IllegalArgumentException(\"MachineId can\'t be greater than MAX_MACHINE_NUM or less than 0！\");\n        }\n        this.dataCenterId = dataCenterId;\n        this.machineId = machineId;\n    }\n    /**\n     * 产生下一个ID\n     *\n     * @return\n     */\n    public synchronized long nextId() {\n        long currTimeStamp = getNewTimeStamp();\n        if (currTimeStamp < lastTimeStamp) {\n            throw new RuntimeException(\"Clock moved backwards.  Refusing to generate id\");\n        }\n        if (currTimeStamp == lastTimeStamp) {\n            //相同毫秒内，序列号自增\n            sequence = (sequence + 1) & MAX_SEQUENCE;\n            //同一毫秒的序列数已经达到最大\n            if (sequence == 0L) {\n                currTimeStamp = getNextMill();\n            }\n        } else {\n            //不同毫秒内，序列号置为0\n            sequence = 0L;\n        }\n        lastTimeStamp = currTimeStamp;\n        return (currTimeStamp - START_TIMESTAMP) << TIMESTAMP_LEFT //时间戳部分\n                | dataCenterId << DATA_CENTER_LEFT       //数据中心部分\n                | machineId << MACHINE_LEFT             //机器标识部分\n                | sequence;                             //序列号部分\n    }\n    \n    public static void main(String[] args) {\n        SnowFlakeShortUrl snowFlake = new SnowFlakeShortUrl(2, 3);\n        for (int i = 0; i < (1 << 4); i++) {\n            //10进制\n            System.out.println(snowFlake.nextId());\n        }\n    }\n}\n\n```\n\n7、百度（uid-generator）\n===================\n\nuid-generator是由百度技术部开发，项目GitHub地址  \n[https://github.com/baidu/uid-..](https://github.com/baidu/uid-.. \"https://github.com/baidu/uid-..\").\n\nuid-generator是基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和 序列号 等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。\n\nuid-generator需要与数据库配合使用，需要新增一个WORKER\\_NODE表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。\n\n**对于uid-generator ID组成结构**：\n\nworkId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。\n\n> 参考文献\n> \n> [https://github.com/baidu/uid-..](https://github.com/baidu/uid-.. \"https://github.com/baidu/uid-..\").\n\n8、美团（Leaf）\n==========\n\nLeaf由美团开发，github地址：  \n[https://github.com/Meituan-Di..](https://github.com/Meituan-Di.. \"https://github.com/Meituan-Di..\").\n\nLeaf同时支持号段模式和snowflake算法模式，可以切换使用。\n\n号段模式\n====\n\n先导入源码  \n[https://github.com/Meituan-Di..](https://github.com/Meituan-Di.. \"https://github.com/Meituan-Di..\"). ，在建一张表leaf\\_alloc\n\n```\nDROP TABLE IF EXISTS `leaf_alloc`;\nCREATE TABLE `leaf_alloc` (\n  `biz_tag` varchar(128)  NOT NULL DEFAULT \'\' COMMENT \'业务key\',  `max_id` bigint(20) NOT NULL DEFAULT \'1\' COMMENT \'当前已经分配了的最大id\',  `step` int(11) NOT NULL COMMENT \'初始步长，也是动态调整的最小步长\',  `description` varchar(256)  DEFAULT NULL COMMENT \'业务key的描述\',  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \'数据库维护的更新时间\',  PRIMARY KEY (`biz_tag`)\n) ENGINE=InnoDB;\n\n```\n\n然后在项目中开启号段模式，配置对应的数据库信息，并关闭snowflake模式\n\n```\nleaf.name=com.sankuai.leaf.opensource.test\nleaf.segment.enable=true\nleaf.jdbc.url=jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&characterEncoding=utf8&characterSetResults=utf8\nleaf.jdbc.username=root\nleaf.jdbc.password=root\nleaf.snowflake.enable=false\n#leaf.snowflake.zk.address=\n#leaf.snowflake.port=\n\n```\n\n启动leaf-server 模块的 LeafServerApplication项目就跑起来了\n\n号段模式获取分布式自增ID的测试url ：http：//localhost：  \n8080/api/segment/get/leaf-segment-test\n\n监控号段模式：  \nhttp://localhost:8080/cache\n\nsnowflake模式\n===========\n\nLeaf的snowflake模式依赖于ZooKeeper，不同于原始snowflake算法也主要是在workId的生成上，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。\n\n```\nleaf.snowflake.enable=true\nleaf.snowflake.zk.address=127.0.0.1\nleaf.snowflake.port=2181\n\n```\n\nsnowflake模式获取分布式自增ID的测试url：  \nhttp://localhost:8080/api/snowflake/get/test\n\n9、滴滴（Tinyid）\n============\n\nTinyid由滴滴开发，Github地址：  \n[https://github.com/didi/tinyid](https://github.com/didi/tinyid \"https://github.com/didi/tinyid\")。\n\nTinyid是基于号段模式原理实现的与Leaf如出一辙，每个服务获取一个号段（1000,2000\\]、（2000,3000\\]、（3000,4000\\]\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05666f-98ac-a942-9fe6-e7358ed2cd59_421da6e9c313bd245984c7af732123ac!detail.png)\n\nTinyid提供http和tinyid-client两种方式接入\n\nHttp方式接入\n========\n\n（1）导入Tinyid源码：\n\ngit clone [https://github.com/didi/tinyi..](https://github.com/didi/tinyi.. \"https://github.com/didi/tinyi..\").\n\n（2）创建数据表：\n\n```\nCREATE TABLE `tiny_id_info` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'自增主键\',  `biz_type` varchar(63) NOT NULL DEFAULT \'\' COMMENT \'业务类型，唯一\',  `begin_id` bigint(20) NOT NULL DEFAULT \'0\' COMMENT \'开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同\',  `max_id` bigint(20) NOT NULL DEFAULT \'0\' COMMENT \'当前最大id\',  `step` int(11) DEFAULT \'0\' COMMENT \'步长\',  `delta` int(11) NOT NULL DEFAULT \'1\' COMMENT \'每次id增量\',  `remainder` int(11) NOT NULL DEFAULT \'0\' COMMENT \'余数\',  `create_time` timestamp NOT NULL DEFAULT \'2010-01-01 00:00:00\' COMMENT \'创建时间\',  `update_time` timestamp NOT NULL DEFAULT \'2010-01-01 00:00:00\' COMMENT \'更新时间\',  `version` bigint(20) NOT NULL DEFAULT \'0\' COMMENT \'版本号\',  PRIMARY KEY (`id`),  UNIQUE KEY `uniq_biz_type` (`biz_type`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT \'id信息表\';\nCREATE TABLE `tiny_id_token` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT \'自增id\',  `token` varchar(255) NOT NULL DEFAULT \'\' COMMENT \'token\',  `biz_type` varchar(63) NOT NULL DEFAULT \'\' COMMENT \'此token可访问的业务类型标识\',  `remark` varchar(255) NOT NULL DEFAULT \'\' COMMENT \'备注\',  `create_time` timestamp NOT NULL DEFAULT \'2010-01-01 00:00:00\' COMMENT \'创建时间\',  `update_time` timestamp NOT NULL DEFAULT \'2010-01-01 00:00:00\' COMMENT \'更新时间\',  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT \'token信息表\';\nINSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)\nVALUES\n    (1, \'test\', 1, 1, 100000, 1, 0, \'2018-07-21 23:52:58\', \'2018-07-22 23:19:27\', 1);\nINSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)\nVALUES\n    (2, \'test_odd\', 1, 1, 100000, 2, 1, \'2018-07-21 23:52:58\', \'2018-07-23 00:39:24\', 3);\nINSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)\nVALUES\n    (1, \'0f673adf80504e2eaa552f5d791b644c\', \'test\', \'1\', \'2017-12-14 16:36:46\', \'2017-12-14 16:36:48\');\nINSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)\nVALUES\n    (2, \'0f673adf80504e2eaa552f5d791b644c\', \'test_odd\', \'1\', \'2017-12-14 16:36:46\', \'2017-12-14 16:36:48\');\n\n```\n\n（3）配置数据库：\n\n```\ndatasource.tinyid.names=primary\ndatasource.tinyid.primary.driver-class-name=com.mysql.jdbc.Driver\ndatasource.tinyid.primary.url=jdbc:mysql://ip:port/databaseName?autoReconnect=true&useUnicode=true&characterEncoding=UTF-8\ndatasource.tinyid.primary.username=root\ndatasource.tinyid.primary.password=123456\n\n```\n\n（4）启动tinyid-server后测试\n\n```\n获取分布式自增ID: http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&token=0f673adf80504e2eaa552f5d791b644c\'\n返回结果: 3\n批量获取分布式自增ID:\nhttp://localhost:9999/tinyid/id/nextIdSimple?bizType=test&token=0f673adf80504e2eaa552f5d791b644c&batchSize=10\'\n返回结果:  4,5,6,7,8,9,10,11,12,13\n\n```\n\nJava客户端方式接入\n===========\n\n重复Http方式的（2）（3）操作\n\n引入依赖\n\n```\n<dependency>\n            <groupId>com.xiaoju.uemc.tinyid</groupId>            <artifactId>tinyid-client</artifactId>            <version>${tinyid.version}</version>        </dependency>\n\n```\n\n配置文件\n\n```\ntinyid.server =localhost:9999\ntinyid.token =0f673adf80504e2eaa552f5d791b644c\n\n```\n\ntest 、tinyid.token是在数据库表中预先插入的数据，test 是具体业务类型，tinyid.token表示可访问的业务类型\n\n```\n// 获取单个分布式自增ID\nLong id =  TinyId . nextId( \" test \" );\n// 按需批量分布式自增ID\nList< Long > ids =  TinyId . nextId( \" test \" , 10 );\n\n```\n\n* * *\n\n总结\n==\n\n本文只是简单介绍一下每种分布式ID生成器，旨在给大家一个详细学习的方向，每种生成方式都有它自己的优缺点，具体如何使用还要看具体的业务需求。', '', 0, 0, 20, 0, 0, 0, 1655861355273, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.124 Safari/537.36 Edg/102.0.1245.41', '127.0.0.1', 1655861355273, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (19, 0, 3, 2, 'BUG反馈和优化建议', '如遇到BUG、优化建议请在评论区提出~\n\n---\n\n#### TODO\n- [x] 话题详情代码高亮显示([@测试](http://192.168.1.83:5000/user/7))\n- [x] 话题详情中图片增加点击预览功能([@ZENGQHAO](http://192.168.1.83:5000/user/11))\n- [ ] 话题列表页面缩略图修改为按比例在中心裁切而不是整体缩放([@慢慢](http://192.168.1.83:5000/user/2))\n', '', 0, 0, 113, 5, 0, 0, 1665648742448, 19, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659268305713, NULL, b'1', 1659268333291);
INSERT INTO `t_topic` VALUES (20, 0, 7, 2, 'int和byte之间转换的方法', '使用位运算\n1、int转byte[]\n```\n  public  byte[] intToBytes(int value)\n  {\n       byte[] src = new byte[4];\n       src[3] = (byte)((value >> 24) & 0xFF);\n       src[2] = (byte)((value >> 16) & 0xFF);\n       src[1] = (byte)((value >> 8) & 0xFF);\n       src[0] = (byte)(value & 0xFF);\n       return src;\n   }\n```\n2、byte[]转为int\n```\n  public  int bytesToInt(byte[] src, int offset)\n  {\n      int value;\n      value = (int)((src[offset] & 0xFF)\n              | ((src[offset + 1] & 0xFF) << 8)\n              | ((src[offset + 2] & 0xFF) << 16)\n              | ((src[offset + 3] & 0xFF) << 24));\n      return value;\n  } \n```\n\n使用BitConverter\n1、int转byte[]\n```\n  public  byte[] IntToBitConverter(int num)\n  {\n       byte[] bytes = BitConverter.GetBytes(num);\n       return bytes;\n  }\n```\n2、byte[]转为int\n```\n  public  int IntToBitConverter(byte[] bytes)\n  {\n      int  temp = BitConverter.ToInt32(bytes, 0);\n      return temp;\n  }\n```\n', '', 0, 0, 1, 0, 0, 0, 1659317088143, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659317088143, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (21, 0, 7, 2, 'ASP.NET Core 产生连续 Guid', '1 前言\n----\n\n### 1.1 这篇文章面向的读者\n\n本文不会过多解释 Guid 是什么，以及顺序 Guid 的作用，需要读者自行具备：\n\n*   知道 Guid，并且清楚其作用与优势\n*   清楚 `Guid.NetGuid()` 产生的 Guid 是混乱无序的，想要一种产生顺序 Guid 的算法来保证数据库的高效运行\n\n### 1.2 连续 Guid 的原理\n\nGuid 形如：\n\n```\n08da7241-170b-c8ef-a094-06224a651c6a\n\n```\n\n该 Guid 有16字节（byte）共128位（bit），可以包含时间戳，而顺序 Guid 主要是根据时间戳顺序来实现的，所以时间戳的部分，作为排序的**决定性因素**。\n\n如示例中，前8个字节的内容为时间戳，将其转为十进制为：\n\n```\n637947921111435500\n\n```\n\n这是一个以时钟周期数（Tick）为单位的时间戳，为从公元1年1月1日0点至今的时钟周期数，1个 Tick 为 100ns（参考[微软官方关于 Ticks 的介绍](https://docs.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=net-6.0#remarks)）。\n\n注：上方示例的 Guid 并不符合 RFC 4122 标准，至于什么是 RFC 4122 标准，以及 Guid 的版本，这里不展开，读者自行参考[什么是 GUID？](http://guid.one/guid)。\n\n### 1.3 本文思路\n\n先大概讲解 ABP 产生连续 Guid 的源码，并提出其问题（高并发产生的 Guid 并不连续）。\n\n接着就问题，以及 ABP 的源码提出解决方案，并给出修改后的源码。\n\n并会就 Sql Server 数据库特殊的 Guid 排序方式，提出一种简单的处理方案，让 Sql Server 与 MySql 等数据库保持一致的排序。\n\n  \n\n2 ABP 连续 Guid 的实现\n-----------------\n\n### 2.1 ABP 连续 Guid 源码\n\n[ABP产生连续 Guid 的源码](https://github.com/abpframework/abp/blob/dev/framework/src/Volo.Abp.Guids/Volo/Abp/Guids/SequentialGuidGenerator.cs)，来源于：[jhtodd/SequentialGuid](https://github.com/jhtodd/SequentialGuid/blob/master/SequentialGuid/Classes/SequentialGuid.cs).\n\n该方式，产生的 Guid 有6个字节是时间戳（毫秒级），10个字节是随机数。\n\n其中，顺序 Guid 主要是根据时间戳顺序来实现的，所以时间戳的部分，作为排序的决定性因素。\n\n源码主要的部分摘录如下：\n\n```\npublic class SequentialGuidGenerator : IGuidGenerator, ITransientDependency\n{\n    public Guid Create(SequentialGuidType guidType)\n    {\n        // 获取 10 字节随机序列数组\n        var randomBytes = new byte[10];\n        RandomNumberGenerator.GetBytes(randomBytes);\n\n        // 获取 Ticks，并处理为毫秒级（1个Tick为100ns，1ms=1000us=1000000ns）\n        long timestamp = DateTime.UtcNow.Ticks / 10000L;\n\n        // 时间戳转为 byte 数组\n        byte[] timestampBytes = BitConverter.GetBytes(timestamp);\n\n        // 因为数组是从 int64 转化过来的，如果是在小端系统中（little-endian），需要翻转\n        if (BitConverter.IsLittleEndian)\n        {\n            Array.Reverse(timestampBytes);\n        }\n\n        byte[] guidBytes = new byte[16];\n\n        switch (guidType)\n        {\n            case SequentialGuidType.SequentialAsString:\n            case SequentialGuidType.SequentialAsBinary:\n                \n                // 16位数组：前6位为时间戳，后10位为随机数\n                Buffer.BlockCopy(timestampBytes, 2, guidBytes, 0, 6);\n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 6, 10);\n                \n                // .NET中，Data1 和 Data2块 分别视为 Int32 和 Int16\n                // 跟时间戳从 Int64 转 byte 数组后需要翻转一个理，在小端系统，需要翻转这两个块。\n                if (guidType == SequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(guidBytes, 0, 4);\n                    Array.Reverse(guidBytes, 4, 2);\n                }\n                break;\n                \n            case SequentialGuidType.SequentialAtEnd:\n                \n                // 16位数组：前10位为随机数，后6位为时间戳\n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 10);\n                Buffer.BlockCopy(timestampBytes, 2, guidBytes, 10, 6);\n                break;\n        }\n        return new Guid(guidBytes);\n    }\n}\n\n```\n\n`RandomNumberGenerator` 用于生成随机序列数组。\n\n`DateTime.UtcNow.Ticks` 为获取从公元1年1月1日0点至今的时钟周期数，1个Tick为100ns（[微软官方关于 Ticks 的介绍](https://docs.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=net-6.0#remarks)）。\n\n`SequentialGuidType` 为产生连续 Guid 的类别，默认为 `SequentialAtEnd` ，定义如下：\n\n```\npublic enum SequentialGuidType\n{\n    /// <summary>\n    /// 用于 MySql 和 PostgreSql.当使用 Guid.ToString() 方法进行格式化时连续.\n    /// </summary>\n    SequentialAsString,\n\n    /// <summary>\n    /// 用于 Oracle.当使用 Guid.ToByteArray() 方法进行格式化时连续.\n    /// </summary>\n    SequentialAsBinary,\n\n    /// <summary>\n    /// 用以 SqlServer.连续性体现于 GUID 的第4块（Data4）.\n    /// </summary>\n    SequentialAtEnd\n}\n\n```\n\n如各个枚举属性的 summary 描述，主要是因为数据库关于 Guid 排序方式的不同。\n\n至于代码中需要翻转 byte 数组的部分，这一部分，可以参考：[Is there a .NET equivalent to SQL Server\'s newsequentialid()](https://stackoverflow.com/questions/211498/is-there-a-net-equivalent-to-sql-servers-newsequentialid)（Stack Overflow 这个问题，有一个回答介绍了时间戳高低位在 Guid 中的排布）。笔者也是看得一脸懵逼，就不在这里误人子弟了。\n\n至于大端、小端，属于计算机组成原理的知识，如果不记得了，可以自行百度（或参考[大端、小端基础知识](https://zhuanlan.zhihu.com/p/316347205)）。\n\n### 2.2 不同数据库 Guid 的排序方式\n\n由于笔者只用过 MySql 和 Sql Server，测试也只用了这两种数据库测试，故而也只讲这两种。\n\n[richardtallent/RT.Comb](https://github.com/richardtallent/RT.Comb#icombprovider)这个仓库也介绍了这一部分内容。\n\n#### （1）MySql\n\n笔者的 MySql 版本为 8.0.26.\n\nMySql 对 Guid 的处理为字符串方式，排序方式为从左到右的。\n\n故而决定顺序的时间戳部分应该位于 Guid 的左侧，所以 ABP 的源码里 Guid 的16位数组：前6位为时间戳，后10位为随机数。\n\n#### （2）Sql Server\n\n笔者的 Sql Server 版本为 2019 Express.\n\nSql Server 关于 Guid 的排序方式比较特殊，属于分块排序。\n\n先排 `Data4` 的后6个字节（即最后一块，也即从第10个字节开始的最后6个字节），块内依旧是从左到右排序。\n\n接着排 `Data4` 的前2个字节（即倒数第2块，也即从第8个字节开始的2个字节），块内依旧是从左到右排序。\n\n随后依次是 `Data3`, `Data2`, `Data1` （其中，笔者验证了 `Data3` 的块内排序，并非从左到右，而是先排了块内第2个字节，后排第1个字节，可能是 Sql Server 认为 `Data3` 是 `Int16`，而小端处理后将2个字节翻转了，显示虽然显示了 `Mxxx`，但实际上是 `xxMx`，排序也是按后者来排）.\n\n故而决定顺序的时间戳部分应该位于 Guid 的右侧，所以 ABP 的源码里 Guid 的16位数组：前10位为随机数，后6位为时间戳。\n\n### 2.3 存在的问题\n\n#### （1）毫秒级的时间戳\n\n由于决定排序因素的部分为时间戳，而时间戳被处理成毫秒级。高并发的情况下，时间戳部分基本上一致，导致短时间内生成的 Guid 并不连续，是无序的。\n\n```\n// 获取 Ticks，并处理为毫秒级（1个Tick为100ns，1ms=1000us=1000000ns）\nlong timestamp = DateTime.UtcNow.Ticks / 10000L;\n\n```\n\n#### （2）非标准 Guid\n\n这里还是大概介绍一下 RFC 4122 版本4的内容：\n\nGuid 组成形如：\n\n```\nxxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx\n\n```\n\n其中 M 为 RFC 版本（version），版本4的话，值为4。\n\nN 为变体（variant），值为 8, 9, A, B 其中一个。\n\n版本4为保留版本号和变体，其他位均为随机。\n\n显然，ABP 的方案，一部分是时间戳，余下的部分均为随机数，这样并不包含版本和变体，不属于任何一版本的 Guid，为非标准的 Guid。\n\n  \n\n3 连续 Guid 修改版本\n--------------\n\n### 3.1 解决高并发时间戳一致问题\n\n#### （1）实现\n\n基于上述的方案的问题1，由于问题是高并发的情况下时间戳一致的问题，那么尽量让时间戳的间隔再小一点，即可，如修改时间戳的代码为：\n\n```\nlong timestamp = DateTime.UtcNow.Ticks;\n\n```\n\n直接将毫秒的处理去掉，让时间戳为纳秒级（ns）。\n\n另外，还需要将时间戳原本只取6个字节，改成8个字节，让尾部的时间戳作用于 Guid 上。\n\n完整的代码修改如下：\n\n```\npublic static Guid Next(SequentialGuidType guidType)\n{\n    // 原先 10 字节的随机序列数组，减少为 8 字节\n    var randomBytes = new byte[8];\n    _randomNumberGenerator.GetBytes(randomBytes);\n\n    // 时间戳保持纳秒级，不额外处理\n    long timestamp = DateTime.UtcNow.Ticks;\n\n    byte[] timestampBytes = BitConverter.GetBytes(timestamp);\n    if (BitConverter.IsLittleEndian)\n    {\n        Array.Reverse(timestampBytes);\n    }\n\n    byte[] guidBytes = new byte[16];\n\n    switch (guidType)\n    {\n        case SequentialGuidType.SequentialAsString:\n        case SequentialGuidType.SequentialAsBinary:\n\n            // 16位数组：前8位为时间戳，后8位为随机数\n            Buffer.BlockCopy(timestampBytes, 0, guidBytes, 0, 8);\n            Buffer.BlockCopy(randomBytes, 0, guidBytes, 8, 8);\n\n            // .NET中，Data1、Data2、Data3 块 分别视为 Int32、Int16、Int16\n            // 跟时间戳从 Int64 转 byte 数组后需要翻转一个理，在小端系统，需要翻转这3个块。\n            if (guidType == SequentialGuidType.AsString && BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(guidBytes, 0, 4);\n                Array.Reverse(guidBytes, 4, 2);\n                Array.Reverse(guidBytes, 6, 2); // 翻转\n            }\n\n            break;\n\n        case SequentialGuidType.SequentialAtEnd:\n\n            // 16位数组：前8位为随机数，后8位为时间戳\n            Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 8);\n            // 方案1：正常拼接。这种方式只能连续1年+\n            Buffer.BlockCopy(timestampBytes, 0, guidBytes, 8, 8);\n            // 方案2：将时间戳末尾的2个字节，放到 Data4 的前2个字节\n            Buffer.BlockCopy(timestampBytes, 6, guidBytes, 8, 2);\n            Buffer.BlockCopy(timestampBytes, 0, guidBytes, 10, 6);\n            break;\n    }\n\n    return new Guid(guidBytes);\n}\n\n```\n\n#### （2）测试\n\nAsString 方式：\n\n```\n# 主要影响排序的，体现在 Guid 第8个字节。\n08da7241-170b-c8ef-a094-06224a651c6a	0\n08da7241-170b-d141-6ffc-5cdcecec5db9	1\n08da7241-170b-d14e-d49e-81ce5efa6143	2\n08da7241-170b-d150-8f59-836eab8d1939	3\n08da7241-170b-d152-ac41-0c357a8aa4a1	4\n08da7241-170b-d163-90a4-6083d462eeaf	5\n08da7241-170b-d175-25b2-1d47ddd25939	6\n08da7241-170b-d178-aa93-dc86e6391438	7\n08da7241-170b-d185-619f-c24faf992806	8\n08da7241-170b-d188-bd51-e36029ad9816	9\n\n```\n\nAtEnd 方式：\n\n```\n// 顺序体现在最后一个字节\n983C1A57-8C2B-DE7D-08DA-724214AED77D	0\n4F1389B8-59F6-7C78-08DA-724214AEDAB6	1\nCF6D52B1-3BFA-272F-08DA-724214AEDABC	2\n017C4F99-4499-67DB-08DA-724214AEDABE	3\n4B0A0685-4355-2060-08DA-724214AEDAC0	4\nD690E344-DDB4-16CB-08DA-724214AEDAC6	5\n6E22CDBE-65FE-64DC-08DA-724214AEDAC8	6\n72E67EB4-CA92-DF3A-08DA-724214AEDACA	7\nAA93D914-5415-21C9-08DA-724214AEDACB	8\n9D93FA3F-84B6-519D-08DA-724214AEDACD	9\n\n```\n\n### 3.2 产生符合 RFC 4122 标准的 Guid\n\n笔者对于这一块内容，也是一脸懵逼。\n\n大概的思路是：在 ABP 连续 Guid 的方案中，插入版本（M）和变体（N），那么牺牲1个字节（byte）共8个位（bit）的随机数即可，影响到时间戳的部分，则往后挪一挪。\n\n```\nxxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx\n\n```\n\n修改后的代码比较复杂，如下：\n\n```\npublic static Guid Next(SequentialGuidType guidType)\n{\n    // see: What is a GUID? http://guid.one/guid\n    // see: https://github.com/richardtallent/RT.Comb#gory-details-about-uuids-and-guids\n    // According to RFC 4122:\n    // dddddddd-dddd-Mddd-Ndrr-rrrrrrrrrrrr\n    // - M = RFC 版本（version）, 版本4的话，值为4\n    // - N = RFC 变体（variant），值为 8, 9, A, B 其中一个，这里固定为8\n    // - d = 从公元1年1月1日0时至今的时钟周期数（DateTime.UtcNow.Ticks）\n    // - r = 随机数（random bytes）\n\n    var randomBytes = new byte[8];\n    _randomNumberGenerator.GetBytes(randomBytes);\n\n    byte version = (byte)4;\n    byte variant = (byte)8;\n    byte filterHighBit = 0b00001111;\n    byte filterLowBit = 0b11110000;\n\n    long timestamp = DateTime.UtcNow.Ticks;\n\n    byte[] timestampBytes = BitConverter.GetBytes(timestamp);\n    if (BitConverter.IsLittleEndian)\n    {\n        Array.Reverse(timestampBytes);\n    }\n\n    byte[] guidBytes = new byte[16];\n\n    switch (guidType)\n    {\n        case SequentialGuidType.SequentialAsString:\n        case SequentialGuidType.SequentialAsBinary:\n\n            // AsString: dddddddd-dddd-Mddd-Ndrr-rrrrrrrrrrrr\n            Buffer.BlockCopy(timestampBytes, 0, guidBytes, 0, 6); // 时间戳前6个字节，共48位\n            // guidBytes[6]：高4位为版本 | 低4位取时间戳序号[6]的元素的高4位\n            guidBytes[6] = (byte)((version << 4) | ((timestampBytes[6] & filterLowBit) >> 4)); \n            // guidBytes[7]:高4位取：[6]低4位 | 低4位取：[7]高4位\n            guidBytes[7] = (byte)(((timestampBytes[6] & filterHighBit) << 4) | ((timestampBytes[7] & filterLowBit) >> 4)); \n            // guidBytes[8]：高4位为：变体 | 低4位取：[7]低4位\n            guidBytes[8] = (byte)((variant << 4) | (timestampBytes[7] & filterHighBit)); \n            Buffer.BlockCopy(randomBytes, 0, guidBytes, 9, 7); // 余下7个字节由随机数组填充\n\n            // .NET中，Data1、Data2、Data3 块 分别视为 Int32、Int16、Int16，在小端系统，需要翻转这3个块。\n            if (guidType == SequentialGuidType.AsString && BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(guidBytes, 0, 4);\n                Array.Reverse(guidBytes, 4, 2);\n                Array.Reverse(guidBytes, 6, 2);\n            }\n\n            break;\n\n        case SequentialGuidType.SequentialAtEnd:\n\n            // AtEnd: rrrrrrrr-rrrr-Mxdr-Nddd-dddddddddddd\n            // Block: 1        2    3    4    5\n            // Data4 = Block4 + Block5\n            // 排序顺序：Block5 > Block4 > Block3 > Block2 > Block1\n            // Data3 = Block3 被认为是 uint16，排序并不是从左到右，为消除影响，x 位取固定值\n            \n            Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 6);\n            // Mx 高4位为版本 | 低4位取：全0\n            guidBytes[6] = (byte)(version << 4); \n            // dr 高4位为：时间戳[7]低4位 | 低4位取：随机数\n            guidBytes[7] = (byte)(((timestampBytes[7] & filterHighBit) << 4) | (randomBytes[7] & filterHighBit)); \n            // Nd 高4位为：变体 | 低4位取：时间戳[6]高4位\n            guidBytes[8] = (byte)((variant << 4) | ((timestampBytes[6] & filterLowBit) >> 4)); \n            // dd 高4位为：时间戳[6]低4位 | 低4位取：时间戳[7]高4位\n            guidBytes[9] = (byte)(((timestampBytes[6] & filterHighBit) << 4) | ((timestampBytes[7] & filterLowBit) >> 4)); \n            Buffer.BlockCopy(timestampBytes, 0, guidBytes, 10, 6); // 时间戳前6个字节\n\n            if (BitConverter.IsLittleEndian)\n            {\n                //Array.Reverse(guidBytes, 0, 4); // 随机数就不翻转了\n                //Array.Reverse(guidBytes, 4, 2);\n                Array.Reverse(guidBytes, 6, 2); // 包含版本号的 Data3 块需要翻转\n            }\n            break;\n    }\n\n    return new Guid(guidBytes);\n}\n\n```\n  \n\n4 Sql Server 关于 Guid 的处理方案\n--------------------------\n\n基于 Sql Server 特殊的 Guid 排序方式，这里提出一种解决方案：\n\n不使用 Sql Server 默认的 `[uniqueidentifier]` 而改用 `char(36)`，这样能让 Sql Server 的 Guid 处理成字符串，令其排序方式与字符串一致（与 MySql 和 C# 程序中的排序统一）。\n\n具体处理可以在自定义的 DbContext 的 OnModelCreating 中配置：\n\n```\n// 获取所有注册的实体，遍历\nforeach (var entityType in builder.Model.GetEntityTypes())\n{\n    // 获取实体的所有属性，遍历\n    PropertyInfo[] propertyInfos = entityType.ClrType.GetProperties();\n    foreach (PropertyInfo propertyInfo in propertyInfos)\n    {\n        string propertyName = propertyInfo.Name;\n        if (propertyInfo.PropertyType.FullName == \"System.Guid\")\n        {\n            // 将 Guid 类型设置为 char(36)\n            builder.Entity(entityType.ClrType).Property(propertyName).HasColumnType(\"char(36)\");\n        }\n    }\n}\n\n```\n  \n\n5 完整的代码\n-------\n\n这里将完整的 GuidHelper 给出：\n\n通过 `GuidHelper.Next()` 生成连续的 Guid.\n\n```\nusing System.Security.Cryptography;\n\npublic enum SequentialGuidType\n{\n    /// <summary>\n    /// 用于 MySql 和 PostgreSql.\n    ///  当使用 <see cref=\"Guid.ToString()\" /> 方法进行格式化时连续.\n    /// </summary>\n    AsString,\n\n    /// <summary>\n    /// 用于 Oracle.\n    /// 当使用 <see cref=\"Guid.ToByteArray()\" /> 方法进行格式化时连续.\n    /// </summary>\n    AsBinary,\n\n    /// <summary>\n    /// 用以 SqlServer.\n    /// 连续性体现于 GUID 的第4块（Data4）.\n    /// </summary>\n    AtEnd\n}\n\npublic static class GuidHelper\n{\n    private const byte version = (byte)4;\n    private const byte variant = (byte)8;\n    private const byte filterHighBit = 0b00001111;\n    private const byte filterLowBit = 0b11110000;\n    private static readonly RandomNumberGenerator _randomNumberGenerator = RandomNumberGenerator.Create();\n\n    /// <summary>\n    /// 连续 Guid 类型，默认：AsString.\n    /// </summary>\n    public static SequentialGuidType SequentialGuidType { get; set; } = SequentialGuidType.AsString;\n\n    /// <summary>\n    /// 生成连续 Guid.\n    /// </summary>\n    /// <returns></returns>\n    public static Guid Next()\n    {\n        return Next(SequentialGuidType);\n    }\n\n    /// <summary>\n    /// 生成连续 Guid（生成的 Guid 并不符合 RFC 4122 标准）.\n    /// 来源：Abp. from jhtodd/SequentialGuid https://github.com/jhtodd/SequentialGuid/blob/master/SequentialGuid/Classes/SequentialGuid.cs .\n    /// </summary>\n    /// <param name=\"guidType\"></param>\n    /// <returns></returns>\n    public static Guid NextOld(SequentialGuidType guidType)\n    {\n        var randomBytes = new byte[8];\n        _randomNumberGenerator.GetBytes(randomBytes);\n\n        long timestamp = DateTime.UtcNow.Ticks;\n\n        byte[] timestampBytes = BitConverter.GetBytes(timestamp);\n        if (BitConverter.IsLittleEndian)\n        {\n            Array.Reverse(timestampBytes);\n        }\n\n        byte[] guidBytes = new byte[16];\n\n        switch (guidType)\n        {\n            case SequentialGuidType.AsString:\n            case SequentialGuidType.AsBinary:\n\n                // 16位数组：前8位为时间戳，后8位为随机数\n                Buffer.BlockCopy(timestampBytes, 0, guidBytes, 0, 8);\n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 8, 8);\n\n                // .NET中，Data1、Data2、Data3 块 分别视为 Int32、Int16、Int16，在小端系统，需要翻转这3个块。\n                if (guidType == SequentialGuidType.AsString && BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(guidBytes, 0, 4);\n                    Array.Reverse(guidBytes, 4, 2);\n                    Array.Reverse(guidBytes, 6, 2);\n                }\n\n                break;\n\n            case SequentialGuidType.AtEnd:\n\n                // 16位数组：前8位为随机数，后8位为时间戳\n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 8);\n                Buffer.BlockCopy(timestampBytes, 6, guidBytes, 8, 2);\n                Buffer.BlockCopy(timestampBytes, 0, guidBytes, 10, 6);\n                break;\n        }\n\n        return new Guid(guidBytes);\n    }\n\n    /// <summary>\n    /// 生成连续 Guid.\n    /// </summary>\n    /// <param name=\"guidType\"></param>\n    /// <returns></returns>\n    public static Guid Next(SequentialGuidType guidType)\n    {\n        // see: What is a GUID? http://guid.one/guid\n        // see: https://github.com/richardtallent/RT.Comb#gory-details-about-uuids-and-guids\n        // According to RFC 4122:\n        // dddddddd-dddd-Mddd-Ndrr-rrrrrrrrrrrr\n        // - M = RFC 版本（version）, 版本4的话，值为4\n        // - N = RFC 变体（variant），值为 8, 9, A, B 其中一个，这里固定为8\n        // - d = 从公元1年1月1日0时至今的时钟周期数（DateTime.UtcNow.Ticks）\n        // - r = 随机数（random bytes）\n\n        var randomBytes = new byte[8];\n        _randomNumberGenerator.GetBytes(randomBytes);\n\n        long timestamp = DateTime.UtcNow.Ticks;\n\n        byte[] timestampBytes = BitConverter.GetBytes(timestamp);\n        if (BitConverter.IsLittleEndian)\n        {\n            Array.Reverse(timestampBytes);\n        }\n\n        byte[] guidBytes = new byte[16];\n\n        switch (guidType)\n        {\n            case SequentialGuidType.AsString:\n            case SequentialGuidType.AsBinary:\n\n                // AsString: dddddddd-dddd-Mddd-Ndrr-rrrrrrrrrrrr\n                Buffer.BlockCopy(timestampBytes, 0, guidBytes, 0, 6); // 时间戳前6个字节，共48位\n                guidBytes[6] = (byte)((version << 4) | ((timestampBytes[6] & filterLowBit) >> 4)); // 高4位为版本 | 低4位取时间戳序号[6]的元素的高4位\n                guidBytes[7] = (byte)(((timestampBytes[6] & filterHighBit) << 4) | ((timestampBytes[7] & filterLowBit) >> 4)); // 高4位取：[6]低4位 | 低4位取：[7]高4位\n                guidBytes[8] = (byte)((variant << 4) | (timestampBytes[7] & filterHighBit)); // 高4位为：变体 | 低4位取：[7]低4位\n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 9, 7); // 余下7个字节由随机数组填充\n\n                // .NET中，Data1、Data2、Data3 块 分别视为 Int32、Int16、Int16，在小端系统，需要翻转这3个块。\n                if (guidType == SequentialGuidType.AsString && BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(guidBytes, 0, 4);\n                    Array.Reverse(guidBytes, 4, 2);\n                    Array.Reverse(guidBytes, 6, 2);\n                }\n\n                break;\n\n            case SequentialGuidType.AtEnd:\n\n                // AtEnd: rrrrrrrr-rrrr-Mxdr-Nddd-dddddddddddd\n                // Block: 1        2    3    4    5\n                // Data4 = Block4 + Block5\n                // 排序顺序：Block5 > Block4 > Block3 > Block2 > Block1\n                // Data3 = Block3 被认为是 uint16，排序并不是从左到右，为消除影响，x 位取固定值\n                \n                Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 6);\n                guidBytes[6] = (byte)(version << 4); // Mx 高4位为版本 | 低4位取：全0\n                guidBytes[7] = (byte)(((timestampBytes[7] & filterHighBit) << 4) | (randomBytes[7] & filterHighBit)); ; // dr 高4位为：时间戳[7]低4位 | 低4位取：随机数\n                guidBytes[8] = (byte)((variant << 4) | ((timestampBytes[6] & filterLowBit) >> 4)); // Nd 高4位为：变体 | 低4位取：时间戳[6]高4位\n                guidBytes[9] = (byte)(((timestampBytes[6] & filterHighBit) << 4) | ((timestampBytes[7] & filterLowBit) >> 4)); // dd 高4位为：时间戳[6]低4位 | 低4位取：时间戳[7]高4位\n                Buffer.BlockCopy(timestampBytes, 0, guidBytes, 10, 6); // 时间戳前6个字节\n\n                if (BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(guidBytes, 6, 2); // 包含版本号的 Data3 块需要翻转\n                }\n                break;\n        }\n\n        return new Guid(guidBytes);\n    }\n}\n\n```\n  \n\n6 其他全局唯一算法推荐\n------------\n\n### 6.1 雪花算法\n\n可以参考：[Adnc 项目的文章：如何动态分配雪花算法的WorkerId](https://github.com/AlphaYu/Adnc/wiki/%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E7%9A%84WorkerId).\n\nAdnc 这个项目是[风口旁的猪](https://www.cnblogs.com/alphayu)的，一个轻量级的微服务/分布式开发框架。\n\n  \n\n参考来源\n----\n\n[ABP产生连续 Guid 的源码](https://github.com/abpframework/abp/blob/dev/framework/src/Volo.Abp.Guids/Volo/Abp/Guids/SequentialGuidGenerator.cs)\n\n[DateTime.Ticks](https://docs.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=net-6.0#remarks)（微软官方关于 Ticks 的介绍，1个 Ticks 是100ns）\n\n[Guid Generator is not sequential generating multiple call in one request](https://github.com/abpframework/abp/issues/11453)（ABP 的 issue）\n\n[Is there a .NET equivalent to SQL Server\'s newsequentialid()](https://stackoverflow.com/questions/211498/is-there-a-net-equivalent-to-sql-servers-newsequentialid)（Stack Overflow 这个问题，有一个回答介绍了时间戳高低位在 Guid 中的排布）\n\n[Pomelo.EntityFrameworkCore.MySql 连续 Guid 的源码](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql/blob/ebe011a6f1b2a2a9709fe558cfc7ed3215b55c37/src/EFCore.MySql/ValueGeneration/Internal/MySqlSequentialGuidValueGenerator.cs)（Furion 源码看到的，这个方案我看不懂，大概理解了一下，实际上原理应该差不多，生成的 Guid 的连续的字符串。不过，这里生成的 Guid 是符合 Guid 的 RFC 4122 Version 4 标准的）\n\n[不同数据库 Guid 的排序规则](https://github.com/richardtallent/RT.Comb#icombprovider)（讲了 MSSQL 即 Sql Server，还有 PostgreSQL）\n\n[.NET生成多数据库有序Guid](https://www.cnblogs.com/Heris-d/p/9359859.html)（这篇贴出的源码与 Abp 没有太大区别，参考文章很齐全，可以看一看，这里不一一列出）\n\n[UUID（GUID）不同版本和顺序递增探究](https://www.cnblogs.com/qinjin/p/uuid.html)\n\n[什么是 GUID？](http://guid.one/guid)\n\n[大端、小端基础知识](https://zhuanlan.zhihu.com/p/316347205)\n\n\n[原文地址](https://www.cnblogs.com/clis/p/16537028.html)', '', 0, 0, 6, 0, 0, 0, 1659319121235, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659319121235, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (22, 0, 7, 2, 'C# 模式&模式匹配', '　　**模式**\n\n*   *   [i](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/is)s 表达式\n    *   `switch` 语句[  \n        ](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/statements/selection-statements#the-switch-statement)\n    *   `switch` 表达式（C# 8.0 引入）[  \n        ](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/switch-expression)\n\n　　在这些构造中，可将输入表达式与以下任一模式进行匹配：\n\n*   *   [声明模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#declaration-and-type-patterns)：用于检查表达式的运行时类型，如果匹配成功，则将表达式结果分配给声明的变量。 在 C# 7.0 中引入。\n    *   [类型模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#declaration-and-type-patterns)：用于检查表达式的运行时类型。 在 C# 9.0 中引入。\n    *   [常量模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#constant-pattern)：用于测试表达式结果是否等于指定常量。 在 C# 7.0 中引入。\n    *   [关系模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#relational-patterns)：用于将表达式结果与指定常量进行比较。 在 C# 9.0 中引入。\n    *   [逻辑模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#logical-patterns)：用于测试表达式是否与模式的逻辑组合匹配。 在 C# 9.0 中引入。\n    *   [属性模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#property-pattern)：用于测试表达式的属性或字段是否与嵌套模式匹配。 在 C# 8.0 中引入。\n    *   [位置模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#positional-pattern)：用于解构表达式结果并测试结果值是否与嵌套模式匹配。 在 C# 8.0 中引入。\n    *   [`var` 模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#var-pattern)：用于匹配任何表达式并将其结果分配给声明的变量。 在 C# 7.0 中引入。\n    *   [弃元模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#discard-pattern)：用于匹配任何表达式。 在 C# 8.0 中引入。\n\n　　**模式匹配**\n\n*   **C# 7.0 - 7.3**\n\n　　　　模式匹配支持 `is` 表达式和 `switch` 表达式。\n\n　　　　以下代码检查变量是否为 `int`，如果是，则将其添加到当前总和：\n\n```\nif (input is int count)\n    sum += count;\n```\n\n　　　　更新后的 switch 语句有几个新构造：\n\n*   *   switch 表达式的控制类型不再局限于整数类型、`Enum` 类型、`string` 或与这些类型之一对应的可为 null 的类型。可能会使用任何类型。\n    *   可以在每个 `case` 标签中测试 `switch` 表达式的类型。 与 `is` 表达式一样，可以为该类型指定一个新变量。\n    *   可以添加 `when` 子句以进一步测试该变量的条件。\n    *   `case` 标签的顺序现在很重要。 执行匹配的第一个分支；其他将跳过。\n\n```\npublic static int SumPositiveNumbers(IEnumerable<object\\> sequence)\n{\n    int sum = 0;\n    foreach (var i in sequence)\n    {\n        switch (i)\n        {\n            case 0:\n                break;\n            case IEnumerable<int\\> childSequence:\n            {\n                foreach(var item in childSequence)\n                    sum += (item > 0) ? item : 0;\n                break;\n            }\n            case int n when n > 0:\n                sum += n;\n                break;\n            case null:\n                throw new NullReferenceException(\"Null found in sequence\");\n            default:\n                throw new InvalidOperationException(\"Unrecognized type\");\n        }\n    }\n    return sum;\n}\n```\n\n*   *   `case 0:` 是[常量模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#constant-pattern)。\n    *   `case IEnumerable<int> childSequence:` 是[声明模式](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/patterns#declaration-and-type-patterns)。\n    *   `case int n when n > 0:` 是具有附加 `when` 条件的声明模式。\n    *   `case null:` 是 `null` 常量模式。\n    *   `default:` 是常见的默认事例。\n\n*   **C# 8.0**\n\n　　　　**switch 表达式**\n\n　　　　更简洁的表达式语法\n\n　　　　下面以 彩虹颜色 枚举举例\n\n```\npublic enum Rainbow\n{\n    Red,\n    Orange,\n    Yellow,\n    Green,\n    Blue,\n    Indigo,\n    Violet\n}\n```\n\n　　　　如果应用定义了通过 `R`、`G` 和 `B` 组件构造而成的 `RGBColor` 类型，可使用以下包含 switch 表达式的方法，将 `Rainbow` 转换为 RGB 值：\n\n```\npublic static RGBColor FromRainbow(Rainbow colorBand) =>\n    colorBand switch\n    {\n        Rainbow.Red    \\=> new RGBColor(0xFF, 0x00, 0x00),\n        Rainbow.Orange \\=> new RGBColor(0xFF, 0x7F, 0x00),\n        Rainbow.Yellow \\=> new RGBColor(0xFF, 0xFF, 0x00),\n        Rainbow.Green  \\=> new RGBColor(0x00, 0xFF, 0x00),\n        Rainbow.Blue   \\=> new RGBColor(0x00, 0x00, 0xFF),\n        Rainbow.Indigo \\=> new RGBColor(0x4B, 0x00, 0x82),\n        Rainbow.Violet \\=> new RGBColor(0x94, 0x00, 0xD3),\n        \\_              \\=> throw new ArgumentException(message: \"invalid enum value\", paramName: nameof(colorBand)),\n    };\n```\n\n　　　　这里有几个语法改进：\n\n*   *   变量位于 `switch` 关键字之前。 不同的顺序使得在视觉上可以很轻松地区分 switch 表达式和 switch 语句。\n    *   将 `case` 和 `:` 元素替换为 `=>`。 它更简洁，更直观。\n    *   将 `default` 事例替换为 `_` 弃元。\n    *   正文是表达式，不是语句。\n\n　　　　**属性模式**\n\n　　　　下面使用属性模式从地址和价格计算销售税：\n\n　　　　State 是 地址Address 的一个属性。\n\n```\npublic static decimal ComputeSalesTax(Address location, decimal salePrice) =>\n    location switch\n    {\n        { State: \"WA\" } => salePrice \\* 0.06M,\n        { State: \"MN\" } => salePrice \\* 0.075M,\n        { State: \"MI\" } => salePrice \\* 0.05M,\n        // other cases removed for brevity...\n        \\_ => 0M\n    };\n```\n\n　　　　**元组模式**\n\n　　　　以下代码显示了游戏“rock, paper, scissors（石头剪刀布）”的切换表达式：\n\n```\npublic static string RockPaperScissors(string first, string second)\n    \\=> (first, second) switch\n    {\n        (\"rock\", \"paper\") => \"rock is covered by paper. Paper wins.\",\n        (\"rock\", \"scissors\") => \"rock breaks scissors. Rock wins.\",\n        (\"paper\", \"rock\") => \"paper covers rock. Paper wins.\",\n        (\"paper\", \"scissors\") => \"paper is cut by scissors. Scissors wins.\",\n        (\"scissors\", \"rock\") => \"scissors is broken by rock. Rock wins.\",\n        (\"scissors\", \"paper\") => \"scissors cuts paper. Scissors wins.\",\n        (\\_, \\_) \\=> \"tie\"\n    };\n```\n\n　　　　**位置模式**\n\n　　　　暂无\n\n*   **C# 9.0**\n\n　　　　模式匹配改进：\n\n*   *   类型模式要求在变量是一种类型时匹配\n    *   带圆括号的模式强制或强调模式组合的优先级\n    *   联合 `and` 模式要求两个模式都匹配\n    *   析取 `or` 模式要求任一模式匹配\n    *   否定 `not` 模式要求模式不匹配\n    *   关系模式要求输入小于、大于、小于等于或大于等于给定常数。\n\n```\npublic static bool IsLetter(this char c) =>\n    c is >= \'a\' and <= \'z\' or >= \'A\' and <= \'Z\';\n```\n\n```\npublic static bool IsLetterOrSeparator(this char c) =>\n    c is (>= \'a\' and <= \'z\') or (>= \'A\' and <= \'Z\') or \'.\' or \',\';\n```\n\n```\nif (e is not null)\n{\n    // ...\n}\n```\n\n 　　　　类型模式示例：\n\n```\npublic static decimal CalculateToll(this Vehicle vehicle) => vehicle switch\n{\n    Car \\=> 2.00m,\n    Truck \\=> 7.50m,\n    null => throw new ArgumentNullException(nameof(vehicle)),\n    \\_ \\=> throw new ArgumentException(\"Unknown type of a vehicle\", nameof(vehicle)),\n};\n```\n\n*   **C# 10.0（预览版）**\n\n  \n', '', 0, 0, 5, 0, 1, 0, 1659321115018, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659321115018, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (23, 0, 9, 2, 'PLSQL 设置', '*   默认选中 My objects\n\n*   工具 --> 对象浏览器过滤 --> 设置 My objects 默认\n\n\n*   定义 对象浏览器 中文件夹位置并设置颜色\n    *   工具 --> 对象浏览器文件夹 --> 移动常用文件夹（Tables,Procedures,Packages,Package bodies,Sequences,Functions）到最上面并设置文件夹颜色\n\n\n*   记住密码\n\n*   工具 --> 首选项 --> Oracle --> 登录历史 --> 勾选  带密码存储\n\n*   双击显示表数据\n\n*   工具 --> 首选项 --> 用户界面 --> 对象浏览器 --> 为不同的 对象类型 绑定 双击动作 和 拖放动作\n\n*   关键字大写\n    *   工具 --> 首选项 --> 用户界面 --> 编辑器 --> 设置 关键字大小写 为 大写\n*   自定义快捷键\n\n*   工具 --> 首选项 --> 用户界面 --> 键配置 --> 为操作设置自己的快捷键\n*   SQL窗口 --> Alt + S\n*   命令窗口 --> Alt + C\n*   执行  -->  F8\n*   代码助手  -->  F6\n\n*   根据光标位置自动选择语句\n    *   工具 --> 首选项 --> 窗口类型 --> SQL窗口 --> 勾选 自动选择语句\n    *   工具 --> 首选项 --> 用户界面 --> 编辑器 --> 其它 --> 选中 高亮编辑行\n    *   注意 每条语句 后面要加分号\n*   自动替换\n    *   工具 --> 首选项 --> 用户界面 --> 编辑器 --> 自动替换 --> 选中 启用 项\n    *   在 PLSQL 安装目录的 PlugIns 文件夹下创建 shortcuts.txt 文件\n    *   在 定义文件 项选择创建的 shortcuts.txt 文件\n    *   一些常用定义：\n    *   ```\n        s=SELECT\n        f\\=FROM\n        i\\=INSERT\n        u\\=UPDATE\n        d\\=DELETE\n        w\\=WHERE\n        o\\=ORDER BY\n        sf\\=SELECT \\* FROM\n        df\\=DELETE FROM\n        sc\\=SELECT COUNT（\\*） FROM\n        desc\\=DESCRIBE\n        st\\=select table\\_name from user\\_tables\n        stw\\=select table\\_name from user\\_tables where table\\_name like \'%%\'\n        ```\n        \n*   关闭代码助手\n\n*   工具 --> 首选项 --> 用户界面 --> 代码助手 --> 取消选中 自动激活 \n\n*   字体设置\n\n*   工具 --> 首选项 --> 用户界面 --> 字体 --> 设置 浏览器，表格，编辑器 字体 （个人喜欢 Consolas）　　\n', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a056a18-4e48-6aa6-06ec-7dbcf9e1e3fe_微信截图_20220801133951.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a18-4e48-6aa6-06ec-7dbcf9e1e3fe_微信截图_20220801133951.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a056a18-4e3c-9bc3-c17a-38d1813cccb8_微信截图_20220801134005.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a18-4e3c-9bc3-c17a-38d1813cccb8_微信截图_20220801134005.png\"}]', 0, 0, 17, 0, 0, 0, 1659332439073, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659332439073, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (24, 0, 1, 2, 'cron表达式', '格式：0 \\* \\* \\* \\* ?  ，对应：秒  分  时  日  月  周  年(可省略)\n\n特殊字符说明：\n\n*   星号（\\*）： 可用在所有字段中，表示对应时间域的每一个时刻，例如：\\*在分钟字段时，表示“每分钟”；\n*   问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”；\n*   减号（-）： 表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12；\n*   逗号（,）： 表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五；\n*   斜杠（/）： x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用\\*/y，它等同于0/y；\n\n0 20 17 ? \\* THUR 每周四 17:20:00\n', '', 0, 0, 8, 0, 0, 0, 1659332620399, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659332620399, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (25, 0, 11, 11, '郴州国际陆港多联平台--大屏', '#### **效果预览地址：**\n##### http://db.winjoinit.com:59876\n------------------------------------\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a366-bd6d-9bed-270a-b90f7956478f_1郴州国际陆港数字大屏-联运主题7.29-大.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a366-f110-5b7e-0494-ed2f9006c8f4_2郴州国际陆港数字大屏-联运主题-公路.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-492c-1bb9-ecd4-e91068f21231_3郴州国际陆港数字大屏-联运主题-铁路.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-6313-7d83-54db-062c0cc463a7_4郴州国际陆港数字大屏-联运主题-海运.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-7e7f-6840-9658-b7f7585f0baf_5郴州国际陆港数字大屏-通道主题8.1.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-9ed9-4f02-7952-2a43d1a1a715_6郴州国际陆港数字大屏-通道-中欧班列.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-d635-9831-214a-d5f9e6a1d237_7郴州国际陆港数字大屏-通道-东盟海铁.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a367-f4b7-6ea7-59dc-9a1fb41e03e6_8郴州国际陆港数字大屏-通关主题8.1.png)', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fdeb-0150-5621-9e0ae3bdaa1c_1郴州国际陆港数字大屏-联运主题7.29-大.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fdeb-0150-5621-9e0ae3bdaa1c_1郴州国际陆港数字大屏-联运主题7.29-大.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fda0-a183-c177-faa620d2d636_2郴州国际陆港数字大屏-联运主题-公路.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fda0-a183-c177-faa620d2d636_2郴州国际陆港数字大屏-联运主题-公路.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fdf1-354b-3327-fbcd76079087_3郴州国际陆港数字大屏-联运主题-铁路.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fdf1-354b-3327-fbcd76079087_3郴州国际陆港数字大屏-联运主题-铁路.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fdb5-d780-121f-2783034a0863_4郴州国际陆港数字大屏-联运主题-海运.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fdb5-d780-121f-2783034a0863_4郴州国际陆港数字大屏-联运主题-海运.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fdd6-8c76-5ecf-235a1cc843bd_5郴州国际陆港数字大屏-通道主题8.1.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fdd6-8c76-5ecf-235a1cc843bd_5郴州国际陆港数字大屏-通道主题8.1.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a365-fdd9-4b03-faae-d3cbc18f71b1_6郴州国际陆港数字大屏-通道-中欧班列.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a365-fdd9-4b03-faae-d3cbc18f71b1_6郴州国际陆港数字大屏-通道-中欧班列.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a366-0314-dd74-3c4c-a1f979bc6362_7郴州国际陆港数字大屏-通道-东盟海铁.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a366-0314-dd74-3c4c-a1f979bc6362_7郴州国际陆港数字大屏-通道-东盟海铁.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a366-0266-6d96-d823-9ce732e6db23_8郴州国际陆港数字大屏-通关主题8.1.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a366-0266-6d96-d823-9ce732e6db23_8郴州国际陆港数字大屏-通关主题8.1.png\"}]', 0, 0, 65, 2, 3, 0, 1659424000150, 12, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659336055778, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (26, 0, 5, 2, '利用wsdl生成代理类', '用于为xml web服务客户端和xml web服务生成代码的实用工具使用ASP。NET从WSDL契约文件、XSD模式和.discomap发现文档。此工具可与disco.exe结合使用。\n\n---\nwsdl参数说明：\n\n**wsdl.exe <选项> <URL 或路径> <URL 或路径> ...**\n\n/nologo  \n取消显示版权标志。\n  \n***/language:<language>***  \n用于生成的代理类的语言。请从“CS”、“VB”、“JS”、“VJS”、“CPP”中选择，或者为实现 System.CodeDom.Compiler.CodeDomProvider 的类提供一个完全限定的名称。\n默认语言为“CS”(CSharp)。缩写形式为“/l:”。\n\n/sharetypes  \n打开类型共享功能。此功能针对不同服务之间共享的相同类型(命名空间、名称和网络签名必须相同)创建一个具有单一类型定义的代码文件。\n请使用 http:// URLs 作为命令行参数来引用  服务，或为本地文件创建一个 discomap 文档。\n\n/verbose\n指定 /sharetypes 开关时显示额外信息。缩写形式为“/v”。\n\n/fields\n生成字段而非属性。缩写形式为“/f”。\n\n/order\n为粒子成员生成显式顺序标识符。\n\n/enableDataBinding\n在所有生成的类型上实现 INotifyPropertyChanged 接口，以启用数据绑定。缩写形式为“/edb”。\n\n***/namespace:<namespace>***\n生成的代理或模板的命名空间。默认命名空间为全局命名空间。缩写形式为“/n:”。\n\n***/out:<fileName|directoryPath>***\n生成的代理代码的文件名或目录路径。默认文件名是从服务名派生的。缩写形式为“/o:”。\n\n/protocol:<protocol>\n重写要实现的默认协议。请从“SOAP”、“SOAP12”、“HttpGet”、“HttpPost”中选择。\n\n/username:<username>  \n/password:<password>  \n\n/domain:<domain>\n连接到要求身份验证的服务器时使用的凭据。缩写形式为“/u:”、“/p:”和“/d:”。\n\n/proxy:<url>\n用来处理 HTTP 请求的代理服务器的 URL。默认为使用系统代理服务器设置。\n\n/proxyusername:<username>  \n/proxypassword:<password>  \n/proxydomain:<domain>\n连接到要求身份验证的代理服务器时使用的凭据。  \n缩写形式为“/pu:”、“/pp:”和“/pd:”。\n\n/appsettingurlkey:<key>\n在代码生成中用来读取 URL 属性的默认值的配置项。默认为不从配置文件中读取。缩写形式为“/urlkey:”。\n\n/appsettingbaseurl:<baseurl>\n计算 URL 段时使用的基 URL。还必须指定 appsettingurlkey 选项。URL 段是从 appsettingbaseurl 计算 WSDL 文档中的 URL 的相对 URL 的结果。缩写形式为“/baseurl:”。\n\n/parsableerrors\n输出错误，其格式与编译器报告的格式类似。\n\n/server\n服务器开关已被否决。请改用 /serverInterface。使用基于协定的 ASP.NET，为 Xml Web Services 实现生成抽象类。默认情况下，生成客户端代理类。\n\n/serverInterface\n为 ASP.Net Web 服务的服务器端实现生成接口。将为 wsdl 文档中的每个绑定生成一个接口。wsdl 单独实现 wsdl 协定(实现接口的类在类方法上不应包括下列任意一项: 更改 wsdl 协定的 Web 服务属性或序列化属性)。缩写形式为“/si”。\n\n/parameters:<file>\n从指定的 xml 文件读取命令行选项。这样可以指定命令行中无法使用的选项，例如选择生成的异步编程模型类型。有关详细信息，请参阅工具文档。缩写形式为“/par:”。', '', 0, 0, 7, 0, 0, 0, 1659336646522, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659336646522, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (27, 0, 5, 2, '通过winsw注册windows服务', 'winsw（Windows Service Wrapper）是一个开源项目，它可以让我们快速把一个可执行的程序注册为Windows的系统服务。\n\n开源地址：[https://github.com/kohsuke/winsw](https://github.com/kohsuke/winsw)\n\n1、最新的版本是v2.11.0，下载对应平台的exe文件\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a79-c5ab-c9e3-d9ea-8e44b4a7b0f1_微信截图_20220801152627.png)\n\n下载地址提供了两份配置文件：\n- sample-allOptions.xml：包含所有配置项\n- smaple-minimal.xml：最小配置项\n\n2、把下载的.exe文件重命名为你自己要用的服务名称，如myapp.exe\n\n3、在myapp.exe同目录下创建同名的xml配置文件，可以复制上面下载的xml，简单配置如下：\n\n```\n  <service>\n  <!-- 该服务的唯一标识 -->\n  <id>myapp</id>\n  <!-- 注册为系统服务的名称 -->\n  <name>myapp</name>\n  <!-- 对服务的描述 -->\n  <description>Send the data to customer</description>\n  <!-- 将java程序添加到系统服务 -->\n  <executable>java</executable>\n  <!-- 执行的参数 -->\n  <arguments>-jar \"myapp.jar\"</arguments>\n  <!-- 日志模式 -->\n  <logmode>rotate</logmode>\n</service>\n```\n\n4、注册服务及其它命令\n```\n  注册服务：myapp.exe install\n  卸载服务：myapp.exe uninstall\n  启动服务：myapp.exe start\n  停止服务：myapp.exe stop\n  重启服务：myapp.exe restart \n  查看服务：myapp.exe status \n```', '', 0, 0, 6, 0, 0, 0, 1659339231163, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659339231163, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (28, 0, 7, 9, '部署baget 管理包', '为了代码重复使用率和代码统一管理，一般都会把一些通用的代码进行封装打包发布，以供别人使用。baget能够很好的用来管理包，下面就来介绍如何部署baget到linux服务器上以及使用问题。\n[baget官网链接地址](https://loic-sharma.github.io/BaGet/installation/docker/)\n1.新建一个启动配置文件\n``` XML\n# The following config is the API Key used to publish packages.\n# You should change this to a secret value to secure your server.\nApiKey=winjoinit                                #秘钥\nStorage__Type=FileSystem\nStorage__Path=/root/wjframe/wjnuget/packages     #包保存地址\nDatabase__Type=Mysql                             #数据库类型\nDatabase__ConnectionString=server=192.168.1.83;database=baget;userid=root;password=root\nSearch__Type=Database\n```\n2.新建一个文件夹用来存储包  baget-data\n3.下载baget镜像\n``` docker\ndocker pull loicsharma/baget\n```\n4.启动\n``` docker\ndocker run --rm --name nuget-server -p 6001:80 --env-file baget.env -v \"$(pwd)/baget-data:/root/wjframe/wjnuget\" loicsharma/baget:latest\n```\n5.使用发布工具发布你的包\n\n6.包管理网址\n``` html\nhttp://192.168.1.83:6001\n```\n\n\n', '', 0, 0, 17, 1, 0, 0, 1659412403608, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659411711651, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (29, 0, 7, 2, '仅在 Windows 上支持 System.Drawing.Common', '[System.Drawing.Common](https://www.nuget.org/packages/System.Drawing.Common/) NuGet 包现在被归为 Windows 特定的库。 在为非 Windows 操作系统编译时，平台分析器会在编译时发出警告。\n\n在非 Windows 操作系统上，除非设置了运行时配置开关，否则将引发 [TypeInitializationException](https://docs.microsoft.com/zh-cn/dotnet/api/system.typeinitializationexception) 异常，其中 [PlatformNotSupportedException](https://docs.microsoft.com/zh-cn/dotnet/api/system.platformnotsupportedexception) 作为内部异常。\n\n旧行为\n---\n\n在 .NET 6 之前，使用 System.Drawing.Common 包不会产生任何编译时警告，也不会引发任何运行时异常。\n\n新行为\n---\n\n从 .NET 6 开始，当为非 Windows 操作系统编译引用代码时，平台分析器会发出编译时警告。 此外，除非设置了配置选项，否则将引发以下运行时异常：\n\n```\nSystem.TypeInitializationException : The type initializer for \'Gdip\' threw an exception.\n      ---- System.PlatformNotSupportedException : System.Drawing.Common is not supported on non-Windows platforms. See https://aka.ms/systemdrawingnonwindows for more information.\n      Stack Trace:\n           at System.Drawing.SafeNativeMethods.Gdip.GdipCreateBitmapFromFile(String filename, IntPtr& bitmap)\n        /_/src/libraries/System.Drawing.Common/src/System/Drawing/Bitmap.cs(42,0): at System.Drawing.Bitmap..ctor(String filename, Boolean useIcm)\n        /_/src/libraries/System.Drawing.Common/src/System/Drawing/Bitmap.cs(25,0): at System.Drawing.Bitmap..ctor(String filename)\n        /_/src/libraries/System.Resources.ResourceManager/tests/ResourceManagerTests.cs(270,0): at System.Resources.Tests.ResourceManagerTests.EnglishImageResourceData()+MoveNext()\n        /_/src/libraries/System.Linq/src/System/Linq/Select.cs(136,0): at System.Linq.Enumerable.SelectEnumerableIterator`2.MoveNext()\n        ----- Inner Stack Trace -----\n        /_/src/libraries/System.Drawing.Common/src/System/Drawing/LibraryResolver.cs(31,0): at System.Drawing.LibraryResolver.EnsureRegistered()\n        /_/src/libraries/System.Drawing.Common/src/System/Drawing/GdiplusNative.Unix.cs(65,0): at System.Drawing.SafeNativeMethods.Gdip.PlatformInitialize()\n        /_/src/libraries/System.Drawing.Common/src/System/Drawing/Gdiplus.cs(27,0): at System.Drawing.SafeNativeMethods.Gdip..cctor()\n\n```\n\n引入的版本\n-----\n\n.NET 6\n\n中断性变更的类型\n--------\n\n此更改会影响[源兼容性](https://docs.microsoft.com/categories#source-compatibility)和[二进制兼容性](https://docs.microsoft.com/categories#binary-compatibility)。\n\n更改原因\n----\n\n由于 `System.Drawing.Common` 被设计为 Windows 技术的精简包装器，因此其跨平台实现欠佳。\n\n`libgdiplus` 是本机端 `System.Drawing.Common` 跨平台实现的主要提供程序。 `libgdiplus` 实际上是对 `System.Drawing.Common` 所依赖的 Windows 部分的重新实现。 该实现使 `libgdiplus` 成为一个重要的组件。 它大约有 30,000 行 C 代码，大部分未经测试，而且缺少很多功能。 `libgdiplus` 还具有许多用于图像处理和文本呈现的外部依赖项，例如 `cairo`、`pango` 和其他本机库。 这些依赖项使得维护和交付组件更具挑战性。 自从包含 Mono 跨平台实现以来，我们已将许多从未得到修复的问题重定向到 `libgdiplus`。 相比之下，我们采用的其他外部依赖项，例如 `icu` 或 `openssl`，都是高质量的库。 使 `libgdiplus` 的功能集和质量与 .NET 堆栈的其余部分相媲美是不可行的。\n\n通过对 NuGet 包的分析，我们观察到 `System.Drawing.Common` 主要用于跨平台的图像处理，例如 QR 代码生成器和文本呈现。 由于我们的跨平台图形支持不完整，我们还没有注意到大量的图形使用。 `System.Drawing.Common` 在非 Windows 环境中的使用通常得到 SkiaSharp 和 ImageSharp 的良好支持。\n\n`System.Drawing.Common` 将仅在 Windows 窗体和 GDI+ 的上下文中继续演变。\n\n建议的操作\n-----\n\n若要将这些 API 用于跨平台应用，请迁移到以下库之一：\n\n*   [ImageSharp](https://github.com/SixLabors/ImageSharp)\n*   [SkiaSharp](https://github.com/mono/SkiaSharp)\n*   [Microsoft.Maui.Graphics](https://github.com/dotnet/Microsoft.Maui.Graphics)\n\n或者，可通过将 runtimeconfig.json 文件中的 `System.Drawing.EnableUnixSupport``System.Drawing.EnableUnixSupport`设置为 `true` 来启用对 .NET 6 中非 Windows 平台的支持：\n\n```\n{\n   \"configProperties\": {\n      \"System.Drawing.EnableUnixSupport\": true\n   }\n}\n\n```\n\n添加此配置开关是为了让严重依赖此包的跨平台应用有时间迁移到更新式的库。 但是，不会修复非 Windows bug。 此外，此开关已在 .NET 7 中删除。\n\n受影响的 API\n--------\n\n[System.Drawing](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing) 命名空间：\n\n*   [Bitmap](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.bitmap)\n*   [Brush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.brush)\n*   [Brushes](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.brushes)\n*   [BufferedGraphics](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.bufferedgraphics)\n*   [BufferedGraphicsContext](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.bufferedgraphicscontext)\n*   [Font](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.font)\n*   [FontFamily](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.fontfamily)\n*   [FontConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.fontconverter)\n*   [Graphics](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.graphics)\n*   [Icon](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.icon)\n*   [IconConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.iconconverter)\n*   [Image](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.image)\n*   [ImageAnimator](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imageanimator)\n*   [Pen](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.pen)\n*   [Pens](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.pens)\n*   [Region](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.region)\n*   [SolidBrush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.solidbrush)\n*   [StringFormat](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.stringformat)\n*   [SystemBrushes](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.systembrushes)\n*   [SystemFonts](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.systemfonts)\n*   [SystemIcons](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.systemicons)\n*   [SystemPens](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.systempens)\n*   [TextureBrush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.texturebrush)\n\n[System.Drawing.Drawing2D](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d) 命名空间：\n\n*   [AdjustableArrowCap](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.adjustablearrowcap)\n*   [CustomLineCap](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.customlinecap)\n*   [GraphicsPath](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.graphicspath)\n*   [GraphicsPathIterator](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.graphicspathiterator)\n*   [GraphicsState](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.graphicsstate)\n*   [HatchBrush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.hatchbrush)\n*   [LinearGradientBrush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.lineargradientbrush)\n*   [Matrix](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.matrix)\n*   [PathGradientBrush](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.drawing2d.pathgradientbrush)\n\n[System.Drawing.Imaging](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging) 命名空间：\n\n*   [Encoder](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.encoder)\n*   [EncoderParameter](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.encoderparameter)\n*   [EncoderParameters](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.encoderparameters)\n*   [ImageAttributes](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.imageattributes)\n*   [ImageCodecInfo](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.imagecodecinfo)\n*   [ImageFormat](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.imageformat)\n*   [Metafile](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.metafile)\n*   [MetafileHeader](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.metafileheader)\n*   [PlayRecordCallback](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.imaging.playrecordcallback)\n\n[System.Drawing.Printing](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing) 命名空间：\n\n*   [PageSettings](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.pagesettings)\n*   [PreviewPageInfo](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.previewpageinfo)\n*   [PrintController](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printcontroller)\n*   [PrintDocument](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printdocument)\n*   [PrinterSettings](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printersettings)\n*   [PrintEventArgs](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printeventargs)\n*   [PrintEventHandler](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printeventhandler)\n*   [PrintPageEventArgs](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printpageeventargs)\n*   [PrintPageEventHandler](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.printing.printpageeventhandler)\n\n[System.Drawing.Text](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.text) 命名空间：\n\n*   [FontCollection](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.text.fontcollection)\n*   [InstalledFontCollection](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.text.installedfontcollection)\n*   [PrivateFontCollection](https://docs.microsoft.com/zh-cn/dotnet/api/system.drawing.text.privatefontcollection)\n\n---\n[原文链接](https://docs.microsoft.com/zh-cn/dotnet/core/compatibility/core-libraries/6.0/system-drawing-common-windows-only)', '', 0, 0, 4, 0, 0, 0, 1659421045657, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659421045657, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (30, 0, 7, 12, '统一社会信用代码JS校验', '``` JavaScript\nfunction CheckSocialCreditCode(Code) {\n  var patrn = /^[0-9A-Z]+$/; //18位校验及大写校验\n  if (Code.length != 18 || patrn.test(Code) == false) {\n    alert(\"不是有效的统一社会信用编码！\");\n  } else {\n    var Ancode; //统一社会信用代码的每一个值\n    var Ancodevalue; //统一社会信用代码每一个值的权重\n    var total = 0;\n    var weightedfactors = [\n      1, 3, 9, 27, 19, 26, 16, 17, 20, 29, 25, 13, 8, 24, 10, 30, 28\n    ]; //加权因子\n    var str = \"0123456789ABCDEFGHJKLMNPQRTUWXY\"; //不用I、O、S、V、Z\n    for (var i = 0; i < Code.length - 1; i++) {\n      Ancode = Code.substring(i, i + 1);\n      Ancodevalue = str.indexOf(Ancode);\n      total = total + Ancodevalue * weightedfactors[i]; //权重与加权因子相乘之和\n    }\n    var logiccheckcode = 31 - (total % 31);\n    if (logiccheckcode == 31) {\n      logiccheckcode = 0;\n    }\n    var Str = \"0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,J,K,L,M,N,P,Q,R,T,U,W,X,Y\";\n    var Array_Str = Str.split(\",\");\n    logiccheckcode = Array_Str[logiccheckcode];\n\n    var checkcode = Code.substring(17, 18);\n    if (logiccheckcode != checkcode) {\n      alert(\"不是有效的统一社会信用编码！\");\n    }\n  }\n}\n\n```', '', 0, 0, 18, 1, 1, 0, 1659422208185, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659422060028, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (31, 0, 7, 2, '$ - 字符串内插（C# 参考）', '`$` 特殊字符将字符串文本标识为内插字符串 。 内插字符串是可能包含内插表达式的字符串文本 。 将内插字符串解析为结果字符串时，带有内插表达式的项会替换为表达式结果的字符串表示形式。 从 C# 6 开始可以使用此功能。\n\n字符串内插为格式化字符串提供了一种可读性和便捷性更高的方式。 它比[字符串复合格式设置](https://docs.microsoft.com/standard/base-types/composite-formatting)更容易阅读。 比较一下下面的示例，它使用了这两种功能产生相同的输出：\n\n```\nstring name = \"Mark\";\nvar date = DateTime.Now;\n\n// Composite formatting:\nConsole.WriteLine(\"Hello, {0}! Today is {1}, it\'s {2:HH:mm} now.\", name, date.DayOfWeek, date);\n// String interpolation:\nConsole.WriteLine($\"Hello, {name}! Today is {date.DayOfWeek}, it\'s {date:HH:mm} now.\");\n// Both calls produce the same output that is similar to:\n// Hello, Mark! Today is Wednesday, it\'s 19:40 now.\n\n```\n\n内插字符串的结构\n--------\n\n若要将字符串标识为内插字符串，可在该字符串前面加上 `$` 符号。 字符串字面量开头的 `$` 和 `\"` 之间不能有任何空格。\n\n具备内插表达式的项的结构如下所示：\n\n```\n{<interpolationExpression>[,<alignment>][:<formatString>]}\n\n```\n\n括号中的元素是可选的。 下表说明了每个元素：\n\n| 元素 | 描述 |\n| --- | --- |\n| `interpolationExpression` | 生成需要设置格式的结果的表达式。 `null` 的字符串表示形式为 [String.Empty](https://docs.microsoft.com/zh-cn/dotnet/api/system.string.empty)。 |\n| `alignment` | 常数表达式，它的值定义表达式结果的字符串表示形式中的最小字符数。 如果值为正，则字符串表示形式为右对齐；如果值为负，则为左对齐。 有关详细信息，请参阅[对齐组件](https://docs.microsoft.com/standard/base-types/composite-formatting#alignment-component)。 |\n| `formatString` | 受表达式结果类型支持的格式字符串。 有关更多信息，请参阅[格式字符串组件](https://docs.microsoft.com/standard/base-types/composite-formatting#format-string-component)。 |\n\n以下示例使用上述可选的格式设置组件：\n\n```\nConsole.WriteLine($\"|{\"Left\",-7}|{\"Right\",7}|\");\n\nconst int FieldWidthRightAligned = 20;\nConsole.WriteLine($\"{Math.PI,FieldWidthRightAligned} - default formatting of the pi number\");\nConsole.WriteLine($\"{Math.PI,FieldWidthRightAligned:F3} - display only three decimal digits of the pi number\");\n// Expected output is:\n// |Left   |  Right|\n//     3.14159265358979 - default formatting of the pi number\n//                3.142 - display only three decimal digits of the pi number\n\n```\n\n从 C# 10 开始，可以使用字符串内插来初始化常量字符串。 用于占位符的所有表达式都必须是常量字符串。 换言之，每个内插表达式都必须是一个字符串，并且必须是编译时常量。\n\n从 C# 11 开始，内插表达式可以包含换行符。 `{` 和 `}` 之间的文本必须是有效的 C#，这样它可以包含换行符，从而提高可读性。 下面的示例展示了换行符如何提高涉及模式匹配的表达式的可读性：\n\n```\nstring message = $\"The usage policy for {safetyScore} is {\n    safetyScore switch\n    {\n        > 90 => \"Unlimited usage\",\n        > 80 => \"General usage, with daily safety check\",\n        > 70 => \"Issues must be addressed within 1 week\",\n        > 50 => \"Issues must be addressed within 1 day\",\n        _ => \"Issues must be addressed before continued use\",\n    }\n    }\";\n\n```\n\n此外，从 C# 11 开始，可以对格式 [字符串使用原始字符串文本](https://docs.microsoft.com/builtin-types/reference-types#string-literals) ：\n\n```\nint X = 2;\nint Y = 3;\n\nvar pointMessage = $\"\"\"The point \"{X}, {Y}\" is {Math.Sqrt(X * X + Y * Y)} from the origin\"\"\";\n\nConsole.WriteLine(pointMessage);\n// output:  The point \"2, 3\" is 3.605551275463989 from the origin.\n\n```\n\n可以使用内插原始字符串文本中的多个 `$` 字符在输出字符串中嵌入 `{` 和 `}` 字符，而无需转义它们：\n\n```\nint X = 2;\nint Y = 3;\n\nvar pointMessage = $$\"\"\"The point {{{X}}, {{Y}}} is {{Math.Sqrt(X * X + Y * Y)}} from the origin\"\"\";\nConsole.WriteLine(pointMessage);\n// output:  The point {2, 3} is 3.605551275463989 from the origin.\n\n```\n\n如果输出字符串应包含重复 `{` 字符串或 `}` 字符，可以添加更多 `$` 内容来指定内插字符串。 `{`任何序列或`}`短于数字，或`$`将嵌入到输出字符串中。 如前面的示例中所示，序列长度超过字符序列 `$` ，在输出中嵌入其他 `{` 字符或 `}` 字符。 如果大括号字符序列等于或大于字符序列 `$` 长度的两倍，编译器将发出错误。\n\n可以使用 .NET 7 SDK 试用这些功能。 或者，如果你有 .NET SDK 6.00.200 或更高版本，则可以将 _csproj_ 文件中的`<LangVersion>`元素设置为 `preview`。\n\n特殊字符\n----\n\n要在内插字符串生成的文本中包含大括号 \"{\" 或 \"}\"，请使用两个大括号，即 \"{{\" 或 \"}}\"。 有关详细信息，请参阅[转义大括号](https://docs.microsoft.com/standard/base-types/composite-formatting#escaping-braces)。\n\n因为冒号（“:”）在内插表达式项中具有特殊含义，为了在内插表达式中使用[条件运算符](https://docs.microsoft.com/operators/conditional-operator)，请将表达式放在括号内。\n\n以下示例演示了如何在结果字符串中包括大括号。 它还演示了如何使用条件运算符：\n\n```\nstring name = \"Horace\";\nint age = 34;\nConsole.WriteLine($\"He asked, \\\"Is your name {name}?\\\", but didn\'t wait for a reply :-{{\");\nConsole.WriteLine($\"{name} is {age} year{(age == 1 ? \"\" : \"s\")} old.\");\n// Expected output is:\n// He asked, \"Is your name Horace?\", but didn\'t wait for a reply :-{\n// Horace is 34 years old.\n\n```\n\n内插逐字字符串以 `$` 字符开头，后跟 `@` 字符。 有关逐字字符串的详细信息，请参阅[字符串](https://docs.microsoft.com/builtin-types/reference-types)和[逐字标识符](https://docs.microsoft.com/verbatim)文章。\n\n注意\n\n从 C# 8.0 开始，可以按任意顺序使用 `$` 和 `@` 标记：`$@\"...\"` 和 `@$\"...\"` 均为有效的内插逐字字符串。 在早期 C# 版本中，`$` 标记必须出现在 `@` 标记之前。\n\n隐式转换和指定 `IFormatProvider` 实现的方式\n-------------------------------\n\n内插字符串有 3 种隐式转换：\n\n1.  将内插字符串转换为 [String](https://docs.microsoft.com/zh-cn/dotnet/api/system.string) 实例。 字符串是内插字符串解析的结果。 所有内插表达式项都被替换为结果的格式设置正确的字符串表示形式。 此转换使用 [CurrentCulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.cultureinfo.currentculture#system-globalization-cultureinfo-currentculture) 设置表达式结果的格式。\n    \n2.  将内插字符串转换为表示复合格式字符串的 [FormattableString](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring) 实例，同时也将表达式结果格式化。 这允许通过单个 [FormattableString](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring) 实例创建多个包含区域性特定内容的结果字符串。 要执行此操作，请调用以下方法之一：\n    \n    *   [ToString()](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring.tostring#system-formattablestring-tostring) 重载，生成 [CurrentCulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.cultureinfo.currentculture#system-globalization-cultureinfo-currentculture) 的结果字符串。\n    *   [Invariant](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring.invariant) 方法，生成 [InvariantCulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.cultureinfo.invariantculture#system-globalization-cultureinfo-invariantculture) 的结果字符串。\n    *   [ToString(IFormatProvider)](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring.tostring#system-formattablestring-tostring(system-iformatprovider)) 方法，生成特定区域性的结果字符串。\n    \n    [ToString(IFormatProvider)](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring.tostring#system-formattablestring-tostring(system-iformatprovider)) 方法提供支持自定义格式设置的 [IFormatProvider](https://docs.microsoft.com/zh-cn/dotnet/api/system.iformatprovider) 接口的用户定义实现。 有关详细信息，请参阅[在 .NET 中设置类型格式](https://docs.microsoft.com/standard/base-types/formatting-types)一文中的[使用 ICustomFormatter 进行自定义格式设置](https://docs.microsoft.com/standard/base-types/formatting-types#custom-formatting-with-icustomformatter)部分。\n    \n3.  将内插字符串转换为 [IFormattable](https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable) 实例，使用此实例也可通过单个 [IFormattable](https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable) 实例创建多个包含区域性特定内容的结果字符串。\n    \n\n以下示例通过隐式转换为 [FormattableString](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring) 来创建特定于区域性的结果字符串：\n\n```\ndouble speedOfLight = 299792.458;\nFormattableString message = $\"The speed of light is {speedOfLight:N3} km/s.\";\n\nSystem.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.GetCultureInfo(\"nl-NL\");\nstring messageInCurrentCulture = message.ToString();\n\nvar specificCulture = System.Globalization.CultureInfo.GetCultureInfo(\"en-IN\");\nstring messageInSpecificCulture = message.ToString(specificCulture);\n\nstring messageInInvariantCulture = FormattableString.Invariant(message);\n\nConsole.WriteLine($\"{System.Globalization.CultureInfo.CurrentCulture,-10} {messageInCurrentCulture}\");\nConsole.WriteLine($\"{specificCulture,-10} {messageInSpecificCulture}\");\nConsole.WriteLine($\"{\"Invariant\",-10} {messageInInvariantCulture}\");\n// Expected output is:\n// nl-NL      The speed of light is 299.792,458 km/s.\n// en-IN      The speed of light is 2,99,792.458 km/s.\n// Invariant  The speed of light is 299,792.458 km/s.\n\n```\n\n组合多个内插字符串\n---------\n\n若要合并多个内插字符串，请使用每个字符串的内插表达式：\n\n```\nvar firstWord = \"Hello\";\nvar secondWord = \"World\";\n\nvar combinedInterpolatedString = $\"{firstWord}, \" + $\"{secondWord}!\";\n\nConsole.WriteLine(combinedInterpolatedString)\n// output: \"Hello, World!\"\n\n```\n\n其他资源\n----\n\n如果你不熟悉字符串内插，请参阅 [C# 中的字符串内插](https://docs.microsoft.com/tutorials/exploration/interpolated-strings)交互式教程。 还可查看另一个 [C# 中的字符串内插](https://docs.microsoft.com/tutorials/string-interpolation)教程。 该教程演示了如何使用内插字符串生成带格式的字符串。\n\n内插字符串编译\n-------\n\n如果内插字符串类型为 `string`，则通常将其转换为 [String.Format](https://docs.microsoft.com/zh-cn/dotnet/api/system.string.format) 方法调用。 如果分析的行为等同于串联，则编译器可将 [String.Format](https://docs.microsoft.com/zh-cn/dotnet/api/system.string.format) 替换为 [String.Concat](https://docs.microsoft.com/zh-cn/dotnet/api/system.string.concat)。\n\n如果内插字符串类型为 [IFormattable](https://docs.microsoft.com/zh-cn/dotnet/api/system.iformattable) 或 [FormattableString](https://docs.microsoft.com/zh-cn/dotnet/api/system.formattablestring)，则编译器会生成对 [FormattableStringFactory.Create](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.formattablestringfactory.create) 方法的调用。\n\n从 C# 10 开始，使用内插字符串时，编译器将检查内插字符串是否被分配给满足内插字符串处理程序模式要求的类型。 内插字符串处理程序是一种自定义类型，可将内插字符串转换为字符串。 内插字符串处理程序是一种高级方案，通常出于性能原因使用。 可以在[内插字符串改进](https://docs.microsoft.com/proposals/csharp-10.0/improved-interpolated-strings#the-handler-pattern)的语言规范中了解生成内插字符串处理程序的要求。 可以按照“C# 新增功能”部分中的[内插字符串处理程序教程](https://docs.microsoft.com/whats-new/tutorials/interpolated-string-handler)生成一个内插字符串处理程序。 在 .NET 6 中，当对 `string` 类型的参数使用内插字符串时，内插字符串由 [System.Runtime.CompilerServices.DefaultInterpolatedStringHandler](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.defaultinterpolatedstringhandler) 处理。\n\n注意\n\n内插字符串处理程序的一个副作用是，自定义处理程序（包括 [System.Runtime.CompilerServices.DefaultInterpolatedStringHandler](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.defaultinterpolatedstringhandler)）可能不会在所有条件下都计算内插字符串中用作占位符的所有表达式。 这意味着这些表达式中的副作用可能不会发生。\n\nC# 语言规范\n-------\n\n有关详细信息，请参阅 [C# 语言规范](https://docs.microsoft.com/language-specification/readme)的[内插字符串](https://docs.microsoft.com/language-specification/expressions#1173-interpolated-string-expressions)部分。\n\n请参阅\n---\n\n*   [简化内插 (样式规则 IDE0071)](https://docs.microsoft.com/fundamentals/code-analysis/style-rules/ide0071)\n*   [C# 参考](https://docs.microsoft.com/)\n*   [C# 特殊字符](https://docs.microsoft.com/)\n*   [字符串](https://docs.microsoft.com/programming-guide/strings/)\n*   [标准数字格式字符串](https://docs.microsoft.com/standard/base-types/standard-numeric-format-strings)\n*   [复合格式设置](https://docs.microsoft.com/standard/base-types/composite-formatting)\n*   [String.Format](https://docs.microsoft.com/zh-cn/dotnet/api/system.string.format)\n\n[原文链接](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/tokens/interpolated)\n', '', 0, 0, 6, 0, 0, 0, 1659491647787, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659491647787, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (32, 0, 9, 2, '【ORACLE移植DM】统计ORACLE基础信息', '统计 `ORACLE` 数据库基础信息\n```\n  --统计页大小 \nselect name,value from v$parameter where name =\'db_block_size\'; \n--查询编码格式 \nselect * from v$nls_parameters a where a.PARAMETER=\'NLS_CHARACTERSET\';\n\n```\n\n---\n\n统计 ORACLE 数据库中的对象以及表数据量\n```\n  --根据指定用户统计用户下的各对象类型和数目 \nselect object_type,count(*) from all_objects where owner=\'ZOBL\' group by object_type;\n--创建移植辅助表，统计指定用户下所有的对象并插入到辅助表中\ncreate table oracle_objects(obj_owner varchar(100),obj_name varchar(100), obj_type varchar(50));\ninsert into oracle_objects \nselect owner,object_name,object_type FROM all_objects where owner=\'ZOBL\';\nselect * from oracle_objects ORDER BY obj_type;\n--创建移植辅助表，统计每个表的数据量并插入到移植辅助表中\ncreate table oracle_tables(tab_owner varchar(100),tab_name varchar(100),tab_count int);\nBEGIN\n  FOR rec IN (select owner,object_name from all_objects WHERE owner=\'ZOBL\' and object_type=\'TABLE\') \n    LOOP\n      BEGIN\n        execute immediate \'insert into oracle_tables select \'\'\'||rec.owner ||\'\'\',\'\'\'|| rec.object_name ||\'\'\',count(*) from \'|| rec.owner|| \'.\' || rec.object_name;\n        EXCEPTION when others THEN \n          dbms_output.put_line( rec.owner || \'.\' || rec.object_name || \'getcount error\');\n      END;\n    END loop;\nEND;\nselect * from oracle_tables ORDER BY tab_count DESC;\n\n```', '', 0, 0, 21, 0, 0, 0, 1659506699857, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659506699857, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (33, 0, 9, 2, '【ORACLE移植DM】创建用户和表空间', '从 `Oracle` 移植到 `DM`，要求必须创建新的用户和表空间，不要把数据迁移到系统管 理员 `SYSDBA` 用户下和 `MAIN` 表空间下。\n\n#### 创建表空间\n\n使用 `SYSDBA` 用户登录 `DM` 管理工具。右键表空间模块，点击【新建表空间】，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05747f-070d-2137-e3d0-aa6f7c5ec345_dm-create-tspace.png)\n在下图红框内，输入表空间名，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05747f-b760-a928-14d9-80b8e9eba655_dm-create-space2.png)\n\n> 注意：上图中文件大小为 32 MB，对应页大小可以是 4 KB 或 8 KB，若页大小为 16 KB 或 32 KB，则创建实例失败。\n初始化页大小的选择不仅影响表空间数据文件的大小选择，也会对表中每个字段及每条记录产生限制，如下表所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057482-134a-2ee8-f859-ae00cebb56bf_dm-create-space3.png)\n\n可根据项目需要，修改表空间文件、路径、大小、是否自动扩充、扩充上限等信息，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057484-4e27-aafb-3aa3-7c7a2f9f2537_dm-create-space5.png)\n可根据项目需要，设置加密算法、加密密码等信息，该设置均可为空，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057484-e058-d763-b2d2-67ec9f390cfa_图片6.png)\n上述参数设定完成后，点击【确定】即可创建完成表空间。\n\n---\n#### 创建用户\n\n使用 `SYSDBA` 用户登录 `DM` 管理工具。\n展开用户模块，右键管理用户，点击【新建用户】，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057486-61a7-7d4b-008d-d8e3898ea543_图片5.png)\n设置用户名、密码，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057486-e4c5-87fd-537a-4492de1d3f54_图片7.png)\n表空间、索引表空间配置完成后，点击【确定】即可创建完成用户关联表空间，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057487-5204-01b0-5384-be211fce41ff_图片70.png)\n\n---\n#### 用户与模式的关系\n\n每个用户有一个默认的同名的模式，访问自己模式下的表、视图等，不需要加模式名，访问其他模式下的对象需要加上模式名。\n\n\n', '', 0, 0, 10, 0, 0, 0, 1659507548932, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659507548932, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (34, 0, 9, 2, '【ORACLE移植DM】DM数据迁移工具迁移过程', '#### 新建工程与迁移\n\n新建工程，选择迁移，并右键新建迁移。\n在新建工程对话框中填写工程名和工程描述信息，点击【确定】按钮，成功添加了一个工程。如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748a-6036-308f-3de8-de03f1512c76_图片8.png)\n展开工程节点，选择【新建迁移】。输入迁移名称：`test`，迁移描述：从 `Oracle` 迁移到 `DM`，点击【确定】按钮，完成迁移的创建。如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748b-10f2-38b8-3b66-cd4808b750f7_图片9.png)\n\n#### 选择迁移方式\n\n默认打开目录为 `DM` `DTS` 工具介绍，选择【下一步】。迁移方式选择 【`Oracle`-->`DM`】 方式，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748b-e5f6-0b62-2c7e-4b40c88b9e0b_图片10.png)\n\n#### 选择数据源和目的库\n\n分别输入主机名 (`IP`) 端口（`Oracle` 默认端口 `1521`，`DM` 默认端口 `5236`），服务名（`Oracle` 默认服务名 `ORCL`），角色（默认），用户名和口令，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748c-fb9e-e571-1266-1d471ed11574_图片11.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748d-14bf-7167-6d2b-bcd0834263f0_图片12.png)\n\n#### 指定对象复制或查询\n\n选择源模式和目的模式。 从数据源复制对象，默认模式及模式对象、目录、同义词、上下文。\n迁移对象，默认在 `DM` 数据库创新同名模式，并迁移表、视图、物化视图、序列、存储过程/函数、触发器、包、同义词、自定义类型。如需调整，用户可根据自身情况勾选，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748d-c54e-42bf-d330-16f3dad0abb5_图片13.png)\n\n#### 选择迁移对象\n\n此处选择要迁移的具体表格、视图、存储过程等。如需调整，用户可根据名称具体选择，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748e-300e-e6d8-60cf-9b83c9ea4bab_图片14.png)\n\n>注意：转换按钮可设置迁移策略，包括表定义、主键、约束条件、索引、数据、读写行数设置等参数，可供用户调整策略。 列映射选项中可调整列名、数据类型、精度、主键（唯一）、空值限制等参数，用户可自行调整。\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748e-e413-70c2-9e14-9fecad054799_图片15.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748e-faf4-ad2d-d0ce-3d6dec179c49_图片16.png)\n\n#### 审阅迁移任务\n\n用户可查看迁移过程重要参数和修改条件，如需修改，可执行上一步进行修改，确认无误后，点击【完成】，如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748f-7093-065e-b9e5-3602c2095911_图片17.png)\n\n#### 验证数据\n\n完成数据迁移后，我们还需对迁移的数据进行验证，表、视图、存储过程、序列都存在且与原数据一致，迁移完成。如下图所示：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05748f-f4fb-eb5e-8eaf-c8ed53be1a4e_图片18.png)\n\n', '', 0, 0, 13, 0, 0, 0, 1659508055882, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659508055882, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (35, 0, 9, 2, '【ORACLE移植DM】处理迁移过程中错误', '#### 标度大于精度\n\n`Oracle` 中 `number(m,n)`允许 `n>m`，但是在达梦中是不允许的，达梦中 `m>=n`，达梦中 `m` 表示精度，`n` 表示标度。精度是一个无符号整数， 定义了总的数字数；标度定义了小数点右边的数字位数。碰到这种问题一方面要思考一下 `Oracle` 里面列定义是否弄错了，如果是特意这样设计的，要搞清楚这个列到底需要存放什么样的数据，单独迁移这张表，对达梦中的数据类型进行修改。\n\n#### 连接尚未建立或已经关闭\n\n这个问题有可能是因为 `Oracle` 库中存在非法的数据如：`-5486-12-31 00:00:00` 这样 的非法的时间，在批量绑定插入的时候 `JDBC` 未作校验，服务器端检测到就会把这个连接剔除，就会报这个错误。新版的 `JDBC` 驱动（2019-7 月以后）已经对此类问题进行了处理， 增加了校验，碰到非法的数据会直接报错。碰到这种问题建议使用最新的 `JDBC` 驱动，替换 掉迁移工具使用的 `JDBC` 驱动即可。\n\n#### 序列最大值超出达梦范围\n\n<最大值> 指定序列能生成的最大值，如果忽略 `MAXVALUE` 子句，则降序序列的最 大值缺省为 `-1` ，升序序列的最大值为 `9223372036854775807(0x7FFFFFFFFFFFFFFF)` 。 非循环序列在到达最大值之后，将不能继续生成序列数；但是 `oracle` 中最大值 `28个9`，迁 移到 `DM8` 时报序列最大值超出达梦范围的错误（最新的 dts 版本已经直接将超过 DM8 最 大值的序列的最大值转换成 9223372036854775807）\n\n#### 字符串截断\n\n一般从 `oracle` 迁移到 `DM8` 的时候，出现字符串截断的一般都是字段中含有中文，出现这种问题是因为 `DM8` 初始化的时候选择的字符集是 `Unicode（即 utf-8）`，该字符集的国际标准是一个汉字占 3 个字节，而 oracle 中默认情况下一个汉字占 2 个字节，此时迁移的时候就会报下面的错误：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05749f-ec50-f85d-0c9f-2ead35500d98_图片19.png)\n遇到该错误有 3 种解决办法：\n1. 是在初始化的时候，字符集选择 `gb18030`，如下图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a1-8da5-0396-9c1f-0ca076276d02_图片20.png)\n2. 是选择 `VARCHAR` 类型以字符为单位，如图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a1-f866-a404-53e7-a604017a949d_图片21.png)\n3. 因为前面 2 种都需要重新初始化数据库，第三种不需要重新初始化数据库即可解决，即在选择迁移方式的时候，选择字符长度隐射关系为 2，如下图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a2-43cb-48a4-c285-6f1e860f6b20_图片22.png)\n\n#### 记录超长\n\n`DM8` 在初始化的时候，选择的页大小影响后面表每行数据的长度，表每行的长度之和（普通数据类型）不能超过一页大小，如果超过 1 页大小即报记录超长的错误，如下图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a3-2053-c07d-2738-ad98f4835aa7_图片23.png)\n解决办法：\n1. 找到表中 `varchar` 类型比较长的（如 `varchar2(8000)`这种），修改成 `text` 类型；\n2. 初始化的时候页大小选择 `32k`。（对于表中 `varchar2` 类型较长，并且字段较多的情况不太适合，这种情况采用方法 1 解决。\n\n\n#### 违反唯一性约束\n\n这种情况是因为表中设置了唯一性约束或者主键约束，但是数据中有重复记录造成的。 这种情况有可能是原始库的约束被禁用了，或者数据重复迁移造成的。\n解决办法：\n在确定源数据没有问题的情况下，迁移的时候选择删除后再拷贝，如下图：\n在迁移界面中，先中要迁移的表，然后点击转换\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a5-25d6-5bdd-ed97-10e22a672987_图片24.png)\n在弹出的窗口中选择删除后拷贝，如下图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a5-6e04-a6a7-a7d9-27939cf1ec46_图片25.png)\n\n#### 违反引用约束\n\n这种问题主要是由外键约束造成的，父表的数据没有迁移，先迁移了子表的数据，错误如图所示：\n解决办法：\n迁移的时候先不迁移外键等约束，在选择好要迁移的表时，点击转换，按照下面步骤迁移。\n1. 第一次只选择表定义，不选择约束等，如图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a7-57a0-f61b-208f-27eaf5b73977_图片28.png)\n2. 第一次迁移完成后（确保没有错误），第二次只选择数据，如图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a7-0cf0-dd7f-a4fe-2b9a42c56ef7_图片27.png)\n3. 第三步选择约束、索引等，如图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0574a6-ce67-a07e-c1d8-9e78386f29ac_图片26.png)\n\n\n', '', 0, 0, 6, 0, 0, 0, 1659509600976, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659509600976, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (36, 0, 9, 2, '【ORACLE移植DM】有区别的语法', '#### INTEGER\n`ORACLE` 中 `INTEGER` 可定义长度，例如 `INTEGER(10)` 等同于 `NUMBER(10,0)`；\n`Dm8` 中 `INTEGER` 和  `INT` 同义，表示四字节存储的整数，精度10，标度0；\n所以如果迁移的脚本中使用到了 `INTEGER` ，并定义了长度，需要去掉长度定义；\n\n#### ROWID\n`Oracle` 中记录的唯一行号，可作为一种数据类型；\n在`DM8`中不支持，建议改成 `bigint`；\n\n#### RAW\n`ORACLE` 的 `RAW` 类型替换为 `DM` 的 `VARBINARY`\n\n#### NUMTODSINTERVAL\n`NUMTODSINTERVAL(N,\'day\')` 修改为 `n` \n`NUMTODSINTERVAL(N,\'hour\')` 修改为 `n/24*1.0` \n`NUMTODSINTERVAL(N,\'minute\')` 修改为 `n/1440*1.0` \n`NUMTODSINTERVAL(N,\'second\')` 修改为 `n/1440/60*1.0`\n\n\n', '', 0, 0, 19, 0, 0, 0, 1659509824913, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659509824913, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (37, 0, 1, 2, '常用 Linux 命令汇总', '**1.ls – List**\n\nls会列举出当前工作目录的内容（文件或文件夹）\n\n**2.mkdir – Make Directory**\n\nmkdir <new-directory-name>创建一个新目录\n\n**3.pwd – Print Working Directory**\n\npwd显示当前工作目录\n\n**4.cd – Change Directory**\n\ncd <directory>将给定的文件夹（或目录）设置成当前工作目录\n\n**5.rmdir – Remove Directory**\n\nrmdir <directory-name>删除给定的目录\n\n**6.rm – Remove**\n\nrm <file-name>会删除给定的文件或文件夹，可以使用rm -r <directory-name>递归删除文件夹\n\n**7.cp – Copy**\n\ncp <source-file> <destination-file>命令对文件或文件夹进行复制，可以使用cp -r <source-folder> <destination-folder> 选项来递归复制文件夹\n\n**8.mv – MoVe**\n\nmv <source> <destination>命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名\n\n**9.cat – concatenate and print files**\n\ncat <file>用于在标准输出（监控器或屏幕）上查看文件内容\n\n**10.tail – print TAIL (from last) >**\n\ntail <file-name>默认在标准输出上显示给定文件的最后10行内容，可以使用tail -n N <file-name>指定在标准输出上显示文件的最后N行内容\n\n**11.less – print LESS**\n\nless <file-name>按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。\n\n**12.grep**\n\ngrep \"<string>\" <file-name>在给定的文件中搜寻指定的字符串。grep -i \"<string>\" <file-name>在搜寻时会忽略字符串的大小写，而grep -r \"<string>\" <file-name>则会在当前工作目录的文件中递归搜寻指定的字符串。\n\n**13.Find**\n\n这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find <folder-to-search> -name <file-name>的-name选项来进行区分大小写的搜寻，find <folder-to-search> -iname <file-name>来进行不区分大小写的搜寻。\n\n**14.tar**\n\ntar命令能创建、查看和提取tar压缩文件。tar -cvf <archive-name.tar> <file1-OR-file2-OR-both-to-archive>是创建对应压缩文件，tar -tvf <archive-to-view.tar>来查看对应压缩文件，tar -xvf <archive-to-extract.tar>来提取对应压缩文件。\n\n**15.gzip**\n\ngzip <filename>命令创建和提取gzip压缩文件，还可以用gzip -d <filename>来提取压缩文件。\n\n**16.unzip**\n\nunzip <archive-to-extract.zip>对gzip文档进行解压。在解压之前，可以使用unzip -l <archive-to-extract.zip>命令查看文件内容。\n\n**17.help**\n\n<command-name> --help会在终端列出所有可用的命令,可以使用任何命令的-h或-help选项来查看该命令的具体用法。\n\n**18.whatis – What is this command**\n\nwhatis <command-name>会用单行来描述给定的命令。\n\n**19.man – Manual**\n\nman <command-name>会为给定的命令显示一个手册页面。\n\n**20.exit**\n\nexit用于结束当前的终端会话。\n\n**21.ping**  \n\nping <remote-host-address>通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。\n\n**22.who – Who Is logged in**\n\nwho能列出当前登录的用户名。\n\n**23.su – Switch User**\n\nsu <username>用于切换不同的用户。即使没有使用密码，超级用户也能切换到其它用户。\n\n**24.uname**\n\nuname会显示出关于系统的重要信息，如内核名称、主机名、内核版本、处理机类型等等，使用uname -a可以查看所有信息。\n\n**25.free – Free memory**  \n\nfree会显示出系统的空闲内存、已经占用内存、可利用的交换内存等信息，free -m将结果中的单位转换成KB，而free –g则转换成GB。\n\n**26.df – Disk space Free**\n\ndf查看文件系统中磁盘的使用情况–硬盘已用和可用的存储空间以及其它存储设备。你可以使用df -h将结果以人类可读的方式显示。\n\n**27.ps – ProcesseS**\n\nps显示系统的运行进程。\n\n**28.Top – TOP processes**\n\ntop命令会默认按照CPU的占用情况，显示占用量较大的进程,可以使用top -u <username>查看某个用户的CPU使用排名情况。\n\n**29.shutdown**\n\nshutdown用于关闭计算机，而shutdown -r用于重启计算机。', '', 0, 0, 8, 0, 0, 0, 1659580233039, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659580233039, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (38, 0, 7, 2, '从 ASP.NET MVC 迁移到 ASP.NET Core MVC', '本文介绍如何开始将 ASP.NET MVC 项目迁移到 [ASP.NET Core MVC](https://docs.microsoft.com/mvc/overview?view=aspnetcore-6.0)。 在此过程中，它会突出显示 ASP.NET MVC 中的相关更改。\n\n从 ASP.NET MVC 迁移涉及多个步骤。 本文介绍：\n\n*   初始设置。\n*   基本控制器和视图。\n*   静态内容。\n*   客户端依赖项。\n\n有关迁移配置和Identity代码，请参阅[将配置迁移到 ASP.NET Core](https://docs.microsoft.com/configuration?view=aspnetcore-6.0)和[迁移身份验证以及 Identity ASP.NET Core](https://docs.microsoft.com/identity?view=aspnetcore-6.0)。\n\n先决条件\n----\n\n*   具有“ASP.NET 和 Web 开发”工作负载的 [Visual Studio 2019 16.4 或更高版本](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)\n    \n*   [.NET Core 3.1 SDK](https://dotnet.microsoft.com/download/dotnet-core/3.1)\n    \n\n创建起始 ASP.NET MVC 项目\n-------------------\n\n在 Visual Studio 中创建 ASP.NET MVC 项目示例来进行迁移：\n\n1.  从“文件”菜单中选择“新建”>“项目” 。\n2.  选择“ASP.NET Web 应用程序(.NET Framework)”，然后选择“下一步”。\n3.  将项目命名为 WebApp1，使命名空间与下一步中创建的 ASP.NET Core 项目相匹配。 选择“创建”。\n4.  选择“MVC”，然后选择“创建”。\n\n创建 ASP.NET Core 项目\n------------------\n\n使用新的 ASP.NET Core 项目创建要迁移到的新的解决方案：\n\n1.  启动 Visual Studio 的第二个实例。\n2.  从“文件”菜单中选择“新建”>“项目” 。\n3.  选择“ASP.NET Core Web 应用程序”，然后选择“下一步” 。\n4.  在“配置新项目”对话框中，将项目命名为“WebApp1”。\n5.  将位置设置为与上一个项目不同的目录，以使用相同的项目名称。 使用同一个命名空间可更轻松地在两个项目之间复制代码。 选择“创建”。\n6.  在“创建新的 ASP.NET Core Web 应用程序”对话框中，确认选择“.NET Core”和“ASP.NET Core 3.1” 。 选择“Web 应用程序(模型-视图-控制器)”项目模板，然后选择“创建”。\n\n将 ASP.NET Core 网站配置为使用 MVC\n--------------------------\n\n在 ASP.NET Core 3.0 及更高版本中，.NET Framework 不再是受支持的目标框架。 你的项目必须面向 .NET Core。 包含 MVC 的 ASP.NET Core 共享框架是 .NET Core 运行时安装的一部分。 使用项目文件中的 `Microsoft.NET.Sdk.Web` SDK 时，会自动引用共享框架：\n\n```\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n```\n\n有关详细信息，请查看[框架参考](https://docs.microsoft.com/22-to-30?view=aspnetcore-6.0#framework-reference)。\n\n在 ASP.NET Core 中，`Startup` 类：\n\n*   替换 Global.asax。\n*   处理所有应用启动任务。\n\n有关详细信息，请参阅 [ASP.NET Core 中的应用启动](https://docs.microsoft.com/fundamentals/startup?view=aspnetcore-6.0)。\n\n在 ASP.NET Core项目中，打开`Startup.cs`该文件：\n\n```\npublic class Startup\n{\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n    }\n\n    public IConfiguration Configuration { get; }\n\n    // This method gets called by the runtime. Use this method to add services to the container.\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddControllersWithViews();\n    }\n\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n            app.UseHsts();\n        }\n        app.UseHttpsRedirection();\n        app.UseStaticFiles();\n\n        app.UseRouting();\n\n        app.UseAuthorization();\n\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapControllerRoute(\n                name: \"default\",\n                pattern: \"{controller=Home}/{action=Index}/{id?}\");\n        });\n    }\n}\n\n```\n\nASP.NET Core 应用必须选择使用包含中间件的框架功能。 上一个模板生成的代码会添加以下服务和中间件：\n\n*   [AddControllersWithViews](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addcontrollerswithviews) 扩展方法为控制器、API 相关功能和视图注册 MVC 服务支持。 若要详细了解 MVC 服务注册选项，请参阅 [MVC 服务注册](https://docs.microsoft.com/22-to-30?view=aspnetcore-6.0#mvc-service-registration)\n*   [UseStaticFiles](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles) 扩展方法会添加静态文件处理程序 `Microsoft.AspNetCore.StaticFiles`。 在 `UseRouting` 之前，必须先调用 `UseStaticFiles` 扩展方法。 有关详细信息，请参阅 [ASP.NET Core 中的静态文件](https://docs.microsoft.com/fundamentals/static-files?view=aspnetcore-6.0)。\n*   [UseRouting](https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting) 扩展方法会添加路由。 有关详细信息，请参阅 [ASP.NET Core 中的路由](https://docs.microsoft.com/fundamentals/routing?view=aspnetcore-6.0)。\n\n该现有配置包括迁移 ASP.NET MVC 项目示例迁移所需的信息。 若要详细了解 ASP.NET Core 中间件选项，请参阅 [ASP.NET Core 中的应用启动](https://docs.microsoft.com/fundamentals/startup?view=aspnetcore-6.0)。\n\n迁移控制器和视图\n--------\n\n在 ASP.NET Core 项目中，会使用与要从中迁移的任何 ASP.NET MVC 项目中的控制器和视图类相同的名称添加新的空控制器和视图类来充当占位符。\n\nASP.NET Core WebApp1 项目已包含与 ASP.NET MVC 同名的最小示例控制器和视图。 因此，它们将用作要从 ASP.NET MVC WebApp1 项目迁移的 ASP.NET MVC 控制器和视图的占位符。\n\n1.  复制 ASP.NET MVC `HomeController` 中的方法来替换新的 ASP.NET Core `HomeController` 方法。 无需更改操作方法的返回类型。 ASP.NET MVC 内置模板的控制器操作方法返回类型为 [ActionResult](https://docs.microsoft.com/zh-cn/dotnet/api/system.web.mvc.actionresult)；在 ASP.NET Core MVC 中，操作方法改为返回 `IActionResult`。 `ActionResult` 可实现 `IActionResult`。\n2.  在 ASP.NET Core项目中，右键单击_“视图/Home_”目录，选择“**添加**\\>**现有项**”。\n3.  在 **“添加现有项** ”对话框中，导航到 ASP.NET MVC _WebApp1_ 项目的 _Views/Home_ 目录。\n4.  选择 `About.cshtml`“， `Contact.cshtml`然后 `Index.cshtml`Razor 查看文件，然后选择” **添加**“，替换现有文件。\n\n有关详细信息，请参阅[使用 ASP.NET Core MVC 中的控制器处理请求](https://docs.microsoft.com/mvc/controllers/actions?view=aspnetcore-6.0)和 [ASP.NET Core MVC 中的视图](https://docs.microsoft.com/mvc/views/overview?view=aspnetcore-6.0)。\n\n测试每个方法\n------\n\n可测试每个控制器终结点，不过本文档的稍后部分介绍了布局和样式。\n\n1.  运行 ASP.NET Core 应用。\n2.  通过将当前端口号替换为 ASP.NET Core 项目中使用的端口号，在运行 ASP.NET Core 应用的浏览器中调用呈现的视图。 例如，`https://localhost:44375/home/about`。\n\n迁移静态内容\n------\n\n在 ASP.NET MVC 5 及更早版本中，静态内容是从 Web 项目的根目录承载的，与服务器端文件混合。 在 ASP.NET Core 中，静态文件存储在项目的 [Web 根](https://docs.microsoft.com/fundamentals/?view=aspnetcore-6.0#web-root)目录中。 默认目录是 {content root}/wwwroot，但可更改它。 有关详细信息，请参阅 [ASP.NET Core 中的静态文件](https://docs.microsoft.com/fundamentals/static-files?view=aspnetcore-6.0#serve-static-files)。\n\n将 ASP.NET MVC WebApp1 项目中的静态内容复制到 ASP.NET Core WebApp1 项目中的 wwwroot 目录：\n\n1.  在 ASP.NET Core 项目中，右键单击 wwwroot 目录，然后选择“添加”>“现有项”。\n2.  在“添加现有项”对话框中，导航到 ASP.NET MVC WebApp1 项目。\n3.  选择 favicon.ico 文件，然后选择“添加”来替换现有文件。\n\n迁移布局文件\n------\n\n将 ASP.NET MVC 项目布局文件复制到 ASP.NET Core 项目：\n\n1.  在 ASP.NET Core 项目中，右键单击 Views 目录，然后选择“添加”>“现有项”。\n2.  在“添加现有项”对话框中，导航到 ASP.NET MVC WebApp1 项目的 Views 目录。\n3.  选择 `_ViewStart.cshtml` 该文件，然后选择“ **添加**”。\n\n将 ASP.NET MVC 项目共享布局文件复制到 ASP.NET Core 项目：\n\n1.  在 ASP.NET Core 项目中，右键单击 Views/Shared 目录，然后选择“添加”>“现有项”。\n2.  在“添加现有项”对话框中，导航到 ASP.NET MVC WebApp1 项目的 Views/Shared 目录。\n3.  `_Layout.cshtml`选择该文件，然后选择**“添加”**，替换现有文件。\n\n在 ASP.NET Core项目中，打开`_Layout.cshtml`该文件。 进行以下更改，使其与下述已补全的代码相匹配：\n\n更新 Bootstrap CSS 包含项，使其与下面已补全的代码相匹配：\n\n1.  替换为`@Styles.Render(\"~/Content/css\")``<link>`要加载`bootstrap.css` (的元素，请参阅以下) 。\n2.  删除 `@Scripts.Render(\"~/bundles/modernizr\")`。\n\nBootstrap CSS 包含项已补全的替换标记：\n\n```\n<link rel=\"stylesheet\"\n    href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.css\"\n    integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\"\n    crossorigin=\"anonymous\">\n\n```\n\n更新 jQuery 和 Bootstrap JavaScript 包含项，使其与下面已补全的代码相匹配：\n\n1.  将 `@Scripts.Render(\"~/bundles/jquery\")` 替换为 `<script>` 元素（见下文）。\n2.  将 `@Scripts.Render(\"~/bundles/bootstrap\")` 替换为 `<script>` 元素（见下文）。\n\nJQuery 和 Bootstrap JavaScript 包含项已补全的替换标记：\n\n```\n<script src=\"https://code.jquery.com/jquery-3.3.1.js\"></script>\n<script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.js\"\n    integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n\n```\n\n更新 `_Layout.cshtml` 的文件如下所示：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>@ViewBag.Title - My ASP.NET Application</title>\n    <link rel=\"stylesheet\"\n          href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.css\"\n          integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\"\n          crossorigin=\"anonymous\">\n</head>\n<body>\n    <div class=\"navbar navbar-inverse navbar-fixed-top\">\n        <div class=\"container\">\n            <div class=\"navbar-header\">\n                <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".navbar-collapse\">\n                    <span class=\"icon-bar\"></span>\n                    <span class=\"icon-bar\"></span>\n                    <span class=\"icon-bar\"></span>\n                </button>\n                @Html.ActionLink(\"Application name\", \"Index\", \"Home\", new { area = \"\" }, new { @class = \"navbar-brand\" })\n            </div>\n            <div class=\"navbar-collapse collapse\">\n                <ul class=\"nav navbar-nav\">\n                    <li>@Html.ActionLink(\"Home\", \"Index\", \"Home\")</li>\n                    <li>@Html.ActionLink(\"About\", \"About\", \"Home\")</li>\n                    <li>@Html.ActionLink(\"Contact\", \"Contact\", \"Home\")</li>\n                </ul>\n            </div>\n        </div>\n    </div>\n    <div class=\"container body-content\">\n        @RenderBody()\n        <hr />\n        <footer>\n            <p>&copy; @DateTime.Now.Year - My ASP.NET Application</p>\n        </footer>\n    </div>\n\n    <script src=\"https://code.jquery.com/jquery-3.3.1.js\"></script>\n    <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.js\"\n            integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"></script>\n    @RenderSection(\"scripts\", required: false)\n</body>\n</html>\n\n```\n\n在浏览器中查看站点。 它应采用部署的预期样式进行呈现。\n\n配置捆绑和缩小\n-------\n\nASP.NET Core 与若干开源捆绑和缩小解决方案（例如 [WebOptimizer](https://github.com/ligershark/WebOptimizer) 和其他类似库）兼容。 ASP.NET Core 不提供本机捆绑和缩小解决方案。 若要了解如何配置捆绑和缩小，请参阅[捆绑和缩小](https://docs.microsoft.com/client-side/bundling-and-minification?view=aspnetcore-6.0)。\n\n解决 HTTP 500 错误\n--------------\n\n有许多问题可能会导致 HTTP 500 错误消息，该消息中不包含问题根源的相关信息。 例如，如果 `Views/_ViewImports.cshtml` 文件包含项目中不存在的命名空间，则会生成 HTTP 500 错误。 默认情况下，在 ASP.NET Core应用中，扩展`UseDeveloperExceptionPage`将添加到`IApplicationBuilder`开发环境时并_执行。_ 详见以下代码：\n\n```\npublic class Startup\n{\n    public Startup(IConfiguration configuration)\n    {\n        Configuration = configuration;\n    }\n\n    public IConfiguration Configuration { get; }\n\n    // This method gets called by the runtime. Use this method to add services to the container.\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddControllersWithViews();\n    }\n\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment())\n        {\n            app.UseDeveloperExceptionPage();\n        }\n        else\n        {\n            app.UseExceptionHandler(\"/Home/Error\");\n            // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\n            app.UseHsts();\n        }\n        app.UseHttpsRedirection();\n        app.UseStaticFiles();\n\n        app.UseRouting();\n\n        app.UseAuthorization();\n\n        app.UseEndpoints(endpoints =>\n        {\n            endpoints.MapControllerRoute(\n                name: \"default\",\n                pattern: \"{controller=Home}/{action=Index}/{id?}\");\n        });\n    }\n}\n\n```\n\nASP.NET Core 会将未经处理的异常转换为 HTTP 500 错误响应。 通常，为防止泄露有关服务器的可能敏感信息，这些响应中不包含错误详细信息。 有关详细信息，请参阅[开发人员异常页面](https://docs.microsoft.com/fundamentals/error-handling?view=aspnetcore-6.0#developer-exception-page)。\n\n后续步骤\n----\n\n*   [迁移身份验证并Identity迁移到 ASP.NET Core](https://docs.microsoft.com/identity?view=aspnetcore-6.0)\n\n其他资源\n----\n\n*   [ASP.NET Core](https://docs.microsoft.com/blazor/?view=aspnetcore-6.0)[](https://docs.microsoft.com/blazor/?view=aspnetcore-6.0)\n*   [ASP.NET Core 中的标记帮助程序](https://docs.microsoft.com/mvc/views/tag-helpers/intro?view=aspnetcore-6.0)\n\n[原文链接](https://docs.microsoft.com/zh-cn/aspnet/core/migration/mvc?view=aspnetcore-6.0)', '', 0, 0, 8, 0, 0, 0, 1659597746603, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659597746603, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (39, 0, 7, 2, '.NET 可移植性分析器 .NET Portability Analyzer', '想让库支持多平台吗？ 想要了解使 .NET Framework 应用程序在 .NET Core 上运行需要花费多大的精力？ [.NET 可移植性分析器](https://github.com/microsoft/dotnet-apiport)是一种工具，可分析程序集并为应用程序或库提供有关缺失的 .NET API 的详细报告，以便在指定的目标 .NET 平台上实现可移植性。 可移植性分析器作为 [Visual Studio Extension](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer) 提供，用于分析每个项目的一个程序集；也可以作为 [ApiPort 控制台应用](https://aka.ms/apiportdownload)提供，用于按指定文件或目录分析程序集。\n\n将项目转换为面向 .NET Core 等新平台后，可以使用基于 Roslyn 的[平台兼容性分析器](https://docs.microsoft.com/platform-compat-analyzer)来识别引发 [PlatformNotSupportedException](https://docs.microsoft.com/zh-cn/dotnet/api/system.platformnotsupportedexception) 异常以及其他兼容性问题的 API。\n\n常用对象\n----\n\n*   [.NET Core](https://docs.microsoft.com/core/introduction)：采用模块化设计，支持并行安装，面向跨平台方案。 可并行安装意味着无需破坏其他应用即可采用新的 .NET Core 版本。 如果目标是将应用移植到 .NET Core 以支持多个平台，则建议使用此对象。\n*   .[NET Standard](https://docs.microsoft.com/net-standard)：包括所有 .NET 实现上提供的 .NET Standard API。 如果目标是使自己的库能够在所有 .NET 支持的平台上运行，则建议使用此对象。\n*   [ASP.NET Core](https://docs.microsoft.com/zh-cn/aspnet/core)：在 .NET Core 基础上构建的现代 Web 框架。 如果目标是将 Web 应用移植到 .NET Core 以支持多个平台，则建议使用此对象。\n*   .NET Core + [平台扩展](https://docs.microsoft.com/core/porting/windows-compat-pack)：除 Windows 兼容包之外，还包括 .NET Core API，后者提供了许多可用的 .NET Framework 技术。 这是推荐的对象，用于将 Windows 上的应用从 .NET Framework 移植到 .NET Core。\n*   .NET Standard + [平台扩展](https://docs.microsoft.com/core/porting/windows-compat-pack)：除 Windows 兼容包之外，还包括 .NET Standard API，后者提供了许多可用的 .NET Framework 技术。 这是推荐的对象，用于将 Windows 上的库从 .NET Framework 移植到 .NET Core。\n\n如何使用 .NET 可移植性分析器\n-----------------\n\n若要开始在 Visual Studio 中使用 .NET 可移植性分析器，必须先从 [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer) 下载扩展并进行安装。 它适用于 Visual Studio 2017 和 Visual Studio 2019 版本。\n\n重要\n\nVisual Studio 2022 不支持 .NET 可移植性分析器。\n\n可以通过 Visual Studio 中的“分析”>“可移植性分析器设置”对其进行配置，并选择目标平台，即选择 .NET 平台/版本，用于评估与当前程序集构建的平台/版本相比的可移植性差距。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2b-24cb-39ae-4b85-46264aca82ae_微信截图_20220804163430.png)\n\n还可以使用 ApiPort 控制台应用程序，可从 [ApiPort 存储库](https://aka.ms/apiportdownload)进行下载。 可以使用 `listTargets` 命令选项以显示可用的目标列表，然后通过指定 `-t` 或 `--target` 命令选项来选择目标平台。\n\n### 解决方案范围视图\n\n分析包含多个项目的解决方案的一个很有用的步骤是，可视化依赖项以了解程序集中各个子集的依赖关系。 一般的建议是，从依赖项关系图中的叶节点开始，以自下而上的方式应用分析结果。\n\n要检索此项，可运行以下命令：\n\n```\nApiPort.exe analyze -r DGML -f [directory or file]\n\n```\n\n在 Visual Studio 中打开时，此结果如下所示：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2b-c7a5-d0a2-e9d2-f80a8fd59487_微信截图_20220804163514.png)\n\n### 分析可移植性\n\n若要在 Visual Studio 中分析整个项目，请在“解决方案资源管理器”中右键单击该项目，然后选择“分析程序集可移植性” 。 也可以转到“分析”菜单，选择“分析程序集可移植性”。 在该位置选择项目的可执行文件或 DLL。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2c-373b-e152-7ab7-b0fb701312de_微信截图_20220804163547.png)\n\n还可以使用 [ApiPort 控制台应用](https://aka.ms/apiportdownload)。\n\n键入以下命令即可分析当前目录：\n\n```\nApiPort.exe analyze -f .\n\n```\n\n若要分析特定的 .dll 文件列表，请键入以下命令：\n\n```\nApiPort.exe analyze -f first.dll -f second.dll -f third.dll\n\n```\n\n若要以特定版本为目标，请使用 `-t` 形式参数：\n\n```\nApiPort.exe analyze -t \".NET, Version=5.0\" -f .\n\n```\n\n运行 `ApiPort.exe -?` 以获取更多帮助。\n\n建议包含自己拥有的且要移植的所有相关 exe 和 dll 文件，并且排除应用所依赖的，但你既不拥有又无法移植的文件。 这将为你提供最相关的可移植性报表。\n\n### 查看和解释可移植性结果\n\n报表中仅显示目标平台不支持的 API。 在 Visual Studio 中运行分析后，你将看到弹出的 .NET 可移植性报表文件链接。 如果使用的是 [ApiPort 控制台应用](https://aka.ms/apiportdownload)，.NET 可移植性报表将以指定的格式保存为文件。 默认位于当前目录中的 Excel 文件 (.xlsx) 中。\n\n#### 可移植性摘要\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2c-b324-847f-3f5d-096a9af7c29a_微信截图_20220804163622.png)\n\n报表的“可移植性摘要”部分显示运行中包含的每个程序集的可移植性百分比。 在上述示例中，`svcutil` 应用中使用的 71.24% 的 .NET Framework API 在 .NET Core + Platform Extensions 中可用。 如果针对多个程序集运行 .NET 可移植性分析器工具，则每个程序集在“可移植性摘要”报表中都应有一行。\n\n#### 详细信息\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2d-0ee0-98ff-e239-9b0dfae332f6_微信截图_20220804163646.png)\n\n报表的“详细信息”部分列出了任意选定目标平台缺少的 API。\n\n*   目标类型：该类型具有目标平台缺少的 API\n*   目标成员：目标平台缺少的方法\n*   程序集名称：缺少的 API 所在的 .NET Framework 程序集。\n*   每个选定的目标平台都是一列，例如“.NET Core”：“不支持”值表示此目标平台不支持 API。\n*   建议的更改：要进行更改的推荐 API 或技术。 对于许多 API，此字段当前为空或已过时。 由于 API 数量众多，在维护 API 最新状态方面，我们面临着巨大的挑战。 我们致力于提供备用解决方案，以便为客户提供有用的信息。\n\n#### 缺少程序集\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057a2d-8dc8-04ae-2487-670d352f0a5e_微信截图_20220804163720.png)\n\n可以在报表中找到“缺少程序集”部分。 此部分包含由你的经过分析的程序集引用的程序集列表（此列表未经过分析）。 如果它是你自己拥有的程序集，请将其包含在 API 可移植性分析器运行过程中，以便你可以获得详细的 API 级别可移植性报表。 如果它是第三方库，请检查是否存在支持目标平台的更新版本，并考虑转到较新的版本。 最终，此列表应该包含你的应用依赖的所有第三方程序集（其中具有支持目标平台的版本）。\n\n有关 .NET 可移植性分析器的详细信息，请访问 [GitHub 文档](https://github.com/Microsoft/dotnet-apiport#documentation)。\n\n[原文链接](https://docs.microsoft.com/zh-cn/dotnet/standard/analyzers/portability-analyzer)', '', 0, 0, 4, 0, 0, 0, 1659602302916, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659602302916, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (40, 0, 7, 2, '关于 MD5CryptoServiceProvider 已过时', '.NET Core && .NET 下 MD5CryptoServiceProvider 已过时\n```\nDerived cryptographic types are obsolete. Use the Create method on the base type instead.\n```\n替换为：\n```\nMD5 md5 = MD5.Create();\n```\n> MD5 位于 System.Security.Cryptography 命名空间下', '', 0, 0, 5, 0, 0, 0, 1659667631258, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659667631258, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (41, 0, 7, 2, '.NET 6 使用 log4net 记录日志', '添加依赖包\n```\nlog4net\nMicrosoft.Extensions.Logging.Log4Net.AspNetCore\n```\n\n准备log4net配置文件log4net.config\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<log4net>\n	<!-- Define some output appenders -->\n	<appender name=\"rollingAppender\" type=\"log4net.Appender.RollingFileAppender\">\n		<file value=\"log4\\log.txt\" />\n		<!--追加日志内容-->\n		<appendToFile value=\"true\" />\n		<!--防止多线程时不能写Log,官方说线程非安全-->\n		<lockingModel type=\"log4net.Appender.FileAppender+MinimalLock\" />\n		<!--可以为:Once|Size|Date|Composite-->\n		<!--Composite为Size和Date的组合-->\n		<rollingStyle value=\"Composite\" />\n		<!--当备份文件时,为文件名加的后缀-->\n		<datePattern value=\"yyyyMMdd.TXT\" />\n		<!--日志最大个数,都是最新的-->\n		<!--rollingStyle节点为Size时,只能有value个日志-->\n		<!--rollingStyle节点为Composite时,每天有value个日志-->\n		<maxSizeRollBackups value=\"20\" />\n		<!--可用的单位:KB|MB|GB-->\n		<maximumFileSize value=\"3MB\" />\n		<!--置为true,当前最新日志文件名永远为file节中的名字-->\n		<staticLogFileName value=\"true\" />\n		<!--输出级别在INFO和ERROR之间的日志-->\n		<filter type=\"log4net.Filter.LevelRangeFilter\">\n			<param name=\"LevelMin\" value=\"ALL\" />\n			<param name=\"LevelMax\" value=\"FATAL\" />\n		</filter>\n		<layout type=\"log4net.Layout.PatternLayout\">\n			<conversionPattern value=\"%date [%thread] %-5level %logger - %message%newline\"/>\n		</layout>\n	</appender>\n	<!--SqlServer形式-->\n	<!--下载NuGet包：  System. Data.SqlClient-->\n	<!--log4net日志配置：http://logging.apache.org/log4net/release/config-examples.html -->\n	<appender name=\"AdoNetAppender_SqlServer\" type=\"log4net.Appender.AdoNetAppender\">\n		<!--日志缓存写入条数 设置为0时只要有一条就立刻写到数据库-->\n		<bufferSize value=\"0\" />\n		<connectionType value=\"System.Data.SqlClient.SqlConnection,System.Data.SqlClient, Version=4.6.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a\" />\n		<connectionString value=\"Data Source=DESKTOP-T2D6ILD;Initial Catalog=LogManager;Persist Security Info=True;User ID=sa;Password=sa123\" />\n		<commandText value=\"INSERT INTO Log4Net ([Date],[Thread],[Level],[Logger],[Message],[Exception]) VALUES (@log_date, @thread, @log_level, @logger, @message, @exception)\" />\n		<parameter>\n			<parameterName value=\"@log_date\" />\n			<dbType value=\"DateTime\" />\n			<layout type=\"log4net.Layout.RawTimeStampLayout\" />\n		</parameter>\n		<parameter>\n			<parameterName value=\"@thread\" />\n			<dbType value=\"String\" />\n			<size value=\"255\" />\n			<layout type=\"log4net.Layout.PatternLayout\">\n				<conversionPattern value=\"%thread\" />\n			</layout>\n		</parameter>\n		<parameter>\n			<parameterName value=\"@log_level\" />\n			<dbType value=\"String\" />\n			<size value=\"50\" />\n			<layout type=\"log4net.Layout.PatternLayout\">\n				<conversionPattern value=\"%level\" />\n			</layout>\n		</parameter>\n		<parameter>\n			<parameterName value=\"@logger\" />\n			<dbType value=\"String\" />\n			<size value=\"255\" />\n			<layout type=\"log4net.Layout.PatternLayout\">\n				<conversionPattern value=\"%logger\" />\n			</layout>\n		</parameter>\n		<parameter>\n			<parameterName value=\"@message\" />\n			<dbType value=\"String\" />\n			<size value=\"4000\" />\n			<layout type=\"log4net.Layout.PatternLayout\">\n				<conversionPattern value=\"%message\" />\n			</layout>\n		</parameter>\n		<parameter>\n			<parameterName value=\"@exception\" />\n			<dbType value=\"String\" />\n			<size value=\"2000\" />\n			<layout type=\"log4net.Layout.ExceptionLayout\" />\n		</parameter>\n	</appender>\n	<root>\n		<!--控制级别，由低到高: ALL|DEBUG|INFO|WARN|ERROR|FATAL|OFF-->\n		<!--OFF:0-->\n		<!--FATAL:FATAL-->\n		<!--ERROR: ERROR,FATAL-->\n		<!--WARN: WARN,ERROR,FATAL-->\n		<!--INFO: INFO,WARN,ERROR,FATAL-->\n		<!--DEBUG: INFO,WARN,ERROR,FATAL-->\n		<!--ALL: DEBUG,INFO,WARN,ERROR,FATAL-->\n		<priority value=\"ALL\"/>\n		<level value=\"INFO\"/>\n		<appender-ref ref=\"rollingAppender\" />\n		<!--<appender-ref ref=\"AdoNetAppender_SqlServer\" />-->\n	</root>\n</log4net>\n```\n> 修改文件属性\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057e2c-5fd9-b48f-a85b-7a0016e7eef7_微信截图_20220805111434.png)\n\n修改 Program.cs 文件\n```\nbuilder.Logging.AddLog4Net(\"log4net.config\");\n```\n\n记录日志效果\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a057e2e-4131-dcd4-16ea-062ff316ae45_微信截图_20220805111637.png)\n', '', 0, 0, 9, 0, 1, 0, 1659669431956, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659669431956, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (42, 0, 7, 2, 'WebRequest、WebClient 和 ServicePoint 已过时', '[WebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webrequest)、[WebClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webclient) 与 [ServicePoint](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepoint) 类别标记为已过时并生成编译时 `SYSLIB0014` 警告。\n\n引入的版本\n-----\n\n6.0\n\n更改说明\n----\n\n为实现后向兼容性，[WebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webrequest)、[WebClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webclient)与 [ServicePoint](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepoint) 类别已添加到 2.0 版 .NET Core。 不过，它们引入了多个运行时中断性变更，例如，`WebRequest.GetRequestStream` 为整个响应分配内存，并且 `WebClient.CancelAsync` 不会立即取消。\n\n从 .NET 6 开始，[WebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webrequest)、[WebClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webclient) 与 [ServicePoint](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepoint) 类别已弃用。 这些类别仍可用，但不建议用于新的开发。 若要减少分析器警告的数量，仅用 [ObsoleteAttribute](https://docs.microsoft.com/zh-cn/dotnet/api/system.obsoleteattribute) 属性修饰构造方法。\n\n建议的操作\n-----\n\n请改用 [System.Net.Http.HttpClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.http.httpclient) 类。\n\n对于 FTP，由于 [HttpClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.http.httpclient) 不支持它，因此建议使用第三方库。\n\n受影响的 API\n--------\n\n*   [WebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webrequest)\n*   [HttpWebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.httpwebrequest)\n*   [FtpWebRequest](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.ftpwebrequest)\n*   [WebClient](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.webclient)\n*   [ServicePoint](https://docs.microsoft.com/zh-cn/dotnet/api/system.net.servicepoint)\n\n[原文地址](https://docs.microsoft.com/zh-cn/dotnet/core/compatibility/networking/6.0/webrequest-deprecated)', '', 0, 0, 6, 0, 0, 0, 1659678181650, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659678181650, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (43, 0, 5, 11, 'SQL中instr和like的使用区别', '1、instr函数\n\n instr函数是一个字符串处理函数，它在Oracle/PLSQL中是返回子字符串在源字符串中的位置，如果在源串中没有找到子串，则返回0。\n\ninstr函数定义如下：\n\n``` \n /*  \n * 返回子字符串在源字符串中的位置(字符串位置从1开始，而不是从0开始)  \n * @param str 源字符串  \n * @param substr 子字符串  \n * @param position 检索位置，可省略(默认为1),参数为正时，从左向右检索，参数为负时，从右向左检索  \n * @param occurrence 检索子串出现次数(即子串在源串第几次出现)，可省略(默认为1),值只能为正整数，否则会报错  \n * @return 返回子字符串在源字符串中出现的位置（没找到返回0）  \n */  \ninstr(str, substr, position, occurrence); \n```\n例如：\n```\nSELECT INSTR(\'hello world\', \'l\') FROM DUAL;        --结果：3  \nSELECT INSTR(\'hello world\', \'l\', 5) FROM DUAL;     --结果：10 (从左向右第5位开始检索\'l\'在\'hello world\'中出现的位置) \nSELECT INSTR(\'hello world\', \'l\', -1) FROM DUAL;    --结果：10 (从右向左第1位开始检索\'l\'在\'hello world\'中出现的位置) \nSELECT INSTR(\'hello world\', \'l\', 2, 2) FROM DUAL;  --结果：4  (从左向右第2位开始检索\'l\'在\'hello world\'中第2次出现的位置) \nSELECT INSTR(\'hello world\', \'l\', -3, 3) FROM DUAL; --结果：0  (从右向左第3位开始检索\'l\'在\'hello world\'中第3次出现的位置)\n```\n\n2、like关键字\n like关键字也可称为通配符，在SQL中用于模糊查询。可以使用“%”和“_”通配符，其中“%”代表0个或多个字符，“_”代表1个字符。\n例如：\n\n``` \nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'%张%\'; --在STUDENTTAB表中查询STUNAME中含有字符“张”的学员\nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'张_\';  --在STUDENTTAB表中查询STUNAME中以“张”开头，名字长度为2的学员(即“张三”、“张四”，而不会检测出“张三三”)\n``` \n\n3、instr和like的使用：\n```\nSELECT * FROM STUDENTTAB WHERE STUNAME LIKE \'%张%\';\n就相当于 \nSELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, \'张\') > 0;\n \nSELECT * FROM STUDENTTAB WHERE STUNAME NOT LIKE \'%张%\';\n就相当于 \nSELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, \'张\') = 0;\n```\n\n4、总结\n<1> instr>0 和like、instr=0 和not like 一般来说查询的结果相同(不考虑特殊字符)\n<2> instr是一个函数，可以建立函数索引，如果过滤的条件有索引，那么instr就可以提高性能。\n<3> like查询时，以\'%\'开头，列所加的索引是不起作用的。\n<4> 在没有索引的前提下，当数据量比较大时，instr要比like效率高。 \n', '', 0, 0, 38, 0, 2, 0, 1659681073641, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1659681073641, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (44, 0, 8, 9, '部署vue 接口代理和刷新404问题', '1.前端访问后台接口代理问题\n本地vue代码一般都会配置代理，列如访问接口 \n浏览器里面看到的是这个\nhttp://localhost:6001/api/sys/user/getpage\n实际访问的是这个\nhttp://localhost:6002/api/sys/user/getpage\n``` \n  proxy: {\n        \"/api\": {\n         target: `http://localhost:6002`, // 代理地址，这里设置的地址会代替axios中设置的baseURL\n          changeOrigin: true, // 如果接口跨域，需要进行这个参数配置       \n          pathRewrite: {\n            \"^/api\": \"/api\"\n          }\n        }\n      }\n```\n项目发布到之后，需要在配置文件里面加上这个\n``` \n    location  /api {\n        proxy_pass   http://192.168.1.83:6006;\n    }\n```\n\n2.页面刷新404问题\n添加配置\n``` \n   location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n        try_files $uri $uri/ /index.html;    --添加这个配置\n    }\n\n```\n\n\n\n\n', '', 0, 0, 25, 0, 0, 0, 1659681626195, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77', '::ffff:172.17.0.1', 1659681626195, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (45, 0, 7, 2, '.NET 中的数字', '.NET 提供了一系列数值整数和浮点基元，还提供：\n\n*   [System.Half](https://docs.microsoft.com/zh-cn/dotnet/api/system.half)，表示半精度浮点数。\n*   [System.Decimal](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal)，表示十进制浮点数。\n*   [System.Numerics.BigInteger](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger)，它表示没有理论上的上限或下限的整型类型。\n*   [System.Numerics.Complex](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.complex)，它表示复数。\n*   [System.Numerics](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics) 命名空间中一组启用了 SIMD 的类型。\n\n整数类型\n----\n\n.NET 支持带符号和无符号的 8 位、16 位、32 位和 64 位整数类型，如下表所示。\n\n**带符号整数类型**\n\n| 类型 | 大小（以字节为单位） | 最小值 | 最大值 |\n| --- | --- | --- | --- |\n| [System.Int16](https://docs.microsoft.com/zh-cn/dotnet/api/system.int16) | 2 | \\-32,768 | 32,767 |\n| [System.Int32](https://docs.microsoft.com/zh-cn/dotnet/api/system.int32) | 4 | \\-2,147,483,648 | 2,147,483,647 |\n| [System.Int64](https://docs.microsoft.com/zh-cn/dotnet/api/system.int64) | 8 | \\-9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |\n| [System.SByte](https://docs.microsoft.com/zh-cn/dotnet/api/system.sbyte) | 1 | \\-128 | 127 |\n| [System.IntPtr](https://docs.microsoft.com/zh-cn/dotnet/api/system.intptr)（32 位进程中） | 4 | \\-2,147,483,647 | 2,147,483,647 |\n| [System.IntPtr](https://docs.microsoft.com/zh-cn/dotnet/api/system.intptr)（64 位进程中） | 8 | \\-9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |\n\n**无符号整数类型**\n\n| 类型 | 大小（以字节为单位） | 最小值 | 最大值 |\n| --- | --- | --- | --- |\n| [System.Byte](https://docs.microsoft.com/zh-cn/dotnet/api/system.byte) | 1 | 0 | 255 |\n| [System.UInt16](https://docs.microsoft.com/zh-cn/dotnet/api/system.uint16) | 2 | 0 | 65,535 |\n| [System.UInt32](https://docs.microsoft.com/zh-cn/dotnet/api/system.uint32) | 4 | 0 | 4,294,967,295 |\n| [System.UInt64](https://docs.microsoft.com/zh-cn/dotnet/api/system.uint64) | 8 | 0 | 18,446,744,073,709,551,615 |\n| [System.UIntPtr](https://docs.microsoft.com/zh-cn/dotnet/api/system.uintptr)（32 位进程中） | 4 | 0 | 4,294,967,295 |\n| [System.UIntPtr](https://docs.microsoft.com/zh-cn/dotnet/api/system.uintptr)（64 位进程中） | 8 | 0 | 18,446,744,073,709,551,615 |\n\n每个整数类型都支持一组标准算术运算符。 [System.Math](https://docs.microsoft.com/zh-cn/dotnet/api/system.math) 类为更广泛的数学函数集提供方法。\n\n还可以使用 [System.BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter) 类对整数值中的单个位进行运算。\n\n注意\n\n无符号整数类型不符合 CLS。 有关详细信息，请参阅[语言独立性和与语言无关的组件](https://docs.microsoft.com/language-independence)。\n\nBigInteger\n----------\n\n[System.Numerics.BigInteger](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger) 结构是不可变类型，表示其值没有理论上限或下限的任意大型整数。 [BigInteger](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger) 类型的方法几乎与其他整数类型的方法一致。\n\n浮点类型\n----\n\n.NET 包含以下浮点类型：\n\n| 类型 | 大小（以字节为单位） | 大致范围 | 基元？ | 说明 |\n| --- | --- | --- | --- | --- |\n| [System.Half](https://docs.microsoft.com/zh-cn/dotnet/api/system.half) | 2 | ±65504 | 否 | 已在 .NET 5 中引入 |\n| [System.Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) | 4 | ±3.4 x 1038 | 是 |  |\n| [System.Double](https://docs.microsoft.com/zh-cn/dotnet/api/system.double) | 8 | ±1.7 × 10308 | 是 |  |\n| [System.Decimal](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal) | 16 | ±7.9228 x 1028 | 否 |  |\n\n[Half](https://docs.microsoft.com/zh-cn/dotnet/api/system.half)、[Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) 和 [Double](https://docs.microsoft.com/zh-cn/dotnet/api/system.double) 类型都支持表示非数字和无穷大的特殊值。 例如，[Double](https://docs.microsoft.com/zh-cn/dotnet/api/system.double) 类型提供以下值：[Double.NaN](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.nan)、[Double.NegativeInfinity](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.negativeinfinity) 和 [Double.PositiveInfinity](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.positiveinfinity)。 可以使用 [Double.IsNaN](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.isnan)、[Double.IsInfinity](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.isinfinity)、[Double.IsPositiveInfinity](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.ispositiveinfinity) 和 [Double.IsNegativeInfinity](https://docs.microsoft.com/zh-cn/dotnet/api/system.double.isnegativeinfinity) 方法来测试这些特殊值。\n\n每个浮点类型都支持一组标准的算术运算符。 [System.Math](https://docs.microsoft.com/zh-cn/dotnet/api/system.math) 类为更广泛的数学函数集提供方法。 .NET Core 2.0 及更高版本包含 [System.MathF](https://docs.microsoft.com/zh-cn/dotnet/api/system.mathf) 类，该类提供接受 [Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) 类型的参数的方法。\n\n还可以使用 [System.BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter) 类对 [Double](https://docs.microsoft.com/zh-cn/dotnet/api/system.double)、[Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) 和 [Half](https://docs.microsoft.com/zh-cn/dotnet/api/system.half) 值中的单个位进行运算。 [System.Decimal](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal) 结构具有自己处理十进制值单个位的方法（[Decimal.GetBits](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal.getbits) 和 [Decimal(Int32\\[\\])](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal.-ctor#system-decimal-ctor(system-int32()))）以及一套执行其他数学运算的方法。\n\n[Double](https://docs.microsoft.com/zh-cn/dotnet/api/system.double)、[Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) 和 [Half](https://docs.microsoft.com/zh-cn/dotnet/api/system.half) 类型旨在用于本质上不精确的值（例如两颗行星之间的距离）和无需高度精确和舍入误差小的应用程序。 在需要较高准确度和尽量减小舍入误差的情况下，使用 [System.Decimal](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal) 类型。\n\n注意\n\n[Decimal](https://docs.microsoft.com/zh-cn/dotnet/api/system.decimal) 类型不会消除对舍入的要求。 相反，它最大限度地减少了因舍入而导致的错误。\n\nComplex\n-------\n\n[System.Numerics.Complex](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.complex) 结构表示复数，即带实数部分和虚数部分的数字。 此类型支持一套标准的算术、比较、相等、显式和隐式转换运算符，以及数学、代数和三角方法。\n\n启用了 SIMD 的类型\n------------\n\n[System.Numerics](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics) 命名空间包含一组启用了 .NET SIMD 的类型。 SIMD (Single Instruction Multiple Data) 操作可以在硬件级别并行化。 这可以增加向量化计算的吞吐量，这在数学、科学和图形应用中很常见。\n\n启用了 .NET SIMD 的类型如下：\n\n*   [Vector2](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector2)、[Vector3](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector3) 和 [Vector4](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector4) 类型，用于表示具有 2、3 和 4 [Single](https://docs.microsoft.com/zh-cn/dotnet/api/system.single) 值的向量。\n    \n*   两个矩阵类型：[Matrix3x2](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.matrix3x2)（表示 3x2 矩阵）和 [Matrix4x4](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.matrix4x4)（表示 4x4 矩阵）。\n    \n*   [Plane](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.plane) 类型，表示三维空间中的一个平面。\n    \n*   [Quaternion](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.quaternion) 类型，表示一个用于对三维物理旋转进行编码的向量。\n    \n*   [Vector<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector-1) 类型，表示指定数字类型的向量，并提供受益于 SIMD 支持的一组广泛的运算符。 [Vector<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector-1) 实例的计数是固定的，但其值 [Vector<T>.Count](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector-1.count) 取决于执行代码的计算机的 CPU。\n    \n    注意\n    \n    [Vector<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.vector-1) 类型随 .NET Core 和 .NET 5+ 一起提供，但 .NET Framework 中不提供。 如果你使用的是 .NET Framework，请安装 [System.Numerics.Vectors](https://www.nuget.org/packages/System.Numerics.Vectors) NuGet 包来访问此类型。\n    \n\n启用了 SIMD 的类型以这样一种方式实现：即它们可以与未启用 SIMD 的硬件或 JIT 编译器一起使用。 要利用 SIMD 指令，你的 64 位应用必须由使用 RyuJIT 编译器的运行时运行，该编译器包含在 .NET Core 和 .NET Framework 4.6 及更高版本中。 它针对 64 位处理器增加了 SIMD 支持。\n\n有关详细信息，请参阅[使用 SIMD 加速数值类型](https://docs.microsoft.com/simd)。\n\n另请参阅\n----\n\n*   [标准数字格式字符串](https://docs.microsoft.com/base-types/standard-numeric-format-strings)\n*   [浮点数值类型 (C#)](https://docs.microsoft.com/csharp/language-reference/builtin-types/floating-point-numeric-types)\n', '', 0, 0, 2, 0, 0, 0, 1660015567131, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 1660015567131, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (46, 0, 7, 2, '! （null 包容）运算符（C# 参考）', '在 C# 8.0 及更高版本中可用，一元后缀 `!` 运算符是 null 包容运算符或 null 抑制运算符。 在已启用的[可为空的注释上下文](https://docs.microsoft.com/nullable-references#nullable-contexts)中，可以使用 null 包容运算符来声明可为空的引用类型的表达式 `x` 不为 `null`：`x!`。 一元前缀 `!` 运算符是[逻辑非运算符](https://docs.microsoft.com/boolean-logical-operators#logical-negation-operator-)。\n\nnull 包容运算符在运行时不起作用。 它仅通过更改表达式的 null 状态来影响编译器的静态流分析。 在运行时，表达式 `x!` 的计算结果为基础表达式 `x` 的结果。\n\n有关可为空引用类型特性的详细信息，请参见[可为空引用类型](https://docs.microsoft.com/builtin-types/nullable-reference-types)。\n\n示例\n--\n\nnull 包容运算符的一个用例是测试参数验证逻辑。 例如，请考虑以下类：\n\n```\n#nullable enable\npublic class Person\n{\n    public Person(string name) => Name = name ?? throw new ArgumentNullException(nameof(name));\n\n    public string Name { get; }\n}\n\n```\n\n使用 [测试框架](https://docs.microsoft.com/core/testing/unit-testing-with-mstest)，可以在构造函数中为验证逻辑创建以下测试：\n\n```\n[TestMethod, ExpectedException(typeof(ArgumentNullException))]\npublic void NullNameShouldThrowTest()\n{\n    var person = new Person(null!);\n}\n\n```\n\n如果不使用 null 包容运算符，编译器将为前面的代码生成以下警告：`Warning CS8625: Cannot convert null literal to non-nullable reference type`。 通过使用 null 包容运算符，可以告知编译器传递 `null` 是预期行为，不应发出警告。\n\n如果你明确知道某个表达式不能为 `null`，但编译器无法识别它，也可以使用 null 包容运算符。 在下面的示例中，如果 `IsValid` 方法返回 `true`，则其参数不是 `null`，可以放心取消对它的引用：\n\n```\npublic static void Main()\n{\n    Person? p = Find(\"John\");\n    if (IsValid(p))\n    {\n        Console.WriteLine($\"Found {p!.Name}\");\n    }\n}\n\npublic static bool IsValid(Person? person)\n    => person is not null && person.Name is not null;\n\n```\n\n如果没有 null 包容运算符，编译器将为 `p.Name` 代码生成以下警告：`Warning CS8602: Dereference of a possibly null reference`。\n\n如果可以修改 `IsValid` 方法，则可使用 [NotNullWhen](https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.codeanalysis.notnullwhenattribute) 属性告知编译器，当方法返回 `true` 时，`IsValid` 方法的参数不能是 `null`：\n\n```\npublic static void Main()\n{\n    Person? p = Find(\"John\");\n    if (IsValid(p))\n    {\n        Console.WriteLine($\"Found {p.Name}\");\n    }\n}\n\npublic static bool IsValid([NotNullWhen(true)] Person? person)\n    => person is not null && person.Name is not null;\n\n```\n\n在前面的例子中，不需要使用 null 包容运算符，因为编译器有足够的信息来发现 `p` 不能是 `if` 语句中的 `null`。 如需深入了解允许你提供有关变量 null 状态的其他信息的属性，请参阅[使用属性升级 API 以定义 null 期望值](https://docs.microsoft.com/attributes/nullable-analysis)。\n\nC# 语言规范\n-------\n\n有关详细信息，请参阅[可为空的引用类型规范草案](https://docs.microsoft.com/proposals/csharp-9.0/nullable-reference-types-specification)的 [null 包容性运算符](https://docs.microsoft.com/proposals/csharp-9.0/nullable-reference-types-specification#the-null-forgiving-operator)部分。\n\n请参阅\n---\n\n*   [删除不必要的抑制运算符（样式规则 IDE0080）](https://docs.microsoft.com/fundamentals/code-analysis/style-rules/ide0080)\n*   [C# 参考](https://docs.microsoft.com/)\n*   [C# 运算符和表达式](https://docs.microsoft.com/)\n*   [教程：使用可为空引用类型进行设计](https://docs.microsoft.com/whats-new/tutorials/nullable-reference-types)\n', '', 0, 0, 5, 0, 0, 0, 1660186198427, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 1660186198427, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (47, 0, 1, 11, 'KETTLE工具使用（第一章节）（给个一键三连不过分吧）', '# 首先要知道ETL是什么？\nETL，来描述将数据从来源端经过抽取（extract）、转换（transform）、加载（load）至目的端的过程\n\n\n# 怎么使用ETL工具？\nKettle\n\n------------------------------------\n\n# 怎么使用kettle？\n安装JDK,按默认值安装即可\njdk:jdk-8u152-windows--x64\nkettle:KETTLE-5.4\n\n------------------------------------\n\n## Kettle程序打开,如下图：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059deb-230b-025b-c53f-b9dca6bfda61_image.png)\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059deb-32f9-4e40-0d1a-be7c65c4f0e4_image.png)\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059deb-4041-ea05-f504-71e2705fd6f1_image.png)\n\n------------------------------------\n\n## 现在开始配置一个简单的get请求（***点赞过10个，加更Post请求***），并将接口返回的数据插入表中，流程如下：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059deb-c4a8-b3bb-4cc8-6396dcf1d903_image.png)\n\n------------------------------------\n\n## 步骤拆解：\n### 1、配置数据源\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-2b34-5d69-20e0-ce1f4b99abd8_image.png)\n\n### 2、配置接口url（通过自定义常量数据模块）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-566f-ba46-bc48-bffba10d3936_image.png)\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-6ed9-0f8f-4a92-a1ebf7ef387d_image.png)\n\n### 3、获取开始时间和结束时间（通过js代码模块编写js方法获得）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-8dc0-bd33-7bfa-fa51b0e82482_image.png)\n\n### 4、拼接url地址（通过前面配置的参数，使用字段拼接工具模块）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-ccf3-b655-ccde-5f46b9ce30e0_image.png)\n\n### 5、请求接口（通过http rest模块配置）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dec-f1ca-e52f-a0d8-364c2a30c56b_image.png)\n\n### 6、获取返回值（使用json输入模块）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059ded-15d7-1d13-c754-d05f4ff02c6a_image.png)\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059ded-26ae-6505-ef3a-f997c60f4203_image.png)\n\n### 7、获取序列（序列模块）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059ded-4e43-b5bd-9c7e-553ca57a8dfe_image.png)\n\n### 8、插入更新（使用插入更新模块）\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059ded-9fd7-a509-40e1-0663a9e2d548_image.png)\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059ded-af41-7d9b-dc92-932d6402c741_image.png)\n\n### 9、运行\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dee-47b1-fd64-e9dc-b4bcb3eef51d_image.png)\n\n### 10、步骤用时\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a059dee-f700-5325-2dc3-c1139f4edd2f_image.png)', '', 1, 1660203147900, 56, 5, 4, 0, 1660209184585, 10, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1660202178004, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (48, 0, 7, 2, '如何将字节数组转换为 int（C# 编程指南）', '此示例演示如何使用 [BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter) 类将字节数组转换为 [int](https://docs.microsoft.com/language-reference/builtin-types/integral-numeric-types) 然后又转换回字节数组。 例如，在从网络读取字节之后，可能需要将字节转换为内置数据类型。 除了示例中的 [ToInt32(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint32#system-bitconverter-toint32(system-byte()-system-int32)) 方法之外，下表还列出了 [BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter) 类中将字节（来自字节数组）转换为其他内置类型的方法。\n\n| 返回类型 | 方法 |\n| --- | --- |\n| `bool` | [ToBoolean(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toboolean#system-bitconverter-toboolean(system-byte()-system-int32)) |\n| `char` | [ToChar(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.tochar#system-bitconverter-tochar(system-byte()-system-int32)) |\n| `double` | [ToDouble(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.todouble#system-bitconverter-todouble(system-byte()-system-int32)) |\n| `short` | [ToInt16(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint16#system-bitconverter-toint16(system-byte()-system-int32)) |\n| `int` | [ToInt32(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint32#system-bitconverter-toint32(system-byte()-system-int32)) |\n| `long` | [ToInt64(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint64#system-bitconverter-toint64(system-byte()-system-int32)) |\n| `float` | [ToSingle(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.tosingle#system-bitconverter-tosingle(system-byte()-system-int32)) |\n| `ushort` | [ToUInt16(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.touint16#system-bitconverter-touint16(system-byte()-system-int32)) |\n| `uint` | [ToUInt32(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.touint32#system-bitconverter-touint32(system-byte()-system-int32)) |\n| `ulong` | [ToUInt64(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.touint64#system-bitconverter-touint64(system-byte()-system-int32)) |\n\n示例\n--\n\n此示例初始化字节数组，并在计算机体系结构为 little-endian（即首先存储最低有效字节）的情况下反转数组，然后调用 [ToInt32(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint32#system-bitconverter-toint32(system-byte()-system-int32)) 方法以将数组中的四个字节转换为 `int`。 [ToInt32(Byte\\[\\], Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.toint32#system-bitconverter-toint32(system-byte()-system-int32)) 的第二个参数指定字节数组的起始索引。\n\n注意\n\n输出可能会根据计算机体系结构的字节顺序而不同。\n\n```\nbyte[] bytes = { 0, 0, 0, 25 };\n\n// If the system architecture is little-endian (that is, little end first),\n// reverse the byte array.\nif (BitConverter.IsLittleEndian)\n    Array.Reverse(bytes);\n\nint i = BitConverter.ToInt32(bytes, 0);\nConsole.WriteLine(\"int: {0}\", i);\n// Output: int: 25\n\n```\n\n在本示例中，将调用 [BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter) 类的 [GetBytes(Int32)](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.getbytes#system-bitconverter-getbytes(system-int32)) 方法，将 `int` 转换为字节数组。\n\n注意\n\n输出可能会根据计算机体系结构的字节顺序而不同。\n\n```\nbyte[] bytes = BitConverter.GetBytes(201805978);\nConsole.WriteLine(\"byte array: \" + BitConverter.ToString(bytes));\n// Output: byte array: 9A-50-07-0C\n\n```\n\n请参阅\n---\n\n*   [BitConverter](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter)\n*   [IsLittleEndian](https://docs.microsoft.com/zh-cn/dotnet/api/system.bitconverter.islittleendian)\n*   [类型](https://docs.microsoft.com/fundamentals/types/)', '', 0, 0, 4, 0, 0, 0, 1660272251469, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 1660272251469, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (49, 0, 11, 11, '果园港国家物流枢纽智慧多式联运信息服务平台--大屏', '##### **效果预览地址：**\n###### 开发环境：http://db.winjoinit.com:49968\n###### 正式环境：http://119.84.240.38:10007\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36b-9dba-91c1-23a0-207847cf6050_果园港-物流全程跟踪3.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36b-e524-47ce-3aff-9b2e878a6ad7_果园港-铁路2.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36c-2a98-4b40-6408-aac0307271b3_果园港-港口.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36c-570f-b031-f2f9-a3ababe8aca7_果园港-港口-港区图.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36c-9b56-e111-499a-144ad1a86414_果园港-仓库.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36c-c985-87ca-1e52-21cd54904e8a_果园港-车队.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-0050-b4bd-9d46-27d350601486_果园港-堆场.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-763c-71d1-458f-7cb4d13ee4d4_果园港-进出口贸易.png)\n------------------------------------\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-a63b-1320-ff83-8c0166e0de4a_物流企业看板.png)', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-d77f-7e43-6161-bae9d036058e_果园港-仓库.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-d77f-7e43-6161-bae9d036058e_果园港-仓库.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-e2d6-8160-05c8-b5d4969cb65a_果园港-车队.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-e2d6-8160-05c8-b5d4969cb65a_果园港-车队.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-f01b-a907-89aa-325bf3700886_果园港-堆场.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-f01b-a907-89aa-325bf3700886_果园港-堆场.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-eeea-f4d5-65a9-7bf54d17d398_果园港-港口.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-eeea-f4d5-65a9-7bf54d17d398_果园港-港口.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-e39f-4546-da33-c51ab514d664_果园港-港口-港区图.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-e39f-4546-da33-c51ab514d664_果园港-港口-港区图.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36e-0116-daf3-9b1e-c098fc08d3ab_果园港-进出口贸易.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36e-0116-daf3-9b1e-c098fc08d3ab_果园港-进出口贸易.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-e629-2474-76c8-7697bc0f8a79_果园港-铁路2.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-e629-2474-76c8-7697bc0f8a79_果园港-铁路2.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36d-fefd-de1b-6cfb-fc776f3f5fc9_果园港-物流全程跟踪3.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36d-fefd-de1b-6cfb-fc776f3f5fc9_果园港-物流全程跟踪3.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a05a36e-06c0-8fcc-cb07-7a3454bc56da_物流企业看板.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a36e-06c0-8fcc-cb07-7a3454bc56da_物流企业看板.png\"}]', 0, 0, 41, 0, 3, 0, 1660294367367, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1660294367367, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (50, 0, 7, 2, '集合 (C#)', '对于许多应用程序，你会想要创建和管理相关对象的组。 有两种方法对对象进行分组：通过创建对象的数组，以及通过创建对象的集合。\n\n数组最适用于创建和使用固定数量的强类型化对象。 有关数组的信息，请参阅[数组](https://docs.microsoft.com/arrays/)。\n\n集合提供更灵活的方式来使用对象组。 与数组不同，你使用的对象组随着应用程序更改的需要动态地放大和缩小。 对于某些集合，你可以为放入集合中的任何对象分配一个密钥，这样你便可以使用该密钥快速检索此对象。\n\n集合是一个类，因此必须在向该集合添加元素之前，声明类的实例。\n\n如果集合中只包含一种数据类型的元素，则可以使用 [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间中的一个类。 泛型集合强制类型安全，因此无法向其添加任何其他数据类型。 当你从泛型集合检索元素时，你无需确定其数据类型或对其进行转换。\n\n注意\n\n在本主题的示例中，针对 `System.Collections.Generic` 和 `System.Linq` 命名空间包括 [using](https://docs.microsoft.com/language-reference/keywords/using-directive) 指令。\n\n**在本主题中**\n\n*   [使用简单集合](about:blank#BKMK_SimpleCollection)\n    \n*   [集合的类型](about:blank#BKMK_KindsOfCollections)\n    \n    *   [System.Collections.Generic 类](about:blank#BKMK_Generic)\n        \n    *   [System.Collections.Concurrent 类](about:blank#BKMK_Concurrent)\n        \n    *   [System.Collections 类](about:blank#BKMK_Collections)\n        \n*   [实现键/值对集合](about:blank#BKMK_KeyValuePairs)\n    \n*   [使用 LINQ 访问集合](about:blank#BKMK_LINQ)\n    \n*   [对集合排序](about:blank#BKMK_Sorting)\n    \n*   [定义自定义集合](about:blank#BKMK_CustomCollection)\n    \n*   [迭代器](about:blank#BKMK_Iterators)\n    \n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n使用简单集合\n------\n\n本部分中的示例使用泛型 [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 类，通过此类可使用对象的强类型列表。\n\n以下示例创建字符串列表，并通过使用 [foreach](https://docs.microsoft.com/language-reference/statements/iteration-statements#the-foreach-statement) 语句循环访问字符串。\n\n```\n// Create a list of strings.\nvar salmons = new List<string>();\nsalmons.Add(\"chinook\");\nsalmons.Add(\"coho\");\nsalmons.Add(\"pink\");\nsalmons.Add(\"sockeye\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n\n```\n\n如果集合中的内容是事先已知的，则可以使用集合初始值设定项来初始化集合。 有关详细信息，请参阅[对象和集合初始值设定项](https://docs.microsoft.com/classes-and-structs/object-and-collection-initializers)。\n\n以下示例与上一示例相同，除了有一个集合初始值设定项用于将元素添加到集合。\n\n```\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook coho pink sockeye\n\n```\n\n可以使用 [for](https://docs.microsoft.com/language-reference/statements/iteration-statements#the-for-statement) 语句，而不是 `foreach` 语句来循环访问集合。 通过按索引位置访问集合元素实现此目的。 元素的索引开始于 0，结束于元素计数减 1。\n\n以下示例通过使用 `for` 而不是 `foreach` 循环访问集合中的元素。\n\n```\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\nfor (var index = 0; index < salmons.Count; index++)\n{\n    Console.Write(salmons[index] + \" \");\n}\n// Output: chinook coho pink sockeye\n\n```\n\n以下示例通过指定要删除的对象，从集合中删除一个元素。\n\n```\n// Create a list of strings by using a\n// collection initializer.\nvar salmons = new List<string> { \"chinook\", \"coho\", \"pink\", \"sockeye\" };\n\n// Remove an element from the list by specifying\n// the object.\nsalmons.Remove(\"coho\");\n\n// Iterate through the list.\nforeach (var salmon in salmons)\n{\n    Console.Write(salmon + \" \");\n}\n// Output: chinook pink sockeye\n\n```\n\n以下示例从一个泛型列表中删除元素。 使用以降序进行循环访问的 `for` 语句，而非 `foreach` 语句。 这是因为 [RemoveAt](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.removeat) 方法将导致已移除的元素后的元素的索引值减小。\n\n```\nvar numbers = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n// Remove odd numbers.\nfor (var index = numbers.Count - 1; index >= 0; index--)\n{\n    if (numbers[index] % 2 == 1)\n    {\n        // Remove the element by specifying\n        // the zero-based index in the list.\n        numbers.RemoveAt(index);\n    }\n}\n\n// Iterate through the list.\n// A lambda expression is placed in the ForEach method\n// of the List(T) object.\nnumbers.ForEach(\n    number => Console.Write(number + \" \"));\n// Output: 0 2 4 6 8\n\n```\n\n对于 [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 中的元素类型，还可以定义自己的类。 在下面的示例中，由 [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 使用的 `Galaxy` 类在代码中定义。\n\n```\nprivate static void IterateThroughList()\n{\n    var theGalaxies = new List<Galaxy>\n        {\n            new Galaxy() { Name=\"Tadpole\", MegaLightYears=400},\n            new Galaxy() { Name=\"Pinwheel\", MegaLightYears=25},\n            new Galaxy() { Name=\"Milky Way\", MegaLightYears=0},\n            new Galaxy() { Name=\"Andromeda\", MegaLightYears=3}\n        };\n\n    foreach (Galaxy theGalaxy in theGalaxies)\n    {\n        Console.WriteLine(theGalaxy.Name + \"  \" + theGalaxy.MegaLightYears);\n    }\n\n    // Output:\n    //  Tadpole  400\n    //  Pinwheel  25\n    //  Milky Way  0\n    //  Andromeda  3\n}\n\npublic class Galaxy\n{\n    public string Name { get; set; }\n    public int MegaLightYears { get; set; }\n}\n\n```\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n集合的类型\n-----\n\n许多通用集合由 .NET 提供。 每种类型的集合用于特定的用途。\n\n本部分介绍了一些通用集合类：\n\n*   [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 类\n    \n*   [System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 类\n    \n*   [System.Collections](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections) 类\n    \n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n### System.Collections.Generic 类\n\n可以使用 [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间中的某个类来创建泛型集合。 当集合中的所有项都具有相同的数据类型时，泛型集合会非常有用。 泛型集合通过仅允许添加所需的数据类型，强制实施强类型化。\n\n下表列出了 [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间中的一些常用类：\n\n| 类 | 说明 |\n| --- | --- |\n| [Dictionary<TKey,TValue>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2) | 表示基于键进行组织的键/值对的集合。 |\n| [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) | 表示可按索引访问的对象的列表。 提供用于对列表进行搜索、排序和修改的方法。 |\n| [Queue<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.queue-1) | 表示对象的先进先出 (FIFO) 集合。 |\n| [SortedList<TKey,TValue>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedlist-2) | 表示基于相关的 [IComparer<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icomparer-1) 实现按键进行排序的键/值对的集合。 |\n| [Stack<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.stack-1) | 表示对象的后进先出 (LIFO) 集合。 |\n\n有关其他信息，请参阅[常用集合类型](https://docs.microsoft.com/standard/collections/commonly-used-collection-types)、[选择集合类](https://docs.microsoft.com/standard/collections/selecting-a-collection-class)和 [](https://docs.microsoft.com/standard/collections/commonly-used-collection-types)。\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n### System.Collections.Concurrent 类\n\n在 .NET Framework 4 以及更新的版本中，[System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的集合可提供高效的线程安全操作，以便从多个线程访问集合项。\n\n只要多个线程同时访问集合，就应使用 [System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的类，而不是 [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 和 [System.Collections](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections) 命名空间中的相应类型。 有关详细信息，请参阅[线程安全集合](https://docs.microsoft.com/standard/collections/thread-safe/)和 [](https://docs.microsoft.com/standard/collections/thread-safe/)。\n\n包含在 [System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的一些类为 [BlockingCollection<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.blockingcollection-1)、[ConcurrentDictionary<TKey,TValue>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2)、[ConcurrentQueue<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentqueue-1) 和 [ConcurrentStack<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentstack-1)。\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n### System.Collections 类\n\n[System.Collections](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections) 命名空间中的类不会将元素作为特别类型化的对象存储，而是作为 `Object` 类型的对象存储。\n\n只要可能，则应使用 [System.Collections.Generic](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic) 命名空间或 [System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的泛型集合，而不是 `System.Collections` 命名空间中的旧类型。\n\n下表列出了 `System.Collections` 命名空间中的一些常用类：\n\n| 类 | 描述 |\n| --- | --- |\n| [ArrayList](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.arraylist) | 表示对象的数组，这些对象的大小会根据需要动态增加。 |\n| [Hashtable](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.hashtable) | 表示根据键的哈希代码进行组织的键/值对的集合。 |\n| [Queue](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.queue) | 表示对象的先进先出 (FIFO) 集合。 |\n| [Stack](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.stack) | 表示对象的后进先出 (LIFO) 集合。 |\n\n[System.Collections.Specialized](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.specialized) 命名空间提供专门类型化以及强类型化的集合类，例如只包含字符串的集合以及链接列表和混合字典。\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n实现键/值对集合\n--------\n\n[Dictionary<TKey,TValue>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2) 泛型集合可通过每个元素的键访问集合中的元素。 每次对字典的添加都包含一个值和与其关联的键。 通过使用键来检索值十分快捷，因为 `Dictionary` 类实现为哈希表。\n\n以下示例创建 `Dictionary` 集合并通过使用 `foreach` 语句循环访问字典。\n\n```\nprivate static void IterateThruDictionary()\n{\n    Dictionary<string, Element> elements = BuildDictionary();\n\n    foreach (KeyValuePair<string, Element> kvp in elements)\n    {\n        Element theElement = kvp.Value;\n\n        Console.WriteLine(\"key: \" + kvp.Key);\n        Console.WriteLine(\"values: \" + theElement.Symbol + \" \" +\n            theElement.Name + \" \" + theElement.AtomicNumber);\n    }\n}\n\nprivate static Dictionary<string, Element> BuildDictionary()\n{\n    var elements = new Dictionary<string, Element>();\n\n    AddToDictionary(elements, \"K\", \"Potassium\", 19);\n    AddToDictionary(elements, \"Ca\", \"Calcium\", 20);\n    AddToDictionary(elements, \"Sc\", \"Scandium\", 21);\n    AddToDictionary(elements, \"Ti\", \"Titanium\", 22);\n\n    return elements;\n}\n\nprivate static void AddToDictionary(Dictionary<string, Element> elements,\n    string symbol, string name, int atomicNumber)\n{\n    Element theElement = new Element();\n\n    theElement.Symbol = symbol;\n    theElement.Name = name;\n    theElement.AtomicNumber = atomicNumber;\n\n    elements.Add(key: theElement.Symbol, value: theElement);\n}\n\npublic class Element\n{\n    public string Symbol { get; set; }\n    public string Name { get; set; }\n    public int AtomicNumber { get; set; }\n}\n\n```\n\n若要转而使用集合初始值设定项生成 `Dictionary` 集合，可使用以下方法替换 `BuildDictionary` 和 `AddToDictionary`。\n\n```\nprivate static Dictionary<string, Element> BuildDictionary2()\n{\n    return new Dictionary<string, Element>\n    {\n        {\"K\",\n            new Element() { Symbol=\"K\", Name=\"Potassium\", AtomicNumber=19}},\n        {\"Ca\",\n            new Element() { Symbol=\"Ca\", Name=\"Calcium\", AtomicNumber=20}},\n        {\"Sc\",\n            new Element() { Symbol=\"Sc\", Name=\"Scandium\", AtomicNumber=21}},\n        {\"Ti\",\n            new Element() { Symbol=\"Ti\", Name=\"Titanium\", AtomicNumber=22}}\n    };\n}\n\n```\n\n以下示例使用 [ContainsKey](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2.containskey) 方法和 `Dictionary` 的 [Item\\[\\]](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2.item) 属性按键快速查找某个项。 使用 `Item` 属性可通过 C# 中的 `elements[symbol]` 来访问 `elements` 集合中的项。\n\n```\nprivate static void FindInDictionary(string symbol)\n{\n    Dictionary<string, Element> elements = BuildDictionary();\n\n    if (elements.ContainsKey(symbol) == false)\n    {\n        Console.WriteLine(symbol + \" not found\");\n    }\n    else\n    {\n        Element theElement = elements[symbol];\n        Console.WriteLine(\"found: \" + theElement.Name);\n    }\n}\n\n```\n\n以下示例则使用 [TryGetValue](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.dictionary-2.trygetvalue) 方法按键快速查找某个项。\n\n```\nprivate static void FindInDictionary2(string symbol)\n{\n    Dictionary<string, Element> elements = BuildDictionary();\n\n    Element theElement = null;\n    if (elements.TryGetValue(symbol, out theElement) == false)\n        Console.WriteLine(symbol + \" not found\");\n    else\n        Console.WriteLine(\"found: \" + theElement.Name);\n}\n\n```\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n使用 LINQ 访问集合\n------------\n\n可以使用 LINQ（语言集成查询）来访问集合。 LINQ 查询提供筛选、排序和分组功能。 有关详细信息，请参阅 [C# 中的 LINQ 入门](https://docs.microsoft.com/linq/)。\n\n以下示例运行一个对泛型 `List` 的 LINQ 查询。 LINQ 查询返回一个包含结果的不同集合。\n\n```\nprivate static void ShowLINQ()\n{\n    List<Element> elements = BuildList();\n\n    // LINQ Query.\n    var subset = from theElement in elements\n                 where theElement.AtomicNumber < 22\n                 orderby theElement.Name\n                 select theElement;\n\n    foreach (Element theElement in subset)\n    {\n        Console.WriteLine(theElement.Name + \" \" + theElement.AtomicNumber);\n    }\n\n    // Output:\n    //  Calcium 20\n    //  Potassium 19\n    //  Scandium 21\n}\n\nprivate static List<Element> BuildList()\n{\n    return new List<Element>\n    {\n        { new Element() { Symbol=\"K\", Name=\"Potassium\", AtomicNumber=19}},\n        { new Element() { Symbol=\"Ca\", Name=\"Calcium\", AtomicNumber=20}},\n        { new Element() { Symbol=\"Sc\", Name=\"Scandium\", AtomicNumber=21}},\n        { new Element() { Symbol=\"Ti\", Name=\"Titanium\", AtomicNumber=22}}\n    };\n}\n\npublic class Element\n{\n    public string Symbol { get; set; }\n    public string Name { get; set; }\n    public int AtomicNumber { get; set; }\n}\n\n```\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n对集合排序\n-----\n\n以下示例阐释了对集合排序的过程。 该示例对 [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 中存储的 `Car` 类的实例进行排序。 `Car` 类实现 [IComparable<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.icomparable-1) 接口，此操作需要实现 [CompareTo](https://docs.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto) 方法。\n\n每次对 [CompareTo](https://docs.microsoft.com/zh-cn/dotnet/api/system.icomparable-1.compareto) 方法的调用均会执行用于排序的单一比较。 `CompareTo` 方法中用户编写的代码针对当前对象与另一个对象的每个比较返回一个值。 如果当前对象小于另一个对象，则返回的值小于零；如果当前对象大于另一个对象，则返回的值大于零；如果当前对象等于另一个对象，则返回的值等于零。 这使你可以在代码中定义大于、小于和等于条件。\n\n在 `ListCars` 方法中，`cars.Sort()` 语句对列表进行排序。 对 [List<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1) 的 [Sort](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.sort) 方法的此调用将导致为 `List` 中的 `Car` 对象自动调用 `CompareTo` 方法。\n\n```\nprivate static void ListCars()\n{\n    var cars = new List<Car>\n    {\n        { new Car() { Name = \"car1\", Color = \"blue\", Speed = 20}},\n        { new Car() { Name = \"car2\", Color = \"red\", Speed = 50}},\n        { new Car() { Name = \"car3\", Color = \"green\", Speed = 10}},\n        { new Car() { Name = \"car4\", Color = \"blue\", Speed = 50}},\n        { new Car() { Name = \"car5\", Color = \"blue\", Speed = 30}},\n        { new Car() { Name = \"car6\", Color = \"red\", Speed = 60}},\n        { new Car() { Name = \"car7\", Color = \"green\", Speed = 50}}\n    };\n\n    // Sort the cars by color alphabetically, and then by speed\n    // in descending order.\n    cars.Sort();\n\n    // View all of the cars.\n    foreach (Car thisCar in cars)\n    {\n        Console.Write(thisCar.Color.PadRight(5) + \" \");\n        Console.Write(thisCar.Speed.ToString() + \" \");\n        Console.Write(thisCar.Name);\n        Console.WriteLine();\n    }\n\n    // Output:\n    //  blue  50 car4\n    //  blue  30 car5\n    //  blue  20 car1\n    //  green 50 car7\n    //  green 10 car3\n    //  red   60 car6\n    //  red   50 car2\n}\n\npublic class Car : IComparable<Car>\n{\n    public string Name { get; set; }\n    public int Speed { get; set; }\n    public string Color { get; set; }\n\n    public int CompareTo(Car other)\n    {\n        // A call to this method makes a single comparison that is\n        // used for sorting.\n\n        // Determine the relative order of the objects being compared.\n        // Sort by color alphabetically, and then by speed in\n        // descending order.\n\n        // Compare the colors.\n        int compare;\n        compare = String.Compare(this.Color, other.Color, true);\n\n        // If the colors are the same, compare the speeds.\n        if (compare == 0)\n        {\n            compare = this.Speed.CompareTo(other.Speed);\n\n            // Use descending order for speed.\n            compare = -compare;\n        }\n\n        return compare;\n    }\n}\n\n```\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n定义自定义集合\n-------\n\n可以通过实现 [IEnumerable<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ienumerable-1) 或 [IEnumerable](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable) 接口来定义集合。\n\n尽管可以定义自定义集合，但通常最好使用包含在 .NET 中的集合，这在本文前面的[集合类型](about:blank#BKMK_KindsOfCollections)中进行了介绍。\n\n以下示例定义一个名为 `AllColors` 的自定义集合类。 此类实现 [IEnumerable](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable) 接口，此操作需要实现 [GetEnumerator](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerable.getenumerator) 方法。\n\n`GetEnumerator` 方法返回 `ColorEnumerator` 类的一个实例。 `ColorEnumerator` 实现 [IEnumerator](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator) 接口，此操作需要实现 [Current](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.current) 属性、[MoveNext](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.movenext) 方法以及 [Reset](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.ienumerator.reset) 方法。\n\n```\nprivate static void ListColors()\n{\n    var colors = new AllColors();\n\n    foreach (Color theColor in colors)\n    {\n        Console.Write(theColor.Name + \" \");\n    }\n    Console.WriteLine();\n    // Output: red blue green\n}\n\n// Collection class.\npublic class AllColors : System.Collections.IEnumerable\n{\n    Color[] _colors =\n    {\n        new Color() { Name = \"red\" },\n        new Color() { Name = \"blue\" },\n        new Color() { Name = \"green\" }\n    };\n\n    public System.Collections.IEnumerator GetEnumerator()\n    {\n        return new ColorEnumerator(_colors);\n\n        // Instead of creating a custom enumerator, you could\n        // use the GetEnumerator of the array.\n        //return _colors.GetEnumerator();\n    }\n\n    // Custom enumerator.\n    private class ColorEnumerator : System.Collections.IEnumerator\n    {\n        private Color[] _colors;\n        private int _position = -1;\n\n        public ColorEnumerator(Color[] colors)\n        {\n            _colors = colors;\n        }\n\n        object System.Collections.IEnumerator.Current\n        {\n            get\n            {\n                return _colors[_position];\n            }\n        }\n\n        bool System.Collections.IEnumerator.MoveNext()\n        {\n            _position++;\n            return (_position < _colors.Length);\n        }\n\n        void System.Collections.IEnumerator.Reset()\n        {\n            _position = -1;\n        }\n    }\n}\n\n// Element class.\npublic class Color\n{\n    public string Name { get; set; }\n}\n\n```\n\n[](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/collections)\n\n迭代器\n---\n\n迭代器用于对集合执行自定义迭代。 迭代器可以是一种方法，或是一个 `get` 访问器。 迭代器使用 [yield return](https://docs.microsoft.com/language-reference/keywords/yield) 语句返回集合的每一个元素，每次返回一个元素。\n\n通过使用 [foreach](https://docs.microsoft.com/language-reference/statements/iteration-statements#the-foreach-statement) 语句调用迭代器。 `foreach` 循环的每次迭代都会调用迭代器。 迭代器中到达 `yield return` 语句时，会返回一个表达式，并保留当前在代码中的位置。 下次调用迭代器时，将从该位置重新开始执行。\n\n有关详细信息，请参阅[迭代器 (C#)](https://docs.microsoft.com/iterators)。\n\n下面的示例使用迭代器方法。 迭代器方法具有位于 `for` 循环中的 `yield return` 语句。 在 `ListEvenNumbers` 方法中，`foreach` 语句体的每次迭代都会创建对迭代器方法的调用，并将继续到下一个 `yield return` 语句。\n\n```\nprivate static void ListEvenNumbers()\n{\n    foreach (int number in EvenSequence(5, 18))\n    {\n        Console.Write(number.ToString() + \" \");\n    }\n    Console.WriteLine();\n    // Output: 6 8 10 12 14 16 18\n}\n\nprivate static IEnumerable<int> EvenSequence(\n    int firstNumber, int lastNumber)\n{\n    // Yield even numbers in the range.\n    for (var number = firstNumber; number <= lastNumber; number++)\n    {\n        if (number % 2 == 0)\n        {\n            yield return number;\n        }\n    }\n}\n\n```\n\n请参阅\n---\n\n*   [对象和集合初始值设定项](https://docs.microsoft.com/classes-and-structs/object-and-collection-initializers)\n*   [编程概念 (C#)](https://docs.microsoft.com/)\n*   [Option Strict 语句](https://docs.microsoft.com/visual-basic/language-reference/statements/option-strict-statement)\n*   [LINQ to Objects (C#)](https://docs.microsoft.com/linq/linq-to-objects)\n*   [并行 LINQ (PLINQ)](https://docs.microsoft.com/standard/parallel-programming/introduction-to-plinq)\n*   [集合和数据结构](https://docs.microsoft.com/standard/collections/)\n*   [选择集合类](https://docs.microsoft.com/standard/collections/selecting-a-collection-class)\n*   [集合内的比较和排序](https://docs.microsoft.com/standard/collections/comparisons-and-sorts-within-collections)\n*   [何时使用泛型集合](https://docs.microsoft.com/standard/collections/when-to-use-generic-collections)\n*   [迭代语句](https://docs.microsoft.com/language-reference/statements/iteration-statements)\n', '', 0, 0, 5, 0, 0, 0, 1660698992315, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Safari/537.36 Edg/104.0.1293.47', '::ffff:172.17.0.1', 1660698992315, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (51, 0, 10, 16, '文景·行业速递（2022年8月第3期，总第41期）', '文景·行业速递【2022年8月第3期】\n\n本期导读：\n政策概览方面，科技部发布关于支持建设新一代人工智能示范应用场景的通知，首批支持建设十个示范应用场景，推进智能物流与供应链技术规模化落地应用，降低物流成本。\n行业动态方面，山东首条商品车水铁联运过境中转班列跑出发展“加速度”，较同期增长69%；宁波舟山港实现海铁联运全程一站式线上服务；青岛港跻身先导级国际航运枢纽；徐州港顺堤河作业区智慧港口工程一期项目正式验收；台州港大麦屿港区多用途码头一期工程全部竣工；马士基推出中国至意大利、土耳其洲际海铁联运综合物流解决方案；广州港：柳州-南沙海铁联运班列开通；国铁集团：多措并举推进中欧班列信息化、数字化；中欧班列“江苏号”无锡—连云港—乌兹别克斯坦班列首发；新疆今年首趟冷链中欧班列通行；西部陆海新通道——陕桂海铁联运常态化班列开行；“京石欧”中欧班列首发；京东物流与山东港口物流集团达成战略合作，强化大宗商品供应链一体化升级。\n让我们共同学习、共同进步，携手推动客户与行业发展！\n\n欢迎大家一起来建设和完善《文景·行业速递》，踊跃投稿！\n联系人：总经办-何斐，邮箱：hefei@winjoinit.com \n\n\n \n------------------------------------\n\n \n一、政策概览\n（一）科技部：推进智能物流与供应链技术规模化落地应用，降低物流成本\n近日，科技部发布关于支持建设新一代人工智能示范应用场景的通知，首批支持建设十个示范应用场景，通知提出，针对智能仓储、智能配送、冷链运输等关键环节，运用人机交互、物流机械臂控制、反向定制、需求预测与售后追踪等关键技术，优化场景驱动的智能供应链算法，构建智能、高效、协同的供应链体系，推进智能物流与供应链技术规模化落地应用，提升产品库存周转效率，降低物流成本。以下为通知内容（部分）：\n为加快推动人工智能应用，助力稳经济，培育新的经济增长点，根据国务院发布的《新一代人工智能发展规划》，按照科技部等六部门联合印发的《关于加快场景创新 以人工智能高水平应用促进经济高质量发展的指导意见》，现启动支持建设新一代人工智能示范应用场景工作。有关事项通知如下。\n1、工作目标\n坚持面向世界科技前沿、面向经济主战场、面向国家重大需求、面向人民生命健康，充分发挥人工智能赋能经济社会发展的作用，围绕构建全链条、全过程的人工智能行业应用生态，支持一批基础较好的人工智能应用场景，加强研发上下游配合与新技术集成，打造形成一批可复制、可推广的标杆型示范应用场景。首批支持建设十个示范应用场景。\n2、首批示范应用场景\n（1）智能港口。\n针对港口大型码头泊位、岸桥管理以及堆场、配载调度等关键业务环节，运用智能化码头机械、数字孪生集成生产时空管控系统等关键技术，开展船舶自动配载、自动作业路径及泊位计划优化、水平运输车辆及新型轨道交通设备的协同调度、智能堆场选位等场景应用，形成覆盖码头运作、运行监测与设备健康管理的智能化解决方案，打造世界一流水平的超大型智能港口。\n（2）自动驾驶。\n针对自动驾驶从特定道路向常规道路进一步拓展需求，运用车端与路端传感器融合的高准确环境感知与超视距信息共享、车路云一体化的协同决策与控制等关键技术，开展交叉路口、环岛、匝道等复杂行车条件下自动驾驶场景示范应用，推动高速公路无人物流、高级别自动驾驶汽车、智能网联公交车、自主代客泊车等场景发展。\n（3）智能供应链。\n针对智能仓储、智能配送、冷链运输等关键环节，运用人机交互、物流机械臂控制、反向定制、需求预测与售后追踪等关键技术，优化场景驱动的智能供应链算法，构建智能、高效、协同的供应链体系，推进智能物流与供应链技术规模化落地应用，提升产品库存周转效率，降低物流成本。\n3、组织实施\n科技部以国家科技计划项目成果为主要基础，以国家新一代人工智能创新发展试验区为主要依托，充分发挥国家新一代人工智能开放创新平台企业作用，遴选一批支持建设的示范应用场景。\n各地方科技厅（委、局）、试验区向科技部推荐拟支持建设的示范应用场景，科技部经审核评估后，确定是否支持，并对建设达标的场景进行宣传推广。\n来源：科技部  2022年8月15日\n二、行业动态\nPart1 港航\n（一）同比增长69%，山东首条商品车水铁联运过境中转班列跑出发展“加速度”\n近日，山东港口烟台港对外公布，自2021年7月山东首条“韩国—烟台—中亚”商品车水铁联运过境中转班列在烟台港正式开通以来，现已形成月均2-3列发运规模，累计商品车发运量突破5000台，未来将达到月均4-6列发运频次，在畅通国内国际双循环中跑出发展“加速度”，为汽车全球产业链创造新盈利增长点。\n国际水铁联运过境运输是“一带一路”的重要组成部分，以往日韩等国销往中亚地区的商品车，大多通过水运至欧洲再进行分拨，全程耗时长，环节多，成本高，如今在山东港口烟台港通过“亚欧班列”打通商品车水铁联运通道，运输时间压缩百分之五十以上，极大降低了综合物流成本，有效提升了客户企业全球资源配置能力，让横跨亚欧大陆的产业经济“血管”更加畅通。\n作为中国第三大外贸整车出口港和山东省最大的专业化汽车码头，烟台港依托山东港口东连日韩、西接欧亚大陆的国际物流大通道优势，抢抓RCEP正式生效实施机遇，与山东自贸试验区烟台片区高效联动，在烟台海关高效监管服务下，持续发力商品车国际转运、水铁联运过境，在降低商品车物流成本、维护国际汽车产业链供应链稳定等方面贡献了港口力量。据海关统计，2022年1-7月份，山东港口烟台港共完成商品车国际转运班轮46航次，运量5.41万台，完成商品车水铁联运过境班列10列，运量2320台，国际转运业务较去年同期增长69%，突破去年全年总发运量，业务规模位居全国港口前列，为“一带一路”沿线国家优化产业链供应链布局提供优质高效的集成化服务。\n商品车是山东港口特色货种的一张闪亮名片，烟台港在加快建设中国北方商品车物流中转枢纽港征程中一路快跑、大步超越，现拥有南美航线、非洲航线等9条商品车国际滚装航线和5条国内航线，现已与50余家汽车生产商建立稳定的合作关系，出口货物品类涵盖轿车、轻卡、重卡、客车、工程机械、MAFI等40余个品牌，130多个车型，一汽、上汽、广汽等多家主机厂在烟台港设立分拨配送中心，国内腹地由山东省内拓展至全国25个省份,正依托成熟的商品车物流运输体系、齐备的配套设施、多元化的增值服务，加速推动港口服务链与商品车供应链、产业链、创新链、价值链的深度融合与一体发展,为中国汽车产业崛起和全球供应链畅通贡献山东港口力量。\n来源：中国水运网  2022年8月18日\n（二）宁波舟山港实现海铁联运全程一站式线上服务\n8月15日19时，装载着86标准箱货物的“绍兴—宁波舟山港”海铁联运班列从铁路皋埠站出发驶向宁波舟山港北仑港区，后续将转至梅山港区出运。在此次业务中，客户全程通过海铁联运物流协同服务系统完成业务委托操作，省去了多道线下申报环节，可将全程物流运输时间控制在24小时内，标志着宁波舟山港成功实现海铁联运全程一站式线上服务，进一步提升了宁波舟山港海铁联运服务质量。\n近年来，面对海铁联运业务不断发展及疫情下海运时效和成本不可控等情况，宁波舟山港以数字化改革为抓手，着力打造一个面向货代、短驳车队、揽货单位等的海铁联运业务统一受理窗口。围绕这一目标，信通公司与铁司、国际物流、四港公司等相关单位开展合作，梳理分析海铁联运业务信息共享需求，提炼总结海铁联运现有标准与实际运营情况，研发了物流作业高效协同、物流服务统一标准、物流信息全程可视的海铁联运物流协同服务系统。\n海铁联运物流协同服务系统可与现有的海铁联运计划系统实现互联互通，可通过系统配套的手机客户端实现客户“统一申报、统一调度、统一结费”托单业务，形成了海铁联运业务、商务全流程闭环，为客户提供从订舱到母港出运的全程一站式线上服务，有效提高海铁联运作业的计划性和操作效率。与此同时，该系统充分利用港口、铁路、口岸单位等信息资源，可为客户提供申报各项托单的实时查询及全程跟踪服务，大幅提高货物运输的透明度和安全性，实现了海铁联运业务全程的信息化、可视化、一体化。“现在这种‘下船即上车，下车即上船’的方式，省去了客户线下奔波、沟通的时间，更便利了！”铁司物流部经理王康对该系统点赞道。\n来源：集团文化新闻中心  2022年8月17日\n（三）青岛港跻身先导级国际航运枢纽 \n在8月15日举行的2022青岛·陆海联动研讨会上，发布解读了国际航运枢纽发展指数、新华·山东港口大宗商品指数、RCEP海运贸易指数，举行了系列重磅签约，发起“服务黄河流域生态保护和高质量发展”关港铁区大协作机制（青岛）倡议，进行了重大项目宣讲推介。\n其中，新华社中国经济信息社编制发布的国际航运枢纽发展指数显示，山东港口青岛港跻身先导级国际航运枢纽，在设施能力、航线网络、枢纽运营服务水平、创新引领能力等指标项上具有显著优势。\n1、国际航运枢纽发展指数发布\n当前，百年变局叠加世纪疫情，国际环境复杂严峻，全球经济增长放缓，国际大宗商品价格大幅上涨，给港航业发展带来了多重挑战。\n在此次大会上，新华社中国经济信息社编制发布国际航运枢纽发展指数，并联合山东港口发布新华·山东港口大宗商品指数和RCEP海运贸易指数，精准刻画港口航运枢纽高质量发展要素、大宗商品及RCEP海运贸易变化趋势，对于促进港口、大宗商品和贸易的高效联动意义重大，将更好推动国际经贸发展。\n其中，国际航运枢纽发展指数选择RCEP区域为主要研究范围，筛选出了29个规模较大、能力较强且具有代表性的港口纳入样本池进行研究。与国际航运中心发展指数综合考量港口产业和城市的融合发展情况不同，国际航运枢纽发展指数更加聚焦物流枢纽能力要素，更加关注港口自身能级的发展提升。\n指数显示，上海港与新加坡港为引领级国际航运枢纽；宁波舟山港、青岛港、深圳港、釜山港不仅在设施能力、航线网络等指标项上具有显著优势，在枢纽运营服务水平、创新引领能力等方面也各具特色，是先导级国际航运枢纽；广州港、天津港、巴生港、香港港、高雄港、厦门港是优势级国际航运枢纽；剩余样本港为中坚级国际航运枢纽。\n新华·山东港口大宗商品指数立足山东港口优势品种，由山东港口联合中国经济信息社研发编制，涵盖山东港口铁矿石、焦炭商品价格、库存和进出港的综合监测体系，既包含物价指数，又包含物量指数，反映了重要战略资源商品在港口的流通和交易情况。该指数精准刻画山东港口大宗商品贸易的变化水平，把港口“晴雨表”“反应器”作用具象化，更好发挥港口优势，为产业监测、贸易决策、科学调控提供了数据支持。\nRCEP海运贸易指数报告以RCEP除老挝之外的14个成员国为研究对象，选取约占RCEP海运贸易量三分之二的集装箱货物、铁矿石、煤炭、成品油、LNG、汽车六大类货物作为分析对象，以2019年数据为计算基期，从总体贸易额、海运贸易量两个维度反映RCEP海运贸易的年度发展趋势，对2017至2021年的情况进行评价。评价结果显示，2021年RCEP海运贸易指数为101.1，较上年度上升3.4点，已超过疫情前的最高水平（2019年）。可以看出，近年来RCEP海运贸易指数总体呈上升趋势，疫情等因素影响导致2020年RCEP海运贸易指数出现下滑。\n2、航运中心离不开港口群支撑\n构筑陆海联动新格局，其中一个关键因素是港口一体化。\n2019年8月6日，山东省港口集团应运而生。在全省一盘棋之下，青岛港担当枢纽港，做强做优国际干线，日照港、烟台港、渤海湾港积极当好青岛港的喂给港，各港口之间开通内支线，释放出一体化倍增效能。\n数据显示，三年来，山东港口不断增强海向通达度、陆向辐射度，全面服务构建新发展格局，吞吐量连跨三个亿吨台阶、突破15亿吨，约占我国港口总吞吐量的10%，集装箱量突破3400万标箱，分别稳居全球第一、第三位，“一带一路”及RCEP海陆辐射优势和枢纽地位得到全面巩固。作为龙头的青岛港更是迈入世界一流港口行列，吞吐量、集装箱量分别晋升世界第四、第六位。\n“山东港口致力于互联互通、保稳保供，充分发挥枢纽平台作用，加快建设东北亚国际航运枢纽中心，全力保障产业链供应链稳定。”山东港口党委副书记、董事、总经理李奉利表示。\n事实上，作为区域的核心战略资源，港口竞争已经逐步演变为港口群之间的竞争。从全球范围来看，港口一体化是大势所趋，而非中国的独有现象。包括美国、欧洲、日本、中国等全球主要港口群，都在采取不同方式推进一体化发展，以增强内部协同，提升对外竞争合力。\n比如，比利时的安特卫普和泽布吕赫通过建立统一的市场主体，完成一体化整合；美国的纽约和新泽西建立统一的公共管理机构，组建纽约-新泽西港务局，统一规划、开发和管理；中国港口一体化基本覆盖了主要沿海和沿江港口，其中浙江、山东、江苏、安徽、福建等港口集团都是省级政府主导，以市场化方式整合港口资源。此外，全球码头运营商正通过在全球投资和运营码头，实现全球码头的网络化、一体化运营和竞争。\n对于青岛而言，山东港口这个世界级港口群无疑为其建设国际航运中心打开了更加远大的想象空间。\n来源：澎湃新闻  2022年8月16日\n（四）徐州港顺堤河作业区智慧港口工程一期项目正式验收\n近日，徐州港顺堤河作业区智慧港口工程一期项目通过验收。这是江苏省港口集团信息科技有限公司智慧港航八大解决方案之一——散杂货码头信息化解决方案首次在内河港成功落地。\n徐州港顺堤河作业区智慧港口工程一期项目软件由省港口集团信息科技有限公司自主研发，主要包含了智慧仓储及监管、无人值守地磅、港口生产指挥中心等项目，通过三维建模、数字孪生、5G、移动互联网等技术应用，结合信息系统建设，优化了港口生产资源配置，实现了生产调度等港口业务的信息化管理，可助力港口生产作业提质增效，为徐州港实现智慧港口目标打下良好基础。\n本次项目的顺利实施，是江苏省港口集团启动“运河战略”以来的又一次重要实践。项目建设完成后，在指挥大厅通过大屏幕就可以总览全港口，并进行指挥管理，同时实现了对港口海量生产信息数据的存储、提取、清洗、转换、分析，使港口数据不仅仅是静态的生产数据，更可以实现内部各相关业务部门的资源共享，以及港口、物流等上下游信息资源整合，通过数据的积累和应用，提升业务效率，增强客户黏性，助力徐州港港口信息化建设升级，为徐州港实现智慧港口目标打下良好基础，积极推动区域港口一体化和地区经济高质量发展。\n来源：中国交通报  2022年8月18日\n（五）台州港大麦屿港区多用途码头一期工程全部竣工\n8月12日，台州港大麦屿港区多用途码头一期工程3万吨级多用途泊位及后方陆域顺利通过竣工验收，标志着该工程全部竣工。\n台州港大麦屿港区多用途码头一期工程位于台州市玉环岛西侧。该工程包括建设3万吨级、5万吨级（水工结构按靠泊7万吨集装箱船预留）多用途泊位各1座，以及配套生产、生活辅助建筑，总建筑面积20041平方米，设计年吞吐能力231万吨。其中，5万吨级多用途泊位水工部分于2010年1月22日通过竣工验收，3万吨级多用途泊位于2011年12月28日通过交工验收，后方陆域工程于2021年10月14日通过交工验收。\n项目建设期间，海港建设大麦屿项目部积极作为、多措并举，联合各参建单位克服疫情、台风、高温、施工生产交叉作业等影响，协调解决项目建设过程中遇到的困难与问题，稳步推动项目建设，为项目竣工验收打下坚实基础。\n台州港大麦屿港区多用途码头一期工程的建成投产，将进一步缓解大麦屿港区日益增长的堆场堆存压力，优化现有陆域布局，助力大麦屿港区提高生产效率和持续发展。\n来源：浙江海钢集团  2022年8月15日\n（六）马士基推出中国至意大利、土耳其洲际海铁联运综合物流解决方案\n马士基首列新疆乌鲁木齐-土耳其班列正式发车，这辆专列满载84个20英尺集装箱，它的开行进一步为中国西部地区出口货物提供了运输新路径。今年上半年，马士基已经成功推出洲际铁路加海运的多式联运物流方案。7月，两列班列分别从新疆乌鲁木齐及奎屯始发，途经哈萨克斯坦阿克套，跨里海至阿塞拜疆巴库，再通过铁路把货物运输至格鲁吉亚波季港，进一步衔接马士基海运网络把货物运送至意大利赛勒诺港。据介绍，本次乌鲁木齐-土耳其班列是马士基为新疆本地番茄酱企业量身打造的方案，为即将到来的产品旺季做好充足的准备。\n来源：电商报 2022年8月15日\n（七）广州港：柳州-南沙海铁联运班列开通\n8月12日下午，装载着广西柳州家电产品的22个40尺集装箱海铁联运班列到达南沙港南站，集装箱在南站卸载后直接转入南沙二期码头装上地中海“艾罗安”轮运往非洲。\n这是广西至广州港南沙港区开行的首趟集装箱海铁联运班列，全程铁路运距约1000公里，从柳州工厂送达南沙港用时仅4天，同比公路运输成本降低约20%。\n据悉，柳州是广西壮族自治区中部重要中心城市，是沟通西南与中南、华东、华南地区的重要铁路枢纽，有着丰富的产品货源和深厚的工业基础。柳州是广州港重要的货源腹地，物流公司收到客户项目咨询后，驻地团队立即到柳州开展实地调研，并根据客户需求制定全程物流方案。同时，积极向南宁铁路局、柳州铁路港、北港物流、柳州中外运等单位推介南沙港海铁联运业务以及南沙港的优势，争取柳州至南沙港出口的运价下浮政策，为当地企业货物经南沙海铁联运出海通道降本增效。\n广州港南沙港区自8月10日起至11月30日期间实施阶段性惠企措施，其中对经南沙港铁路南站进、出口的集装箱，免收南沙港南站普通重箱堆存费用，为外贸企业进一步降低物流成本带来新利好。\n依托南沙港区优越的地理位置、优良的营商环境、丰富的外贸班轮航线以及南沙港南站无缝连接铁路和港区的优势，广州港强化“双循环”枢纽节点功能，坚持上下“一盘棋”，物流公司以“立足广州、服务广东、辐射内陆”为目标，围绕货运代理、国际贸易、物流仓储、供应链金融等业务板块，加强全生态产业链延伸，进一步优化“站到站”和“门到门”的全流程、定制化服务，以多式联运为桥梁，打造高质量服务广州港国家物流枢纽建设的特色之路。\n据统计，截至目前，广州港开通至江西、湖南、四川、广西等内陆腹地海铁联运班列35条，今年上半年海铁联运集装箱量同比增长49.5%，其中南沙港铁路海铁联运箱量完成3.1万标箱。\n来源：广州港集团  2022年8月15日\nPart2 铁路\n（一）国铁集团：多措并举推进中欧班列信息化、数字化\n数字化管理是中欧班列高质量发展的必然要求。在18日国家发展改革委就《中欧班列发展报告（2021）》有关情况举行的发布会上，国铁集团货运部主任庄河介绍到，几年来，国铁集团在国家有关部门的大力支持下，不断推进与海关等行政部门及国外铁路的信息共享，推进中欧班列信息化、数字化，提升运输效率和服务水平。\n庄河表示，首先是实现了国际联运办理流程的电子化。2016年，国铁集团在95306货运电子商务平台开发了国际联运需求自动受理功能，实现了客户互联网提报需求，外方铁路受理结果经互联网反馈。2017年，开发了国联运单填制功能，实现了货协运单、国际货协/国际货约统一运单两种纸质国联运单的100%电子填报和打印。\n实现了与俄罗斯、哈萨克斯坦、蒙古铁路间信息交换。“中欧班列运输联合工作组”下设运输组织和信息两个工作组，每年召开工作会议，务实推进各国铁路间的运输合作和信息共享。2017年4月，中俄两国铁路正式签署数据交换协议，并于2018年8月正式开展进出境货物运单和列车编组信息交换。2019年，中哈、中蒙信息交换快速推进。通过与外方铁路的信息共享，大幅提升了口岸站单证交接和运输组织效率。\n实现了与海关全面协同作业。国铁集团与海关总署共同推动无纸化通关，组织研发了“数字口岸”系统，于2020年6月在国家铁路口岸站推广实施。通过数字口岸系统，代理企业可提前查看运输和到达信息，足不出户完成海关申报、铁路流向变更等联运手续。根据国内外发车信息，客户可提前办理海关手续，大幅缩短了通关时间、提升了作业效率。\n推进中欧班列信息集成平台建设。2021年，国铁集团在充分征求国家发展改革委、海关总署等部委以及各地平台公司意见基础上印发了《中欧班列信息集成平台建设行动计划》。在国家发展改革委大力支持下，开工建设了中欧班列信息集成平台项目，主要建设内容和任务包括开通中欧班列门户网站，打造信息发布、境内外全程业务、客户服务的重要窗口，实现与中欧班列相关主体间信息互联互通。\n“目前，国铁集团正在与俄罗斯、哈萨克斯坦等国铁路公司协商推进基于双方电子签名互认的无纸化运输。”庄河指出，同时在中欧班列运输联合工作组合作机制下，有关各方正在研究各国铁路开展区块链信息追踪的实施方案，将进一扩大信息共享的范围，为客户提供更多便捷服务。\n来源：光明网 2022年8月18日\n（二）中欧班列“江苏号”无锡—连云港—乌兹别克斯坦班列首发\n13日，随着一声鸣笛响起，中欧班列“江苏号”无锡—连云港—乌兹别克斯坦班列从无锡西站缓缓驶出。据悉，该班列在到达连云港(墟沟北)站集结后，将发往乌兹别克斯坦、哈萨克斯坦两国，行程20天左右。\n本趟班列搭载了无锡本地企业生产的聚酯切片、钻杆、家电、轮胎、汽车配件等多种货物，共计100个标箱，载重1000余吨，价值3000万元(人民币，下同)。\n近两年，受新冠肺炎疫情影响，外贸出口企业面临着一箱难求、运费居高不下等难题。无锡西站物流园区副主任朱萍介绍，铁路运输方式时效稳定，一般不受疫情影响，受恶劣天气影响小，具有较强的安全性、稳定性，能有效降低企业的运输成本。“此前无锡外贸企业对外发送货物，约九成是走公路和海运，中欧班列的运行将优化这一状况。”\n3月30日，开行无锡—徐州—汉堡的首趟试运行接续班列；4月28日，开行无锡—苏州—圣彼得堡试运行班列；5月7日，开行无锡—徐州—莫斯科试运行班列……今年以来，无锡已新增多条中欧班列线路。\n自6月7日无锡首次以整列开行中欧班列接续班列以来，已接单600标箱。\n随着中欧班列“江苏号”无锡—连云港—乌兹别克斯坦班列的首发，已有近50家无锡本土企业纷纷报名，期待能“搭”车走向海外。\n来源：探索新思路  2022年8月15日\n（三）新疆今年首趟冷链中欧班列通行\n8月12日22时15分，伴随着汽笛声，一列自江西赣州国际陆港铁路场站始发，满载50个集装箱的首列冷链中欧班列从阿拉山口铁路口岸出境，预计7天后抵达俄罗斯谢利亚季诺站，这是今年新疆通行的首趟冷链中欧班列，出境冷链货物品种和规模呈现增长态势。\n据悉，本批货物货值达453万美金，货物主要有冻鳗鱼、蔬菜等冷冻鲜食品。这趟冷链专列的顺利开行，为货源地及周边地区的农牧业和生鲜产品进出口打通了一条高效快捷的国际冷链物流大通道，是发展中欧班列特色班列的又一成果，有助于加快中欧班列与地方产业深度融合。\n为服务中欧班列高效通行，打通国内国际双循环，中国铁路乌鲁木齐局集团有限公司阿拉山口站根据通道能力情况，持续优化运输组织，科学制定班列运输组织方案，做到中欧班列原到原开，并对中欧班列实行优先办理、优先制票、优先换装、优先编组、优先发车运输组织模式，加强与海关、边检和哈萨克斯坦铁路部门的协调联系，落实定期对话机制，提前沟通信息，合理安排线路运用，提升运输组织效率，保障中欧班列高效通行。\n“为促进外贸稳增长，确保中欧班列高效通行，阿拉山口站加强与海关等联检单位沟通协调，破解运输组织中的难点，整合加快票据周转，压缩班列在口岸停留时间。今年，中欧班列在口岸日均通行数量达17列。”阿拉山口站货装车间货运员罗欢介绍。\n“相较于其他普通中欧班列，冷链班列对通关服务效能及口岸衔接速度提出了更高的要求，我们主动靠前服务企业，第一时间掌握相关信息，并积极协调铁路等部门，压缩货物在口岸运转时间，确保该趟班列高效快速通关。”阿拉山口海关监管二科一级行政执法员冯尹彭玉说。\n近年来，随着丝绸之路经济带核心区建设深入推进，新疆区位优势、资源优势不断显现，正成为向西开放的前沿门户。新疆铁路部门发挥阿拉山口、霍尔果斯铁路口岸通道优势，实施精准调度指挥，推进口岸扩能改造，在促进国际贸易发展和保障防疫物资运输等方面挑起了大梁，助力构建以国内大循环为主体、国内国际双循环相互促进的新发展格局，中欧班列的朋友圈持续扩大。2022年，阿拉山口站新增通行中欧班列线路已达21条，累计达86条，通行中欧班列线路已覆盖全国24个省、自治区、直辖市，通达德国、波兰等18个国家，搭载的货物涉及汽车及配件、棉纱、木材等8大类200余种。\n来源：光明日报  2022年8月14日\n（四）西部陆海新通道——陕桂海铁联运常态化班列开行 \n8月14日，随着一声机车汽笛长鸣，首趟西部陆海新通道——陕桂海铁联运常态化班列从西安国际港站发车，一路向南开往广西北部湾港。这是广西与陕西共享新通道发展机遇，加快西部陆海新通道建设的又一务实举措，为陕西内陆提供了一条稳定、安全、高效、便捷的物流运输大通道。\n为深入实施全国首个陆路启运港退税试点政策，加强与陕西共享新通道发展机遇，务实深化陕桂两省区全方位合作，借助第六届丝博会隆重召开之际，广西在西安市成功举办了西部陆海新通道暨陆路启运港退税试点政策广西推介会。推介会现场，举行了陆路启运港退税试点政策海铁联运班列（西安—北部湾港）战略合作框架协议签订仪式，宣布了西部陆海新通道（西安—北部湾港）海铁联运班列常态化开行，随着陕桂海铁联运班列常态化开行与陆路启运港退税试点政策的叠加，将为陕西省及周边的企业开展外贸运输提供了新动能。\n为做好此次班列的开行工作，中国铁路西安局集团有限公司从运输组织、货运调度等方面加强协调，不断优化班列运输方案。西安国际港站作为本次班列的始发站，进一步优化作业流程，提升作业效率，按照“优先配空、优先装卸、优先查验、优先始发”的作业原则，实现承运、查验、转运的快速无缝衔接，为班列的顺利开行提供坚强运输保障。\n陕西历史悠久、文化厚重、资源丰富、科教发达，经济发展迅速，是西部地区重要的经济中心。西安既是千年古都，也是千年商都，是古代陆路丝绸之路的起点，见证了“使者相望于道，商旅不绝于途”的盛况，广西北海是古代海上丝绸之路的始发港，见证了“舶交海中，不知其数”的繁华。近年来，在党中央、国务院的大力支持和沿线省份的共同努力下，广西、陕西等通道沿线兄弟省份强力推进新通道建设并取得显著成效，通道互联互通水平不断提高，物流服务水平和运行效率明显提升，双向共济的经贸联动格局逐步形成。\n2021年广西北部湾港集装箱吞吐量突破600万标箱，增速连续四年位列全国主要沿海港口第1位，海铁联运班列从2017年的178列增长到2021年的6117列，年均增速142%。今年1—7月，海铁联运班列共开行4978列、增长45%；北部湾港完成货物吞吐量2.1亿吨、增长3.44%，完成集装箱吞吐量379.91万标箱、增长22.01%，通道运行各项指标持续向好，西部陆海新通道的吸引力和竞争力不断增强，已成为中西部地区货物出海出边的主要通道和RCEP框架下连接中国与东盟地区最快速、最便捷的运输通道。\n今年3月,财政部、海关总署、税务总局联合印发了《关于陆路启运港退税试点政策的通知》，以陕西西安国际港务区铁路场站为启运港、北部湾港为离境港的全国首个陆路启运港退税试点政策顺利实施，为高水平共建西部陆海新通道带来重大利好，有效缩短陕西及周边地区出口企业退税时间，有助于提供企业资金循环效率、提升市场竞争力，支持内陆企业开拓“一带一路”沿线国家市场，对推动西部陆海新通道高质量发展、加快构建国内国际双循环新发展格局具有重要意义。\n来源：华商网  2022年8月15日\n（五）“京石欧”中欧班列首发\n8月16日上午10点38分，伴随着一声嘹亮的汽笛，首趟“京石欧”中欧班列从北京石景山南站北京外运陆运有限公司专用线驶向石家庄，经石家庄国际陆港集结中转后，开往俄罗斯下卡姆斯克。这是石家庄国际陆港发挥陆港型国家物流枢纽功能，服务京津冀协同发展的又一重要举措。\n该班列由北京中外运运输有限公司、河北中外运冀发物流有限公司与石家庄国际陆港联合组织开行。整列50个车厢满载冷藏冷冻箱、不干胶纸、调味品等货物，货重240多吨，价值760多万元，经由二连浩特口岸出境前往俄罗斯下卡姆斯克。\n“物流协同是疏解北京非首都功能、促进区域发展的重要领域。”石家庄国际陆港总经理刘金朋认为，“京石欧”中欧班列是北京在疏解非首都功能过程中，推动适铁物流向河北转移的发展成果，有助于深化京冀商贸物流协同发展。石家庄国际陆港将做到“枢纽功能＋资源共享”，构筑京津冀连通亚欧经贸往来的桥梁，推动地区外向型经济加快发展。\n河北陆港集团董事长刘瑞领表示，“京石欧”中欧班列的开通，将成为北京疏解非首都功能、河北承接产业转移的“助推器”，不仅有利于深化京冀两地物流合作，推动京津冀统一物流市场建设，也有利于石家庄国际陆港创建京津冀中欧班列集结中心，促进“一带一路”建设与京津冀协同发展的对接融合，一体化构建国内国际双循环新发展格局。\n据介绍，“京石欧”是石家庄国际陆港继“邢石欧”“沧石欧”“衡石欧”之后开通的第4条“+石欧”中欧班列。截至8月16日，石家庄国际陆港今年累计开行中欧班列229列，货值逾52亿元，拓展的13条国际线路，覆盖欧洲、中亚、东盟等40多个国家和地区，中欧班列开行量稳居京津冀首位，有力服务京津冀协同发展和共建“一带一路”。\n来源：河北经济日报 2022年8月17日\n\nPart3 产业供应链\n（一）京东物流与山东港口达成战略合作，强化大宗商品供应链一体化升级\n近日，京东物流与山东港口陆海国际物流集团有限公司（以下简称：山东港口物流集团）在青岛签署战略合作协议。双方宣布将以共建大宗一体化、数智化供应链为目标，通过对“公、铁、水”运力资源及站台、港口仓储资源的整合，加快大宗主要集散区域的网络化布局以及数智化能力创新共建，打造商流、物流、信息流、资金流“四流合一”的综合型大宗供应链解决方案。\n当前，我国大宗整车物流市场预估超过4万亿，卡车司机超过3500万人，市场体量和从业人员规模巨大，但整体存在信息化程度低、价格不透明、空载率高等诸多问题，给货主端造成运输成本高、货物安全和运输时效难以保证的同时，运力端的收益也无法保障，行业监管合规风险长期居高不下。\n为解决大宗物流实际痛点，山东港口物流集团选择携手京东物流，依托其在一体化供应链方面成熟的供应链基础设施与数字技术，实现优势互补、合作共赢。据悉，山东港口物流集团作为山东港口整合后组建的第一个板块集团，承担着整合港口物流资源、构建全程物流体系、创新发展现代物流业态的重要任务，在公铁、海港、陆港、供应链服务等领域具有明显优势，并且与京东物流在大宗业务、国际物流、快递快运、冷链医药、KA客户、大件运输和物流智能化等多维度、多领域，拥有良好的合作基础与广泛的合作空间。\n据悉，双方自今年1月合作以来，已先后在农业、钢材、有色金属、煤炭等多个行业领域落地重点项目，为中粮、华润、酒钢、忠旺、攀钢等客户提供了大宗物流服务；同时，双方也在西北区域共同打造煤炭产运销一体化供应链新模式，为新疆能源、河北燃料和陕煤集团提供了公铁联运的一体化供应链解决方案。\n此次战略合作是双方合作的进一步深化。根据协议，山东港口物流集团将与京东物流通过对“公、铁、水”运力资源及站台、港口仓储资源的整合，加快大宗主要集散区域的网络化布局，实现货物在场、站、港等物流枢纽的高效运转，为大宗货主企业提供全场景、全链路的大宗供应链一体化服务。\n针对大宗供应链数字化程度不高及各种系统相互孤立的痛点，双方将在供应链数字化、自动化与信息化等技术层面进行创新共建，依托物联网、区块链、云计算等前沿技术，实现从订单委托、智能调度、线上对账、自动计费、司机端履约的全流程线上化，提升运力匹配时效，完成大宗供应链在物流、资金流、信息流、票据流的“四流合一”。\n此外，双方也将依托主体信用评级优势、平台优势以及信息技术体系和数据沉淀，为下游承运商、个体司机提供多样化的供应链金融服务，并通过资金流、货流的风控闭环，探索建设风险防控体系，为上下游合作伙伴带来全新的价值提升。\n当前，山东港口正在加快建设世界一流的海洋港口，此次与京东物流的战略合作，将充分释放港口产业集聚功能和陆海联动效能，全面加速现代物流枢纽港口建设。京东物流作为国内领先的技术驱动的供应链解决方案与物流服务商，通过开放自身的供应链基础设施和技术，扎实推进链网融合，在保障自身供应链的稳定性与可靠性的同时，也在带动更多供应链、产业链上下游的数字化转型，为降低社会流通成本、提高生产效率贡献自己更多的力量。。\n来源：风口财经 2022年8月17日\n\n\n------------------------------------\n编辑：总经办  日期：2022年8月19日\n', '', 0, 0, 26, 0, 3, 0, 1660895042865, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 1660895042865, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (52, 0, 9, 2, '达梦环境下SqlSugar使用序列', '由于SqlSugar的序列配置`OracleSequenceName`仅支持`Oracle`数据库，所以在迁移到达梦后新增数据不会读取到配置的序列的值。\n\n使用`SqlSugar`的`AOP`机制在数据插入前读取序列值赋值给主键，具体参考代码如下：\n\n```\nDataExecuting = (oldValue, entityInfo) =>\n{\n    if (entityInfo.OperationType == DataFilterType.InsertByObject && entityInfo.EntityColumnInfo.IsPrimarykey)\n    {\n        // 设置序列值\n        var _id = Db.Ado.GetLong($\"select {entityInfo.EntityColumnInfo.OracleSequenceName}.nextval from dual\");\n        entityInfo.SetValue(_id);\n    }\n}\n``` ', '', 0, 0, 7, 0, 0, 0, 1661235598649, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63', '::ffff:172.17.0.1', 1661235598649, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (53, 0, 9, 2, 'DBMS_JOB 包', '为了兼容ORACLE定时任务的创建，按指定的时间或间隔执行用户定义的作业。达梦提供了DBMS\\_JOB包以及DBA\\_JOBS、USER\\_JOBS视图来实现跟ORACLE类似的功能。\n\n6.1 相关方法[](about:blank#undefined)\n---------------------------------\n\n1.  BROKEN过程\n\n更新一个已提交的工作的状态，典型地是用来把一个已过期工作标记为未过期工作；或者把一个未过期的工作设置为何时过期。\n\n语法如下：\n\n```\nPROCEDURE Broken(\n\n  job in integer，\n\n  broken in boolean,\n\n  next_date in datetime :=SYSDATE\n\n);\n\n```\n\n**参数详解**\n\n*   job工作号，唯一标识一个特定工作。\n*   broken指示此工作是否将标记为过期，TRUE或FALSE。TRUE表明过期，而FALSE表明未过期。\n*   next\\_date指示在什么时候此工作将再次运行。此参数缺省值为当前日期和时间。\n\n2.  CHANGE过程\n\n用来改变指定工作的设置。\n\n语法如下：\n\n```\nPROCEDURE Change (\n\n  job in integer,\n\n  what in varchar2,\n\n  next_date in datetime,\n\n  interval in varchar2\n\n);\n\n```\n\n**参数详解**\n\n*   job工作号，唯一标识一个特定工作。\n*   what是由此工作运行的一块PL/SQL代码块。\n*   next\\_date指示何时此工作将被执行。\n*   interval指示一个工作重执行的频度。\n\n**注意：**\n\n由于CHANGE是保留字，调用该过程时需要在过程名上加双引号。\n\n3.  INTERVAL过程\n\n用来显式地设置重执行一个工作之间的时间间隔数。\n\n语法如下：\n\n```\nPROCEDURE Interval (\n\n  job in integer,\n\n  interval in varchar2\n\n);\n\n```\n\n**参数详解**\n\n*   job 工作号，唯一标识一个特定工作。\n*   interval 指示一个工作重执行的频度，该频度是一个日期表达式字符串，以当天0点0分为起点和该日期表达式字符串计算出来的日期时间之差，以分钟为最小间隔单位。例如’sysdate+1/1440’，则表示间隔1分钟，’sysdate + 1/24’则表示间隔1小时，’sysdate +1’则表示间隔1天，最多允许间隔100天。达梦的INTERVAL参数不支持以周，月，季等单位方式指定间隔。\n\n**注意：**\n\n由于INTERVAL是保留字，调用该过程时需要在过程名上加双引号。\n\n4.  ISUBMIT过程\n\n用来用特定的工作号提交一个工作。这个过程与Submit()过程的唯一区别在于此job参数作为IN型参数传递且包括一个由开发者提供的工作号。如果提供的工作号已被使用，将产生一个错误。\n\n语法如下：\n\n```\nPROCEDURE ISubmit (\n\n  job in integer,\n\n  what in varchar2,\n\n  next_date in datetime,\n\n  interval in varchar2,\n\n  no_parse in boolean:=FALSE\n\n);\n\n```\n\n**参数详解**\n\n*   job是由用户指定的工作编号，不能为负数，且必须是不存在的工作编号。\n*   what是将被执行的PL/SQL代码块。\n*   next\\_date指示何时将运行这个工作。\n*   interval何时这个工作将被重执行。\n*   no\\_parse指示此工作在提交时或执行时是否应进行语法分析，TRUE指示此PL/SQL代码在它第一次执行时应进行语法分析，而FALSE指示本PL/SQL代码应立即进行语法分析。\n\n5.  NEXT\\_DATE过程\n\n用来显式地设定一个工作的执行时间。\n\n语法如下：\n\n```\nPROCEDURE Next_Date(\n\n  job in integer,\n\n  next_date in datetime\n\n);\n\n```\n\n**参数详解**\n\n*   job标识一个已存在的工作。\n*   next\\_date指示了此工作应被执行的日期与时间。\n\n6.  REMOVE过程\n\n用来删除一个已计划运行的工作。已正在运行的工作不能由调用过程序删除。\n\n语法如下：\n\n```\nPROCEDURE Remove(\n\n  job in integer\n\n);\n\n```\n\n**参数详解**\n\n*   job唯一地标识一个工作。这个参数的值是由为此工作调用Submit()过程返回的job参数的值。\n\n7.  RUN过程\n\n用来立即执行一个指定的工作。需要说明的是，RUN过程的调用不影响工作的计划运行时间。\n\n语法如下：\n\n```\nPROCEDURE Run(\n\n  job in integer\n\n);\n\n```\n\n**参数详解**\n\njob标识将被立即执行的工作。\n\n8.  SUBMIT过程\n\n使用Submit()过程，工作被正常地计划好。\n\n语法如下：\n\n```\nPROCEDURE Submit (\n\n  job out integer,\n\n  what in varchar2,\n\n  next_date in date,\n\n  interval in varchar2,\n\n  no_parse in boolean:=FALSE\n\n);\n\n```\n\n**参数详解**\n\n*   job 是由Submit()过程返回的工作编号。这个值用来唯一标识一个工作。\n*   what 是将被执行的PL/SQL代码块。\n*   next\\_date 指识何时将运行这个工作。\n*   interval 何时这个工作将被重执行。\n*   no\\_parse 指示此工作在提交时或执行时是否应进行语法分析，TRUE指示此PL/SQL代码在它第一次执行时应进行语法分析，而FALSE指示本PL/SQL代码应立即进行语法分析。\n\n9.  WHAT过程\n\n允许在工作执行时重新设置此正在运行的命令。\n\n语法如下：\n\n```\nPROCEDURE What (\n\n  job in integer,\n\n  what in out varchar2\n\n);\n\n```\n\n**参数详解**\n\n*   job标识一个存在的工作。\n*   what指示将被执行的新的PL/SQL代码，如果传入的what参数值为空串，那将返回该任务原来的PL/SQL代码。\n\n6.2 DBMS\\_JOB视图[](about:blank#undefined)\n----------------------------------------\n\n1.  BDA\\_JOBS视图\n\n描述数据库中所有的JOB。\n\n| **序号** | **列** | **数据类型** | **说明** |\n| --- | --- | --- | --- |\n| 1 | JOB | INTEGER | 工作的唯一标识号 |\n| 2 | LOG\\_USER | VARCHAR(8188) | 提交工作的用户 |\n| 3 | PRIV\\_USER | VARCHAR(8188) | 赋予工作权限的用户 |\n| 4 | SCHEMA\\_USER | VARCHAR(8188) | 对工作做语法分析的用户模式 |\n| 5 | LAST\\_DATE | DATE | 最后一次成功运行工作的时间 |\n| 6 | LAST\\_SEC | TIME(0) | HH:MM:SS格式的LAST\\_DATE的时间 |\n| 7 | THIS\\_DATE | DATE | 正在运行工作的开始时间 |\n| 8 | THIS\\_SEC | TIME(0) | HH:MM:SS格式的THIS\\_DATE的时间 |\n| 9 | NEXT\\_DATE | DATE | 下一次定时任务运行的时间 |\n| 10 | NEXT\\_SEC | TIME(0) | HH:MM:SS格式的NEXT\\_DATE的时间 |\n| 11 | TOTAL\\_TIME | FLOAT | 该job运行所需的总时间 |\n| 12 | BROKEN | VARCHAR(1) | 是否工作中断标识参数，Y是，N否 |\n| 13 | INTERVAL | INTEGER | 用于计算下一运行时间的表达式 |\n| 14 | FAILURES | BIGINT | 工作运行连续没有成功的次数 |\n| 15 | WHAT | VARCHAR(1800) | 执行工作的PL/SQL块 |\n| 16 | NLS\\_ENV | VARCHAR(1) | 工作运行的NLS会话设置 |\n| 17 | MISC\\_ENV | VARCHAR(1) | 工作运行的其他一些会话参数 |\n| 18 | INSTANCE | INTEGER | 能够运行或正在运行工作的实例的id号。 单节点上默认值为1，如果是DM MPP或DMDSC环境。 默认值为实例序号加1。 |\n\n2.USER\\_JOBS视图\n\n描述当前用户所拥有的JOB。视图结构与DBA\\_JOBS相同。\n\n3.DBA\\_JOBS\\_RUNNING\n\n显示实例中所有正在执行的作业。\n\n| 序号 | 列 | 数据类型 | 说明 |\n| --- | --- | --- | --- |\n| 1 | SID | BIGINT | 作业执行的SESSION的ID |\n| 2 | JOB | INTEGER | 作业号 |\n| 3 | FAILURES | INTEGER | 作业自上一次成功以来的失败次数，暂不支持 |\n| 4 | LAST\\_DATE | DATE | 最后一次成功运行工作的时间 |\n| 5 | LAST\\_SEC | TIME(0) | HH:MM:SS格式的LAST\\_DATE的时间 |\n| 6 | THIS\\_DATE | DATE | 本次运行的开始时间 |\n| 7 | THIS\\_SEC | TIME(0) | HH:MM:SS格式的THIS\\_DATE的时间 |\n| 8 | INSTANCE | INTEGER | 能够运行或正在运行作业的实例的ID号。 单节点上默认值为1，如果是DM MPP或DMDSC环境，默认值为实例序号加1 |\n\n6.3 创建、删除语句[](about:blank#undefined)\n------------------------------------\n\n创建或删除DBMS\\_JOB系统包。\n\n语法如下：\n\n```\nvoid\n\nSP_INIT_JOB_SYS(\n\n    CREATE_FLAG int\n\n)\n\n```\n\n**参数详解**\n\n*   CREATE\\_FLAG\n\n为1时表示创建DBMS\\_JOB包；为0表示删除该系统包。\n\n**返回值**\n\n无\n\n**举例说明**\n\n创建DBMS\\_JOB系统包。\n\n```\nSP_INIT_JOB_SYS(1);\n\n```\n\n6.4 举例说明[](about:blank#undefined)\n---------------------------------\n\n用户在使用DBMS\\_JOB包之前，需要提前调用系统过程SP\\_INIT\\_JOB\\_SYS(1)，创建好调试所需要的包，就可以使用DBMS\\_JOB来调用PL/SQL中的过程或函数了。\n\n```\nSP_INIT_JOB_SYS(1);\n\n```\n\n创建测试表\n\n```\ncreate table a(a datetime);\n\n```\n\n创建一个自定义过程\n\n```\ncreate or replace procedure test as\n\nbegin\n\ninsert into a values(sysdate);\n\nend;\n\n/\n\n```\n\n创建JOB\n\n```\nbegin\n\ndbms_job.isubmit(1,\'test;\',sysdate,\'sysdate+1/1440\');--每天1440分钟，即一分钟运行test过程一次\n\n  commit;\n\nend;\n\n/\n\n```\n\n查看JOB运行结果\n\n```\nselect to_char(a,\'yyyy/mm/dd hh24:mi:ss\') 时间 from a;\n\n```\n\n结果如下：\n\n```\n时间\n\n2013/09/04 13:22:44\n\n2013/09/04 13:23:44\n\n2013/09/04 13:24:44\n\n2013/09/04 13:25:44\n\n```\n\n删除JOB\n\n```\nbegin\n\ndbms_job.remove(1);\n\nend;\n\n/\n\n```\n\nPL/SQL过程已成功完成。', '', 0, 0, 8, 0, 0, 0, 1661239117831, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63', '::ffff:172.17.0.1', 1661239117831, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (54, 0, 9, 2, 'Oracle迁移达梦选择合适的初始化参数', '初始化库，关键的点在于对初始化参数的设置，本章节明确是从 Oracle 移植到 DM 数据库，所以具体的初始化参数建议如下：\n\n- 关于页大小 PAGE_SIZE。Oracle 也叫块大小（block），在 DM 数据库中，页大小可以为 4KB、8KB、16KB 或者 32KB，从 Oracle 移植到 DM，建议设置页大小为 8KB，一旦创建好了数据库，在该库的整个生命周期内，页大小都不能够改变。除了每个字段的最大长度限制外，每条记录总长度不能大于页面大小的一半。如果系统中存在或者以后可能存在含有较长的字符串类型的表，建议该参数设置为 16 或者 32。页大小设置越大，最后数据文件的物理大小就会越大，系统运行时，每次从磁盘调入内存的数据单位也就越大，所以此处要慎重。\n\n- 关于簇大小 EXTENT_SIZE。数据文件使用的簇大小，即每次分配新的段空间时连续的页数，只能是 16 页或 32 页，缺省使用 16 页，从 ORACLE 移植到 DM 使用默认值就可。\n\n- 关于大小写敏感 CASE_SENSITIVE。DM 为了兼容不同的数据库，在初始化数据库的时候有一个参数字符串比较大小写敏感，用于确定数据库对象及数据是否区分大小写，默认为区分，不可更改。建议 MYSQL 和 SQLSERVER 迁移过来的系统，使用大小写不敏感，ORACLE 迁移过来的系统，使用大小写敏感，以便和原来系统匹配。\n\n- 关于字符集 CHARSET。建议采用默认值 GB18030，如果需要国际字符可以采用Unicode，GB18030 数字字母占 1 个字节，普通汉字占 2 个字节，部分繁体及少数民族文字占 4 字节，Unicode 在达梦中采用 UTF-8 编码格式，欧洲的字母字符占 1 到 2 个字节，亚洲的大部分字符占 3 个字节，附加字符为 4 个字节。如果只存储中文和字母数字，一般来说 GB18030 更节省空间一些。\n\n- BLANK_PAD_MODE 空格填充模式，默认是 0，从 Oracle 移植要设置为 1.\nBLANK_PAD_MODE 主要用于 Oracle 数据的兼容，达梦默认设置 BLANK_PAD_MODE=0，即在做数据对比时，默认会截断字符结尾的空格，而 Oracle 默认是会识别到字符结尾的空格。\n```\n1. 在BLANK_PAD_MODE=0时\nSQL> create table student(id int, name varchar(20));\nSQL> insert into student values (1,\'blank \');\nSQL> commit;\nSQL> insert into student values (1,\'blank\');\nSQL> commit;\nSQL> create unique index idx_test_blank on student(name);\ncreate unique index idx_test_blank on student(name);\n[-6612]:违反唯一性约束.\n已用时间: 4.925(毫秒). 执行号:0.\n\n2. 在BLANK_PAD_MODE=1时，同样的表和数据\n登录使用时间 : 4.018(ms)\ndisql V8\nSQL> create unique index idx_test_blank on student(name);\n操作已执行\n已用时间: 5.721(毫秒). 执行号:50700.\n```\n\n#### 合理配置 INI 参数\n|Compatibility|使用效果及建议|\n|-|-|\n|COMPATIBLE_MODE|是否兼容其他数据库模式。0：不兼容，1：兼容 SQL92 标准，2：兼容 ORACLE，3：兼容 MS SQL SERVER，4：兼容 MYSQL，5：兼容 DM6，6：兼容 Teradata，所以当从 Oracle 移植到DM7 时，修改值为2；|\n|CALC_AS_DECIMAL|整数相除是否保留小数位，修改为 1|\n', '', 0, 0, 15, 0, 0, 0, 1661493923248, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63', '::ffff:172.17.0.1', 1661493923248, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (55, 0, 7, 2, 'SqlSugar迁移达梦问题汇总', '1、**实体序列配置`OracleSequenceName`无法应用**\n在`SqlSugar`中`OracleSequenceName`是只适用于Oracle数据库的实体配置，并不适用达梦数据库；\n- 达梦支持自增主键，在数据库中设置即可；\n- 通过AOP方式手动查询 序列 值并设置到实体中；\n```\n            Db.Aop.DataExecuting = (oldValue, entityInfo) =>\n            {\n                if (entityInfo.OperationType == DataFilterType.InsertByObject\n                            && entityInfo.EntityColumnInfo.IsPrimarykey\n                            && !string.IsNullOrWhiteSpace(entityInfo.EntityColumnInfo.OracleSequenceName))\n                {\n                    // 设置序列值\n                    var _id = Db.Ado.GetLong($\"select {entityInfo.EntityColumnInfo.OracleSequenceName}.nextval from dual\");\n                    entityInfo.SetValue(_id);\n                }\n            };\n```\n2、程序中将`short`类型改成`int`；`double`改成`decimal`；\n- 解决达梦驱动读取`number(n,0)`数据类型时读取到`n.0`值而转换失败的问题\n\n3、[主键使用序列情况下`ExecuteReturnIdentity`方法适配达梦](http://192.168.1.83:5000/topic/58)\n\n4、解决自定义函数中`DbType`参数获取值在达梦情况下错误的问题\n- `SqlSugar 5.1.2.3` 以前版本中自定义函数 `dbType` 在达梦版本下获取值是`SqlServer`，暂时可以通过增加类型判断解决\n```\n                new SqlFuncExternal()\n                {\n                    UniqueMethodName = \"GetDomainName\",\n                    MethodValue = (expInfo, dbType, expContext) =>\n                    {\n                        if (dbType == DbType.Oracle || dbType == DbType.Dm || dbType == DbType.SqlServer)\n                            return string.Format(\"COMM_PAK.GET_DOMAIN_CODENM_F({0},{1})\", expInfo.Args[0].MemberName,expInfo.Args[1].MemberName);\n                        else\n                            throw new Exception(\"未实现\");\n                    }\n                }\n```\n- 此问题在 `SqlSugar 5.1.2.4+`已修复，可以通过升级版本解决\n\n5、表字段类型避免设置为`varchar2(18)`', '', 0, 0, 38, 0, 0, 0, 1661495280568, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63', '::ffff:172.17.0.1', 1661495280568, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (56, 0, 9, 2, 'Oracle与DM无区别的函数', '| Oracle函数名 | DM函数名 | 功能简要说明 |\n|:--|:--|:--|\n| **数值函数** | - | - |\n| ABS(n) | ABS(n) | 求数值 n 的绝对值 |\n| ACOS(n) | ACOS(n) |求数值 n 的反余弦值|\n| ASIN(n)|ASIN(n)|求数值 n 的反正弦值|\n|ATAN(n)|ATAN(n)|求数值 n 的反正切值|\n|ATAN2(n1,n2)|ATAN2(n1,n2)|求数值 n1/n2 的反正切值|\n|**CEIL(n)**|CEIL(n)或 CEILING(n)|求大于或等于数值 n 的最小整数|\n|COS(n)|COS(n)|求数值 n 的余弦值|\n|COSH(n)|COSH(n)|求数值 n 的双曲余弦值|\n|COT(n)|COT(n)|求数值 n 的余切值|\n|EXP(n)|EXP(n)|求 e 的 n 次幂值，e=2.71828183...|\n|FLOOR(n)|FLOOR(n)|求小于或等于数值 n 的最大整数|\n|GREATEST(n1,n2,n3)|GREATEST(n1,n2,n3)|求 n1、n2 和 n3中的最大浮点数|\n|LEAST(n1,n2,n3)|LEAST(n1,n2,n3)|求 n1、n2 和 n3中的最小浮点数|\n|LN(n)|LN(n)|求数值 n 的自然对数|\n|LOG(n1,n2)|LOG(n1,n2)|求数值n2以n1为底数的对数|\n|MOD(m,n)|MOD(m,n)|求数值m被数值n除的余数|\n|PI()|PI()|得到常数π|\n|POWER(n1,n2)|POWER(n1,n2)|求数值n2以n1为基数的指数|\n|RAND([n])|RAND([n])|求一个 0 到 1 之间的随机浮点数|\n|**ROUND(n[,m])**|ROUND(n[,m])|求四舍五入值函数|\n|SIGN(n)|SIGN(n)|判断数值的数学符号|\n|SIN(n)|SIN(n)|求数值 n 的正弦值|\n|SINH(n)|SINH(n)|求数值 n 的双曲正弦值|\n|SQRT(n)|SQRT(n)|求数值 n 的平方根|\n|TAN(n)|TAN(n)|求数值 n 的正切值|\n|TANH(n)|TANH(n)|求数值 n 的双曲正切值|\n|**TO_NUMBER (char [,fmt])**|TO_NUMBER (char [,fmt])|将 CHAR 、VARCHAR 、VARCHAR2 等类型的字符串转换为 DECIMAL 类型的数值|\n|**TRUNC(n[,m])**|TRUNC(n[,m])|截取数值函数|\n|TRUNCATE(n[,m])|TRUNCATE(n[,m])|截取数值函数，等价于 TRUNC|\n|TO_CHAR(n [, fmt [,\'nlsparam\' ] ])|TO_CHAR(n [, fmt [,\'nlsparam\' ] ])|将数字类型的数据转换为VARCHAR类型输出|\n|BITAND(n1, n2)|BITAND(n1, n2)|求两个数值型数值按位进行 AND运算的结果|\n| **字符串函数** |-|-|\n|ASCII(char)|ASCII(char)|返回字符对应的整数|\n|ASCIISTR(char)|ASCIISTR(char)|将字符串 char 中，非 ASCII 的字符转成\\XXXX(UTF-16)格式，ASCII 字符保持不变|\n|BIT_LENGTH(char)|BIT_LENGTH(char)|求字符串的位长度|\n|CHAR(n)或 CHR(n)|CHAR(n)或 CHR(n)|返回整数 n 对应的字符|\n|CHAR_LENGTH(char)|CHAR_LENGTH(char)|求字符串的串长度|\n|CHARACTER_LENGTH(char)|CHARACTER_LENGTH(char)|求字符串的串长度|\n|**CONCAT(char1,char2)**|CONCAT(char1,char2)|顺序联结 2 个字符串成为一个字符串|\n|DIFFERENCE(char1,char2)|DIFFERENCE(char1,char2)|以整数返回两个字符串的SOUNDEX值之差|\n|INITCAP(char)|INITCAP(char)|将字符串中单词的首字符转换成大写的字符|\n|**INSTR(char1,char2,n,m)**|INSTR(char1,char2,n,m)|从输入字符串char1的第n个字符开始查找字符串char2的第m次的出现，以字符计算|\n|INSTRB(char1,char2,n,m)|INSTRB(char1,char2,n,m)|从输入字符串char1的第n个字符开始查找字符串char2的第m次的出现，以字节计算|\n|LCASE(char)|LCASE(char)|将大写的字符串转换为小写的字符串|\n|**LENGTH(char)**|LEN(char)或 LENGTH(char)|返回给定字符串表达式的字符(而不是字节)个数（汉字为一个字符），其中不包含尾随空格|\n|LENGTHB(char)|LENGTHB(char)|返回输入字符串的字节数|\n|LOCATE(char1,char2)|LOCATE(char1,char2)|返 回 char1 在char2 中首次出现的位置|\n|LOWER(char)|LOWER(char)|将大写的字符串转换为小写的字符串|\n|LTRIM(char1,char2)|LTRIM(char1,char2)|从输入字符串中删除所有的前导字符，这些前导字符由 char2 来定义|\n|REPEAT(char, n)|REPEAT(char, n)/REPEATSTR(char, n)|返回将字符串重复 n 次形成的字符串|\n|REPLACE (arg1,arg2,arg3)|REPLACE (arg1,arg2,arg3)|将在 arg1 中的所有 arg2 替 换 成arg3|\n|REVERSE(char)|REVERSE(char)|将字符串反序|\n|RPAD(char1,n,char2)|RPAD(char1,n,char2)|类似 LPAD 函数，只是向右拉伸该字符串使之达到 n个字符串长|\n|RTRIM(char1,char2)|RTRIM(char1,char2)|从输入字符串的右端开始删除char2 参数中的字符|\n|SOUNDEX(char)|SOUNDEX(char)|返回一个表示字符串发音的字符串|\n|STUFF(char1,begin,n,char2)|STUFF(char1,begin,n,char2)|删除在字符串char1 中以 begin参 数所指位置开始的 n 个字符, 再把 char2 插入到char1 串的 begin所指位置|\n|**SUBSTR(char,m,n)**|SUBSTR(char,m,n)|返回 char 中从字符位置m开始的n个字符|\n|SUBSTRB(char,n,m)|SUBSTRB(char,n,m)|SUBSTR 函数等价的单字节形式|\n|**TO_CHAR(DATE[,fmt])**|TO_CHAR(DATE[,fmt])|日期转换为字符串函数|\n|TRANSLATE(S,S1,S2)|TRANSLATE(S,S1,S2)|将所有出现在搜索字符集中的字符转换成字符集中的相应字符|\n|TRIM([LEADING|TRAILING|BOTH] [exp] [] FROM char2])|TRIM([LEADING|TRAILING|BOTH] [exp] [] FROM char2])|删去字符串 char2中由串 char1 指定的字符|\n|UPPER(char)|UPPER(char)|将小写的字符串转换为大写的字符串|\n|GREATEST(char 1, char 2, char 3)|GREATEST(char 1, char 2, char 3)|求 char 1、char 2和 char 3 中最大的字符串|\n|to_single_byte (char)|to_single_byte (char)|将多字节形式的字符（串）转换为对应的单字节形式|\n|TO_MULTI_BYTE(char)|TO_MULTI_BYTE(char)|将单字节形式的字符（串）转换为对应的多字节形式|\n|EMPTY_CLOB ()|EMPTY_CLOB ()|初始化 clob 字段|\n|EMPTY_BLOB ()|EMPTY_BLOB ()|初始化 blob 字段|\n| **日期类函数** |-|-|\n|ADD_DAYS(date,n)|ADD_DAYS(date,n)|返回日期加上 n 天后的新日期|\n|ADD_MONTHS(date,n)|ADD_MONTHS(date,n)|在输入日期上加上指定的几个月返回一个新日期|\n|ADD_WEEKS(date,n)|ADD_WEEKS(date,n)|返回日期加上 n 个星期后的新日期|\n|CURRENT_DATE()|CURRENT_DATE()|返回系统当前日期|\n|CURRENT_TIMESTAMP(n)|CURRENT_TIMESTAMP(n)|返回系统当前带时区信息的时间戳|\n|EXTRACT(时间字段 FROM date)|EXTRACT(时间字段 FROM date)|抽取日期时间或时间间隔类型中某一个字段的值|\n|GREATEST(n1,n2,n3)|GREATEST(n1,n2,n3)|求 n1、n2 和 n3中的最大日期|\n|LAST_DAY(date)|LAST_DAY(date)|返回输入日期所在月份最后一天的日期|\n|LEAST(n1,n2,n3)|LEAST(n1,n2,n3)|求 n1、n2 和 n3中的最小日期|\n|MONTHS_BETWEEN(date1,date2)|MONTHS_BETWEEN(date1,date2)|返回两个日期之间的月份数|\n|NEXT_DAY(date1,char2)|NEXT_DAY(date1,char2)|返回输入日期指定若干天后的日期|\n|ROUND (date1,char2)|ROUND (date1,char2)|把日期四舍五入到最接近格式元素指定的形式|\n|**SYSDATE()**|SYSDATE()|返回系统的当前日期|\n|**TO_DATE(CHAR[,fmt])**|TO_DATE(CHAR[,fmt])|字符串转换为日期数据类型|\n|TRUNC(date[,format])|TRUNC(date[,format])|把日期截断到最接近格式元素指定的形式|\n|LOCALTIMESTAMP()|LOCALTIMESTAMP()|返回系统当前时间戳|\n|OVERLAPS|OVERLAPS|返回两两时间段是否存在重叠|\n|NUMTODSINTERVAL(dec,interval_unit)|NUMTODSINTERVAL(dec,interval_unit)|转换一个指定的DEC 类型到INTERVAL DAY TO SECOND|\n|NUMTOYMINTERVAL(dec,interval_unit)|NUMTOYMINTERVAL(dec,interval_unit)|转换一个指定的DEC 类型值到INTERVAL YEAR TO MONTH|\n|FROM_TZ(timestamp,timezone|tz_name])|FROM_TZ(timestamp,timezone|tz_name])|将时间戳类型timestamp 和时区类型 timezone（或时区名称tz_name）转化为timestamp with timezone 类型|\n|**TO_CHAR(DATE[,fmt])**|TO_CHAR(DATE[,fmt])|将日期数据类型DATE 转换为一个在日期语法 fmt 中指定语法的VARCHAR 类型字符串|\n| **空值判断函数** |-|-|\n|COALESCE(n1,n2,…nx)|COALESCE(n1,n2,…nx)|返回第一个非空的值|\n|IFNULL(n1,n2)|IFNULL(n1,n2)|当 n1 为非空时，返回 n1；若 n1 为空，则返回 n2|\n|NULLIF(n1,n2)|NULLIF(n1,n2)|如果 n1=n2 返回NULL，否则返回n1|\n|NVL(n1,n2)|NVL(n1,n2)|返回第一个非空的值|\n| **类型转换函数** |-|-|\n|CAST(value AS 类型说明)|CAST(value AS 类型说明)|将 value 转换为指定的类型|\n|CONVERT(类型说明,value)|CONVERT(类型说明,value)|将 value 转换为指定的类型|\n|HEXTORAW(string)|HEXTORAW(string)|将由 string 表示的二进制数值转换为一个 RAW 数值|\n|RAWTOHEX(rawvalue)|RAWTOHEX(rawvalue)|将 RAW 类数值rawvalue 转换为一个相应的十六进制表示的字符串|\n| **集函数** | - | - |\n|COUNT|COUNT|对组内发生的事情进行累计|\n|Avg|Avg|计算一个组和数据窗口内表达式的平均值|\n|MAX|MAX|在一个组中的数据窗口中查找表达式的最大值|\n|MIN|MIN|在一个组中的数据窗口中查找表达式的最小值|\n|SUM|SUM|该函数计算组中表达式的累积和|\n|DISTINCT|DISTINCT|去重函数|\n|covar_pop|covar_pop|协方差函数|\n|covar_samp|covar_samp|协方差函数|\n|CORR|CORR|协方差函数|\n|var_pop|var_pop|方差函数|\n|var_samp|var_samp|方差函数|\n|VARIANCE|VARIANCE|该函数返回表达式的方差|\n|stddev_pop|stddev_pop|方差函数|\n|STDDEV|STDDEV|计算当前行关于组的标准偏离|\n|STDDEV_SAMP|STDDEV_SAMP|该函数计算累积样本标准偏离，并返回总体变量的平方根，其返回值与 VAR_POP 函数的平方根相同|\n|**LISTAGG**|LISTAGG|字符串集函数|\n| **杂类函数** |-|-|\n|**DECODE**(exp, search1, result1, … searchn, resultn [,default])|DECODE(exp, search1, result1, … searchn, resultn [,default])|decode 函数比较表达式和搜索字，如果匹配，返回结果；如果不匹配，返回 default 值；如果未定义default 值，则返回空值|\n|ROWIDTOCHAR(rowid)|ROWIDTOCHAR(rowid)|将 INT 类 型 的ROWID 值转换成CHAR 类|\n|VSIZE(expr)|VSIZE(expr)|返回 n 的核心内部表示的字节数|\n| **group by字句相关函数** |-|-|\n|GROUP_ID()|GROUP_ID()|表示结果集来自于哪一个分组，用于区别相同分组的结果集|\n|GROUPING(expr)|GROUPING(expr)|用来标识某列是否为分组列|\n|GROUPING_ID(expr)|GROUPING_ID(expr)|表示参数列是否为分组列|\n| **Regexp函数（正则）** |-|-|\n|REGEXP_COUNT(str, pattern[, position [, match_param]])|REGEXP_COUNT(str, pattern[, position [, match_param]])|根据 pattern 正则表达式，从 str 字符串的第position 个字符开始查找符合正则表达式的子串的个数，并符合匹配参数match_param|\n|REGEXP_INSTR(str, pattern[, position[, occurrence [, return_opt [, match_param [, subexpr]]]]])|REGEXP_INSTR(str, pattern[, position[, occurrence [, return_opt [, match_param [, subexpr]]]]])|根据 pattern 正则表达式，从 str 字符串的第position 个字符开始查找符合subexpr 正则表达式的子串，如果return_opt 为 0，返回第occurrence 次出现的位置，如果return_opt 为大于 0，则返回该出现位置的下一个字符位置，并符合匹配参数。Subexpr 为匹配的子 pattern|\n|REGEXP_SUBSTR(str, pattern [,position [, occurrence[,match_param[, subexpr]]]])|REGEXP_SUBSTR(str, pattern [,position [, occurrence[,match_param[, subexpr]]]])|根据 pattern 正则表达式，从 str 字符串的第position 个字符开始查找符合subexpr 正则表达式的子串，返回第occurrence 次出现的子串，并符合匹配参数match_param|\n|REGEXP_REPLACE(str, pattern [, replace_str [, position [, occurrence[,match_param]]]])|REGEXP_REPLACE(str, pattern [, replace_str [, position [, occurrence[,match_param]]]])|根据 pattern 正则表达式，从 str 字符串的第position 个字符开始查找符合正则表达式的子串，并用 replace_str进行替换第occurrence 次出现的子串，并符合匹配参数match_param。|', '', 0, 0, 38, 0, 1, 0, 1661501255274, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63', '::ffff:172.17.0.1', 1661501255274, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (57, 0, 7, 2, '模式匹配概述', '“模式匹配”是一种测试表达式是否具有特定特征的方法。 C# 模式匹配提供更简洁的语法，用于测试表达式并在表达式匹配时采取措施。 “[`is`](https://docs.microsoft.com/language-reference/operators/is) 表达式”目前支持通过模式匹配测试表达式并有条件地声明该表达式结果。 “[`switch`](https://docs.microsoft.com/language-reference/operators/switch-expression) 表达式”允许你根据表达式的首次匹配模式执行操作。 这两个表达式支持丰富的[模式](https://docs.microsoft.com/language-reference/operators/patterns)词汇。\n\n本文概述了可以使用模式匹配的方案。 这些方法可以提高代码的可读性和正确性。 有关可以应用的所有模式的完整讨论，请参阅语言参考中有关[模式](https://docs.microsoft.com/language-reference/operators/patterns)的文章。\n\nNull 检查\n-------\n\n模式匹配最常见的方案之一是确保值不是 `null`。 使用以下示例进行 `null` 测试时，可以测试可为 null 的值类型并将其转换为其基础类型：\n\n```\nint? maybe = 12;\n\nif (maybe is int number)\n{\n    Console.WriteLine($\"The nullable int \'maybe\' has the value {number}\");\n}\nelse\n{\n    Console.WriteLine(\"The nullable int \'maybe\' doesn\'t hold a value\");\n}\n\n```\n\n上述代码是[声明模式](https://docs.microsoft.com/language-reference/operators/patterns#declaration-and-type-patterns)，用于测试变量类型并将其分配给新变量。 语言规则使此方法比其他方法更安全。 变量 `number` 仅在 `if` 子句的 true 部分可供访问和分配。 如果尝试在 `else` 子句或 `if` 程序块后等其他位置访问，编译器将出错。 其次，由于不使用 `==` 运算符，因此当类型重载 `==` 运算符时，此模式有效。 这使该方法成为检查空引用值的理想方法，可以添加 `not` 模式：\n\n```\nstring? message = \"This is not the null string\";\n\nif (message is not null)\n{\n    Console.WriteLine(message);\n}\n\n```\n\n前面的示例使用[常数模式](https://docs.microsoft.com/language-reference/operators/patterns#constant-pattern)将变量与 `null` 进行比较。 `not` 为一种[逻辑模式](https://docs.microsoft.com/language-reference/operators/patterns#logical-patterns)，在否定模式不匹配时与该模式匹配。\n\n类型测试\n----\n\n模式匹配的另一种常见用途是测试变量是否与给定类型匹配。 例如，以下代码测试变量是否为非 null 并实现 [System.Collections.Generic.IList<T>](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.ilist-1) 接口。 如果是，它将使用该列表中的 [ICollection<T>.Count](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.icollection-1.count#system-collections-generic-icollection-1-count) 属性来查找中间索引。 不管变量的编译时类型如何，声明模式均与 `null` 值不匹配。 除了防范未实现 `IList` 的类型之外，以下代码还可防范 `null`。\n\n```\npublic static T MidPoint<T>(IEnumerable<T> sequence)\n{\n    if (sequence is IList<T> list)\n    {\n        return list[list.Count / 2];\n    }\n    else if (sequence is null)\n    {\n        throw new ArgumentNullException(nameof(sequence), \"Sequence can\'t be null.\");\n    }\n    else\n    {\n        int halfLength = sequence.Count() / 2 - 1;\n        if (halfLength < 0) halfLength = 0;\n        return sequence.Skip(halfLength).First();\n    }\n}\n\n```\n\n可在 `switch` 表达式中应用相同测试，用以测试多种不同类型的变量。 你可以根据特定运行时类型使用这些信息创建更好的算法。\n\n比较离散值\n-----\n\n你还可以通过测试变量找到特定值的匹配项。 在以下代码演示的示例中，你针对枚举中声明的所有可能值进行数值测试：\n\n```\npublic State PerformOperation(Operation command) =>\n   command switch\n   {\n       Operation.SystemTest => RunDiagnostics(),\n       Operation.Start => StartSystem(),\n       Operation.Stop => StopSystem(),\n       Operation.Reset => ResetToReady(),\n       _ => throw new ArgumentException(\"Invalid enum value for command\", nameof(command)),\n   };\n\n```\n\n前一个示例演示了基于枚举值的方法调度。 最终 `_` 案例为与所有数值匹配的[弃元模式](https://docs.microsoft.com/language-reference/operators/patterns#discard-pattern)。 它处理值与定义的 `enum` 值之一不匹配的任何错误条件。 如果省略开关臂，编译器会警告你尚未处理所有可能输入值。 在运行时，如果检查的对象与任何开关臂均不匹配，则 `switch` 表达式会引发异常。 可以使用数值常量代替枚举值集。 你还可以将这种类似的方法用于表示命令的常量字符串值：\n\n```\npublic State PerformOperation(string command) =>\n   command switch\n   {\n       \"SystemTest\" => RunDiagnostics(),\n       \"Start\" => StartSystem(),\n       \"Stop\" => StopSystem(),\n       \"Reset\" => ResetToReady(),\n       _ => throw new ArgumentException(\"Invalid string value for command\", nameof(command)),\n   };\n\n```\n\n前面的示例显示相同的算法，但使用字符串值代替枚举。 如果应用程序响应文本命令而不是常规数据格式，则可以使用此方案。 从 C# 11 开始，还可以使用 `Span<char>` 或 `ReadOnlySpan<char>` 来测试常量字符串值，如以下示例所示：\n\n```\npublic State PerformOperation(ReadOnlySpan<char> command) =>\n   command switch\n   {\n       \"SystemTest\" => RunDiagnostics(),\n       \"Start\" => StartSystem(),\n       \"Stop\" => StopSystem(),\n       \"Reset\" => ResetToReady(),\n       _ => throw new ArgumentException(\"Invalid string value for command\", nameof(command)),\n   };\n\n```\n\n在所有这些示例中，“弃元模式”可确保处理每个输入。 编译器可确保处理每个可能的输入值，为你提供帮助。\n\n关系模式\n----\n\n你可以使用[关系模式](https://docs.microsoft.com/language-reference/operators/patterns#relational-patterns)测试如何将数值与常量进行比较。 例如，以下代码基于华氏温度返回水源状态：\n\n```\nstring WaterState(int tempInFahrenheit) =>\n    tempInFahrenheit switch\n    {\n        (> 32) and (< 212) => \"liquid\",\n        < 32 => \"solid\",\n        > 212 => \"gas\",\n        32 => \"solid/liquid transition\",\n        212 => \"liquid / gas transition\",\n    };\n\n```\n\n上述代码还演示了联合 `and`[逻辑模式](https://docs.microsoft.com/language-reference/operators/patterns#logical-patterns)，用于检查两种关系模式是否匹配。 你还可以使用析取 `or` 模式检查模式匹配。 这两种关系模式括在括号中，可以在任何模式下用于清晰表述。 最后两个开关臂用于处理熔点和沸点的案例。 如果没有这两个开关臂，编译器将警告你的逻辑未涵盖每个可能的输入。\n\n上述代码还说明了编译器为模式匹配表达式提供的另一项重要功能：如果没有处理每个输入值，编译器会发出警告。 如果交换机 arm 已由先前的交换机 arm 处理，则编译器还会发出警告。 这使你能够随意重构和重新排列 switch 表达式。 编写同一表达式的另一种方法是：\n\n```\nstring WaterState2(int tempInFahrenheit) =>\n    tempInFahrenheit switch\n    {\n        < 32 => \"solid\",\n        32 => \"solid/liquid transition\",\n        < 212 => \"liquid\",\n        212 => \"liquid / gas transition\",\n        _ => \"gas\",\n};\n\n```\n\n关于这一点和任何其他重构或重新排列的关键注意事项是，编译器会验证你已涵盖所有输入。\n\n多个输入\n----\n\n到目前为止，你所看到的所有模式都在检查一个输入。 可以写入检查一个对象的多个属性的模式。 请考虑以下 `Order` 记录：\n\n```\npublic record Order(int Items, decimal Cost);\n\n```\n\n前面的位置记录类型在显式位置声明两个成员。 首先出现 `Items`，然后是订单的 `Cost`。 有关详细信息，请参阅[记录](https://docs.microsoft.com/language-reference/builtin-types/record)。\n\n以下代码检查项数和订单值以计算折扣价：\n\n```\npublic decimal CalculateDiscount(Order order) =>\n    order switch\n    {\n        { Items: > 10, Cost: > 1000.00m } => 0.10m,\n        { Items: > 5, Cost: > 500.00m } => 0.05m,\n        { Cost: > 250.00m } => 0.02m,\n        null => throw new ArgumentNullException(nameof(order), \"Can\'t calculate discount on null order\"),\n        var someObject => 0m,\n    };\n\n```\n\n前两个开关臂检查 `Order` 的两个属性。 第三个仅检查成本。 下一个检查 `null`，最后一个与其他任何值匹配。 如果 `Order` 类型定义了适当的 [`Deconstruct`](https://docs.microsoft.com/deconstruct) 方法，则可以省略模式的属性名称，并使用析构检查属性：\n\n```\npublic decimal CalculateDiscount(Order order) =>\n    order switch\n    {\n        ( > 10,  > 1000.00m) => 0.10m,\n        ( > 5, > 50.00m) => 0.05m,\n        { Cost: > 250.00m } => 0.02m,\n        null => throw new ArgumentNullException(nameof(order), \"Can\'t calculate discount on null order\"),\n        var someObject => 0m,\n    };\n\n```\n\n上述代码演示了[位置模式](https://docs.microsoft.com/language-reference/operators/patterns#positional-pattern)，其中表达式的属性已析构。\n\n列表模式\n----\n\n可以使用列表模式检查列表或数组中的元素。 列表模式提供了一种方法，将模式应用于序列的任何元素。 此外，还可以应用弃元模式 (`_`) 来匹配任何元素，或者应用切片模式来匹配零个或多个元素。 以下示例确定数组是否与二进制数字匹配，或与 Fibonacci 序列的开头匹配：\n\n```\npublic void MatchElements(int[] array)\n{\n    if (array is [0,1])\n    {\n        Console.WriteLine(\"Binary Digits\");\n    }\n    else if (array is [1,1,2,3,5,8, ..])\n    {\n        Console.WriteLine(\"array looks like a Fibonacci sequence\");\n    }\n    else\n    {\n        Console.WriteLine(\"Array shape not recognized\");\n    }\n}\n\n```\n\n本文介绍了可以使用 C# 中的模式匹配写入的代码类型。 下面的文章显示了在方案中使用模式的更多示例，以及可供使用的完整模式词汇。\n\n另请参阅\n----\n\n*   [使用模式匹配来避免后跟强制转换的“is”检查（样式规则 IDE0020 和 IDE0038）](https://docs.microsoft.com/fundamentals/code-analysis/style-rules/ide0020-ide0038)\n*   [探索：使用模式匹配生成类行为以获得更好的代码](https://docs.microsoft.com/whats-new/tutorials/patterns-objects)\n*   [教程：使用模式匹配来构建类型驱动和数据驱动的算法](https://docs.microsoft.com/tutorials/pattern-matching)\n*   [引用：模式匹配](https://docs.microsoft.com/language-reference/operators/patterns)\n\n[](about:blank#)', '', 0, 0, 7, 0, 1, 0, 1661842364159, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70', '::ffff:172.17.0.1', 1661842364159, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (58, 0, 7, 2, '解决SqlSugar方法ExecuteReturnIdentity适配达梦的问题', '如果数据库中表主键没有设置自增，而是使用序列的话，`ExecuteReturnIdentity`方法并不会返回新增后的主键值，因为实体中配置的序列是只适用`Oracle`数据库版本的，解决办法如下：\n```\n        /// <summary>\n        /// 获取序列当前值\n        /// </summary>\n        /// <param name=\"seqName\"></param>\n        /// <returns></returns>\n        private long GetSeqCurrValue(string seqName)\n        {\n            return Db.Ado.GetLong(\" SELECT \" + seqName + \".currval FROM DUAL\");\n        }\n        /// <summary>\n        /// 获取序列名称\n        /// </summary>\n        /// <returns></returns>\n        private string GetSeqName<Entity>()\n        {\n            var type = typeof(Entity);\n            var customAttribute = type.GetProperties()\n                .Where(it => it.GetCustomAttributes(typeof(SugarColumn), true).Any(x => !string.IsNullOrWhiteSpace(((SugarColumn)x).OracleSequenceName)))\n                .FirstOrDefault();\n            if (customAttribute != null)\n            {\n                var sugarAttribute = (SugarColumn)customAttribute.GetCustomAttributes(true).First(it => it is SugarColumn);\n                return sugarAttribute.OracleSequenceName;\n            }\n            return string.Empty;\n        }\n        public virtual long InsertReturnId(T t)\n        {\n            // 兼容达梦\n            var seq = GetSeqName<T>();\n            if (!string.IsNullOrWhiteSpace(seq))\n            {\n                var result = Db.Insertable(t).ExecuteCommand();\n                if (result > 0)\n                {\n                    return GetSeqCurrValue(seq);\n                }\n                return result;\n            }\n            else\n            {\n                return Db.Insertable(t).ExecuteReturnIdentity();\n            }\n        }\n        public virtual long InsertOtherEntityAndReturnId<Entity>(Entity entity) where Entity : class, new()\n        {\n            // 兼容达梦\n            var seq = GetSeqName<Entity>();\n            if (!string.IsNullOrWhiteSpace(seq))\n            {\n                var result = Db.Insertable(entity).ExecuteCommand();\n                if (result > 0)\n                {\n                    return GetSeqCurrValue(seq);\n                }\n                return result;\n            }\n            else\n            {\n                return Db.Insertable(entity).ExecuteReturnIdentity();\n            }\n        }\n```', '', 0, 0, 14, 0, 0, 0, 1661931552869, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70', '::ffff:172.17.0.1', 1661931552869, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (59, 0, 9, 2, '达梦连接字符串', '**连接串**\n\n公共属性ConnectionString是用于连接DM数据库的字符串，其格式为：\n\n```\n<属性名>=<属性值>{;<属性名>=<属性值>}\n\n```\n\n其中支持的属性名及其意义如下表所示：\n\n| **属性名** | **意义** |\n| --- | --- |\n| server | 服务名。 |\n| login\\_primary | 在主备情况下是否仅登录到主库或备库。0：主库不存在的情况下可连接备库；1：只连接主库；2：只连接备库；3：优先连接备库。默认为0。 |\n| port | 登录端口号。 |\n| user | 用户名。 |\n| password | 用户口令。 |\n| timeout | 连接超时时间，默认15s。 |\n| commandTimeout | 命令超时时间，默认30s。 |\n| appname | 应用名。 |\n| trace | NONE：不记录TRACE； DEBUG：将TRACE内容打印到控制台； TRACE：将TRACE内容记录到运行路径下的ProviderTrace.txt文件中。 |\n| primary\\_key | 需要加双引号的关键字。 |\n| switch\\_time | 主备切换的次数，默认为3。 |\n| switch\\_interval | 主备切换的时间间隔，默认为200ms。 |\n| time\\_zone | 时区，默认为当前时区。 |\n| rw\\_separate | 是否读写分离，默认为FALSE。 |\n| rw\\_percent | 读写分离百分比，默认为25。 |\n| connPooling | 是否使用连接缓存池，默认为TRUE，表示开启。 |\n| connPoolSize | 连接池中最大连接数，默认为100，连接池开启时有效。 |\n| connPoolCheck | 是否检查连接池中连接的有效性，TRUE表示检查， FALSE表示不检查，默认为FALSE，连接池开启时有效。 |\n| stmtPooling | 是否启用句柄重用，默认为TRUE。 |\n| poolSize | 句柄重用缓冲区的大小，默认为100。 |\n| encoding | 客户端本地编码，支持UTF-8或GB18030。默认为GB18030。 |\n| logLevel | 日志等级，默认为OFF，高级别同时记录低级别的信息。 OFF：不记录； ERROR：记录错误日志； SQL：记录执行SQL信息； INFO：记录全部执行信息。 |\n| logDir | 生成日志路径，默认为当前执行程序路径，日志文件名自动生成，格式如： DmProvider\\_2019\\_09\\_05\\_16\\_49\\_20.845.log。 |\n| enRsCache | 是否打开结果集缓存。默认值false。 |\n| rsCacheSize | 缓存池大小，单位M。默认值10。 |\n| rsRefreshFreq | 缓存池中结果集更新的频率阈值，即大于该值时才检查命中的结果集是否需要更新,单位秒。默认值10。 |\n| lobMode | 结果集中大字段类型数据的缓存方式。值为1表示本地只缓存一部分数据；值为2表示本地缓存全部的数据。默认值1。 |\n| batchType | 绑定多行参数执行时，值为0表示分多次执行，一次只执行一行参数；值为1表示一次执行多行参数。默认值为1。 |\n| batchNotOnCall | 执行SQL为存储过程时，是否允许一次执行多行参数。默认值为false。 |\n| batchContinueOnError | 绑定多行参数执行时，某行参数执行出错后，后续参数是否继续执行。默认值为false。 |\n| batchAllowMaxErrors | 绑定多行参数执行时允许的错误数最大值。默认值为0。 |\n| bufPrefetch | Fetch获取的结果集内存大小，单位M。默认值为0。 |\n| compatibleMode | 兼容模式。值为0表示不开启该功能；值为1表示兼容oracle；值为2表示兼容mysql。默认值为0。 |\n| isBdtaRS | 消息中结果集是否以Bdta格式。默认值为false。 |\n| maxRows | 返回的结果集最大行数。默认值为0x7fffffff。 |\n| scoketTimeout | 网络包读写的超时时间值，单位秒。默认值为0。 |\n| addressRemap | 服务器网络地址映射表。默认值为空串。值格式：address\\_remap=192.168.1.24:5236,192.168.1.23:5236 。 |\n| userRemap | 用户名映射表。默认值为空串。格式同 addressRemap。 |\n| epSelector | 服务名配置的集群选取起始位置的方式。值为0表示随机选取一个站点为起始位置；值为1表示第一个站点就是起始位置。默认值为0。 |\n| loginStatus | 设置连接的服务器状态。值为0，表示不开启该功能；值为4表示open状态；值为3表示mount状态；值为5表示suspend状态。默认值为0。 |\n| ep\\_selection | 当集群中存在故障节点时是否进行连接优化。值为0表示进行优化，重排连接节点次序，故障节点位置靠后；值为1表示不进行优化。默认值为0。 |\n| maxLobDataLenPerMsg | 指定单条消息中大字段类型数据的最大长度，单位字节，默认值为32000，最小值为1024（1K），最大值为104857600（100M），超出范围则使用默认值。 |', '', 0, 0, 11, 0, 0, 0, 1662086765854, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70', '::ffff:172.17.0.1', 1662086765854, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (60, 0, 7, 2, 'Infrastructure.Core框架迁移达梦指南', '1、增加`DbProviderFactoryExtensions`扩展类\n```\nusing Dm;\nusing System;\nusing System.Data;\nusing System.Data.Common;\nusing System.Globalization;\n\nnamespace Infrastructure.Dal\n{\n    public static class DbProviderFactoryExtensions\n    {\n        /// <summary>\n        /// 根据 sql 语句生成 DbCommand 对象\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"sql\">sql 语句</param>\n        /// <returns></returns>\n        public static DbCommand GetSqlStringCommand(this DbProviderFactory dbProviderFactory, string sql)\n        {\n            return CustomDatabaseFactory.CreateDbCommand(dbProviderFactory, sql, CommandType.Text);\n        }\n\n        /// <summary>\n        /// 根据 存储过程 名生成 DbCommand 对象\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"storedProcedureName\">存储过程名称</param>\n        /// <returns></returns>\n        public static DbCommand GetStoredProcCommand(this DbProviderFactory dbProviderFactory, string storedProcedureName)\n        {\n            return CustomDatabaseFactory.CreateDbCommand(dbProviderFactory, storedProcedureName, CommandType.StoredProcedure);\n        }\n\n        /// <summary>\n        /// 查询结果集第一行第一列\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <returns></returns>\n        public static object ExecuteScalar(this DbProviderFactory dbProviderFactory, DbCommand dbCommand)\n        {\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            return dbCommand.ExecuteScalar();\n        }\n\n        /// <summary>\n        /// 查询结果集并从中读取行数据\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <returns></returns>\n        public static IDataReader ExecuteReader(this DbProviderFactory dbProviderFactory, DbCommand dbCommand)\n        {\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            return dbCommand.ExecuteReader();\n        }\n\n        /// <summary>\n        /// 获取指定列的 32 位有符号整数形式的值\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"columnIndex\"></param>\n        /// <returns></returns>\n        public static int GetInt32(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, int columnIndex = 0)\n        {\n            int result = default;\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            var dmDataReader = (DmDataReader)dbCommand.ExecuteReader();\n            try\n            {\n                while (dmDataReader.Read())\n                {\n                    result = dmDataReader.GetInt32(columnIndex);\n                }\n                return result;\n            }\n            catch (Exception ex)\n            {\n                throw ex;\n            }\n            finally\n            {\n                dmDataReader.Close();\n            }\n        }\n\n        /// <summary>\n        /// 获取指定列的 DateTime 对象形式的值\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"columnIndex\"></param>\n        /// <returns></returns>\n        public static DateTime GetDateTime(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, int columnIndex = 0)\n        {\n            DateTime result = default;\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            var dmDataReader = (DmDataReader)dbCommand.ExecuteReader();\n            try\n            {\n                while (dmDataReader.Read())\n                {\n                    result = dmDataReader.GetDateTime(columnIndex);\n                }\n                return result;\n            }\n            catch (Exception ex)\n            {\n                throw ex;\n            }\n            finally\n            {\n                dmDataReader.Close();\n            }\n        }\n\n        /// <summary>\n        /// 获取指定列的 Decimal 对象形式的值\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"columnIndex\"></param>\n        /// <returns></returns>\n        public static decimal GetDecimal(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, int columnIndex = 0)\n        {\n            decimal result = default;\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            var dmDataReader = (DmDataReader)dbCommand.ExecuteReader();\n            try\n            {\n                while (dmDataReader.Read())\n                {\n                    result = dmDataReader.GetDecimal(columnIndex);\n                }\n                return result;\n            }\n            catch (Exception ex)\n            {\n                throw ex;\n            }\n            finally\n            {\n                dmDataReader.Close();\n            }\n        }\n\n        /// <summary>\n        /// 返回一个 DataTable，它描述 DmDataReader 的列元数据\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <returns></returns>\n        public static DataTable GetDataTable(this DbProviderFactory dbProviderFactory, DbCommand dbCommand)\n        {\n            DataTable result = new DataTable();\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            var dmDataReader = (DmDataReader)dbCommand.ExecuteReader();\n            try\n            {\n                while (dmDataReader.Read())\n                {\n                    result = dmDataReader.GetSchemaTable();\n                }\n                return result;\n            }\n            catch (Exception ex)\n            {\n                throw ex;\n            }\n            finally\n            {\n                dmDataReader.Close();\n            }\n        }\n\n        /// <summary>\n        /// 获取指定列的字符串形式的值\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"columnIndex\"></param>\n        /// <returns></returns>\n        public static string GetString(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, int columnIndex = 0)\n        {\n            string result = string.Empty;\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            var dmDataReader = (DmDataReader)dbCommand.ExecuteReader();\n            try\n            {\n                while (dmDataReader.Read())\n                {\n                    result = dmDataReader.GetString(columnIndex);\n                }\n                return result;\n            }\n            catch (Exception ex)\n            {\n                throw ex;\n            }\n            finally\n            {\n                dmDataReader.Close();\n            }\n        }\n\n        /// <summary>\n        /// 查询并返回 DataSet 结果集\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <returns></returns>\n        public static DataSet ExecuteDataSet(this DbProviderFactory dbProviderFactory, DbCommand dbCommand)\n        {\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            DataSet dataSet = new DataSet();\n            dataSet.Locale = CultureInfo.InvariantCulture;\n            var tableNames = new string[] { \"Table\" };\n            using (var dmDataAdapter = CustomDatabaseFactory.GetDmDataAdapter((DmCommand)dbCommand))\n            {\n                try\n                {\n                    string text = \"Table\";\n                    for (int j = 0; j < tableNames.Length; j++)\n                    {\n                        string sourceTable = (j == 0) ? text : (text + j);\n                        dmDataAdapter.TableMappings.Add(sourceTable, tableNames[j]);\n                    }\n                    dmDataAdapter.Fill(dataSet);\n                }\n                catch (Exception ex)\n                {\n                    throw ex;\n                }\n            }\n            return dataSet;\n        }\n\n        /// <summary>\n        /// 新增、插入、删除，支持事务\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"dbTransaction\">事务对象</param>\n        /// <returns></returns>\n        public static int ExecuteNonQuery(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, DbTransaction dbTransaction = null)\n        {\n            if (dbTransaction != null)\n            {\n                dbCommand.Transaction = dbTransaction;\n                dbCommand.Connection = dbTransaction.Connection;\n            }\n            dbProviderFactory.ConfigureDbConnectionToDbCommand(dbCommand);\n            return dbCommand.ExecuteNonQuery();\n        }\n\n        /// <summary>\n        /// 设置参数\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"name\">参数名</param>\n        /// <param name=\"dbType\">参数类型</param>\n        /// <param name=\"value\">参数值</param>\n        public static void AddInParameter(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, string name, DbType dbType, object value)\n        {\n            var dbParameter = ConfigureParameter(name, dbType, value);\n            dbCommand.Parameters.Add(dbParameter);\n        }\n        /// <summary>\n        /// 创建 DmParameter 对象\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"dbType\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns></returns>\n        public static DmParameter ConfigureParameter(string name, DbType dbType, object value)\n        { \n            return ConfigureParameter(name, dbType, 0, ParameterDirection.Input, false, 0, 0, string.Empty, DataRowVersion.Default, value);\n        }\n        /// <summary>\n        /// 创建 DmParameter 对象\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"dbType\"></param>\n        /// <param name=\"size\"></param>\n        /// <param name=\"direction\"></param>\n        /// <param name=\"nullable\"></param>\n        /// <param name=\"precision\"></param>\n        /// <param name=\"scale\"></param>\n        /// <param name=\"sourceColumn\"></param>\n        /// <param name=\"sourceVersion\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns></returns>\n        public static DmParameter ConfigureParameter(string name, DbType dbType, int size, ParameterDirection direction, bool nullable, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, object value)\n        {\n            DmParameter dmParameter = new DmParameter();\n            dmParameter.ParameterName = name;\n            dmParameter.DbType = dbType;\n            dmParameter.Size = size;\n            dmParameter.Direction = direction;\n            dmParameter.IsNullable = nullable;\n            dmParameter.Precision = precision;\n            dmParameter.Scale = scale;\n            dmParameter.SourceColumn = sourceColumn;\n            dmParameter.SourceVersion = sourceVersion;\n            dmParameter.Value = value ?? DBNull.Value;\n            return dmParameter;\n        }\n\n        /// <summary>\n        /// 创建数据库连接\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"open\">默认是否打开</param>\n        /// <returns></returns>\n        public static DbConnection CreateDbConnection(this DbProviderFactory dbProviderFactory, bool open = false)\n        { \n            return CustomDatabaseFactory.CreateConnection(dbProviderFactory, open);\n        }\n\n        /// <summary>\n        /// 设置 DbCommand 的数据库连接对象\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"dbCommand\"></param>\n        /// <param name=\"open\"></param>\n        public static void ConfigureDbConnectionToDbCommand(this DbProviderFactory dbProviderFactory, DbCommand dbCommand, bool open = true)\n        {\n            if (dbCommand.Connection == null)\n            {\n                dbCommand.Connection = dbProviderFactory.CreateDbConnection(open);\n            }\n        }\n    }\n}\n```\n2、修改`CustomDatabaseFactory`类\n```\nusing Dm;\nusing System.Configuration;\nusing System.Data;\nusing System.Data.Common;\n\nnamespace Infrastructure.Dal\n{\n    public class CustomDatabaseFactory \n    {\n        static ConnectionStringSettings _dmConnectionString = ConfigurationManager.ConnectionStrings[\"Dm\"];\n        static DbProviderFactory _dbProviderFactory;\n        private static object _lockobj = new object();\n        /// <summary>\n        /// 创建数据库连接\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"open\">默认打开</param>\n        /// <returns></returns>\n        public static DbConnection CreateConnection(DbProviderFactory dbProviderFactory, bool open = true)\n        {\n            DbConnection dbConnection = dbProviderFactory.CreateConnection();\n            dbConnection.ConnectionString = _dmConnectionString.ConnectionString;\n            if (open)\n            {\n                dbConnection.Open();\n            }\n            return dbConnection;\n        }\n        /// <summary>\n        /// 创建 DbCommand 对象\n        /// </summary>\n        /// <param name=\"dbProviderFactory\"></param>\n        /// <param name=\"commandText\">Sql 语句或者 存储过程</param>\n        /// <param name=\"commandType\">类型</param>\n        /// <returns></returns>\n        public static DbCommand CreateDbCommand(DbProviderFactory dbProviderFactory, string commandText, CommandType commandType)\n        {\n            DbCommand dbCommand = dbProviderFactory.CreateCommand();\n            dbCommand.CommandText = commandText;\n            dbCommand.CommandType = commandType;\n            return dbCommand;\n        }\n\n        public static DbProviderFactory CreateDatabase()\n        {\n            if (_dbProviderFactory != null)\n            {\n                return _dbProviderFactory;\n            }\n            lock (_lockobj)\n            {\n                if (_dbProviderFactory != null)\n                {\n                    return _dbProviderFactory;\n                }\n                _dbProviderFactory = DbProviderFactories.GetFactory(\"Dm\");\n                return _dbProviderFactory;\n            }\n        }\n\n        public static DmDataAdapter GetDmDataAdapter(DmCommand dmCommand)\n        {\n            return new DmDataAdapter(dmCommand);\n        }\n    }\n}\n```\n3、替换`Database`为`var`\n4、修改`BaseDal`类\n- 将`BaseDal`中`OracleParameter`修改为`DmParameter`；\n- 将`BaseDal`中`OracleType`修改为`DmDbType`；\n\n5、修改开启事务前创建数据库连接方式\n- 将`using (DbConnection conn = db.CreateConnection())`修改为\n    `using (DbConnection conn = db.CreateDbConnection())`\n\n6、移除引用\n- 将所有C#代码头部的`using Microsoft.Practices.EnterpriseLibrary.Data;`引用移除\n\n7、修改`Web.config`\n```\n<connectionStrings>\n  <add name=\"Dm\" connectionString=\"server=192.168.1.75;port=5236;user=GZZOBL;password=GZZOBL123456;commandTimeout=60;\"/>\n</connectionStrings>\n```\n\n\n', '', 0, 0, 12, 0, 0, 0, 1662342191216, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70', '::ffff:172.17.0.1', 1662342191216, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (61, 0, 7, 2, 'SqlSugar 库表操作', '借助`DbMaintenance`完成如创建表、字段、索引、字段描述等操作；\n\n> 注意：用查询方法时看有没有 isCache重载， true是走缓存,false是不走缓存\n\n------------------------------------\n- GetTableInfoList - 获取所有表信息\n```\nList<DbTableInfo> GetTableInfoList(bool isCache = true);\n```\n\n- GetColumnInfosByTableName - 根据表名获取字段信息\n```\nList<DbColumnInfo> GetColumnInfosByTableName(string tableName, bool isCache = true);\n```\n\n- GetIsIdentities - 获取自增列\n```\nList<string> GetIsIdentities(string tableName);\n```\n\n- GetPrimaries - 获取主键\n```\nList<string> GetPrimaries(string tableName);\n```\n\n- IsAnyTable - 判断表存不存在\n```\nbool IsAnyTable(string tableName, bool isCache = true);\n```\n\n- IsAnyColumn - 列是否存在\n```\nbool IsAnyColumn(string tableName, string column, bool isCache = true);\n```\n\n- IsPrimaryKey - 主键是否存在\n```\nbool IsPrimaryKey(string tableName, string column);\nbool IsPrimaryKey(string tableName, string column, bool isCache = true);\n```\n\n- IsIdentity - 自增是否存在\n```\nbool IsIdentity(string tableName, string column);\n```\n\n- IsAnyConstraint - 约束是否存在\n```\nbool IsAnyConstraint(string ConstraintName);\n```\n\n- DropTable - 删除表\n```\nbool DropTable(string tableName);\n```\n\n- TruncateTable - 清空表\n```\nbool TruncateTable(string tableName);\n```\n\n- CreateTable - 创建表\n```\nbool CreateTable(string tableName, List<DbColumnInfo> columns, bool isCreatePrimaryKey = true);\n```\n\n- AddColumn - 添加列\n```\nbool AddColumn(string tableName, DbColumnInfo column);\n```\n\n- UpdateColumn - 更新列\n```\nbool UpdateColumn(string tableName, DbColumnInfo column);\n```\n\n- AddPrimaryKey - 添加主键\n```\nbool AddPrimaryKey(string tableName, string columnName);\nbool AddPrimaryKeys(string tableName, string[] columnNames);\nbool AddPrimaryKeys(string tableName, string[] columnNames, string pkName);\n```\n\n- DropConstraint - 删除约束\n```\nbool DropConstraint(string tableName, string constraintName);\n```\n\n- DropColumn - 删除列\n```\nbool DropColumn(string tableName, string columnName);\n```\n\n- RenameColumn - 重命名列\n```\nbool RenameColumn(string tableName, string oldColumnName, string newColumnName);\n```\n\n- AddTableRemark - 添加表描述\n```\nbool AddTableRemark(string tableName, string description);\n```\n\n- AddColumnRemark - 添加列描述\n```\nbool AddColumnRemark(string columnName, string tableName, string description);\n```\n\n- DeleteColumnRemark - 删除列描述\n```\nbool DeleteColumnRemark(string columnName, string tableName);\n```\n\n- RenameTable - 重命名表\n```\nbool RenameTable(string oldTableName, string newTableName);\n```\n\n- CreateIndex - 创建索引\n```\nbool CreateIndex(string tableName, string[] columnNames, bool isUnique = false);\nbool CreateIndex(string tableName, string[] columnNames, string IndexName, bool isUnique = false);\n```\n\n- IsAnyIndex - 索引是否存在\n```\nbool IsAnyIndex(string indexName);\n```\n\n------------------------------------\n- DbTableInfo\n```\n    public class DbTableInfo\n    {\n        public string Name\n        {\n            get;\n            set;\n        }\n\n        public string Description\n        {\n            get;\n            set;\n        }\n\n        public DbObjectType DbObjectType\n        {\n            get;\n            set;\n        }\n    }\n    public enum DbObjectType\n    {\n        Table,\n        View,\n        All\n    }\n```\n\n- DbColumnInfo\n```\n    public class DbColumnInfo\n    {\n        public string TableName\n        {\n            get;\n            set;\n        }\n\n        public int TableId\n        {\n            get;\n            set;\n        }\n\n        public string DbColumnName\n        {\n            get;\n            set;\n        }\n\n        public string PropertyName\n        {\n            get;\n            set;\n        }\n\n        public string DataType\n        {\n            get;\n            set;\n        }\n\n        public Type PropertyType\n        {\n            get;\n            set;\n        }\n\n        public int Length\n        {\n            get;\n            set;\n        }\n\n        public string ColumnDescription\n        {\n            get;\n            set;\n        }\n\n        public string DefaultValue\n        {\n            get;\n            set;\n        }\n\n        public bool IsNullable\n        {\n            get;\n            set;\n        }\n\n        public bool IsIdentity\n        {\n            get;\n            set;\n        }\n\n        public bool IsPrimarykey\n        {\n            get;\n            set;\n        }\n\n        public object Value\n        {\n            get;\n            set;\n        }\n\n        public int DecimalDigits\n        {\n            get;\n            set;\n        }\n\n        public int Scale\n        {\n            get;\n            set;\n        }\n\n        public bool IsArray\n        {\n            get;\n            set;\n        }\n\n        public bool IsJson\n        {\n            get;\n            set;\n        }\n\n        public bool? IsUnsigned\n        {\n            get;\n            set;\n        }\n\n        public int CreateTableFieldSort\n        {\n            get;\n            set;\n        }\n\n        internal object SqlParameterDbType\n        {\n            get;\n            set;\n        }\n    }\n```', '', 0, 0, 12, 0, 1, 0, 1662535147090, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.70', '::ffff:172.17.0.1', 1662535147090, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (62, 0, 7, 2, '.NET Standard', '.NET Standard 是针对多个 .NET 实现推出的一套正式的 .NET API 规范。 推出 .NET Standard 的背后动机是要提高 .NET 生态系统中的一致性。 .NET 5 及更高版本采用不同的方法来建立一致性，这种方法在大多数情况下都不需要 .NET Standard。 但如果要在 .NET Framework 和其他任何 .NET 实现（例如 .NET Core）之间共享代码，则库必须面向 .NET Standard 2.0。 [不会发布新版本的 .NET Standard](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/)，但 .NET 5、.NET 6 以及所有将来的版本将继续支持 .NET Standard 2.1 及更早版本。\n\n有关如何在 .NET 5+ 和 .NET Standard 之间选择的信息，请参阅本文后面的 [.NET 5+ 和 .NET Standard](about:blank#net-5-and-net-standard)。\n\n.NET Standard 版本\n----------------\n\n已对 .NET Standard 进行版本控制。 每个新版本都会添加更多 API。 当库是针对 .NET Standard 的某个版本生成时，它可以在任何实现该版本（或更高版本）的 .NET Standard 的 .NET 实现上运行。\n\n面向更高版本的 .NET Standard让库能够使用更多 API，但这意味着它只能在较新版本的 .NET 上使用。 面向较低版本会减少可用的 API，但意味着库可以在更多位置运行。\n\n### 选择 .NET Standard 版本\n\n*   [1.0](about:blank#tabpanel_1_net-standard-1-0)\n*   [1.1](about:blank#tabpanel_1_net-standard-1-1)\n*   [1.2](about:blank#tabpanel_1_net-standard-1-2)\n*   [1.3](about:blank#tabpanel_1_net-standard-1-3)\n*   [1.4](about:blank#tabpanel_1_net-standard-1-4)\n*   [1.5](about:blank#tabpanel_1_net-standard-1-5)\n*   [1.6](about:blank#tabpanel_1_net-standard-1-6)\n*   [2.0](about:blank#tabpanel_1_net-standard-2-0)\n*   [2.1](about:blank#tabpanel_1_net-standard-2-1)\n\n.NET Standard 1.0 提供 37,118 个可用 API 中的 7,949 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework | 4.5、4.5.1、4.5.2、4.6、4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 8.0、8.1、10.0、10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n有关详细信息，请参阅 [.NET Standard 1.0](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.0.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.1 提供 37,118 个可用 API 中的 10,239 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework | 4.5、4.5.1、4.5.2、4.6、4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 8.0、8.1、10.0、10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n有关详细信息，请参阅 [.NET Standard 1.1](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.1.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.2 提供 37,118 个可用 API 中的 10,285 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework | 4.5.1、4.5.2、4.6、4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 8.1、10.0、10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n有关详细信息，请参阅 [.NET Standard 1.2](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.2.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.3 提供 37,118 个可用 API 中的 13,122 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework | 4.6、4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 10.0、10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n有关详细信息，请参阅 [.NET Standard 1.3](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.3.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.4 提供 37,118 个可用 API 中的 13,140 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework | 4.6.1、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 10.0、10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n有关详细信息，请参阅 [.NET Standard 1.4](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.4.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.5 提供 37,118 个可用 API 中的 13,355 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework 1 | 4.6.1 2、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n1 针对 .NET framework 列出的版本适用于 .NET Core 2.0 SDK 和更高版本的工具。 旧版本对 .NET Standard 1.5 及更高版本使用了不同映射。 如果无法升级到 Visual Studio 2017 或更高版本，可[下载适用于 Visual Studio 2015 的 .NET Core 工具](https://github.com/dotnet/core/blob/main/release-notes/download-archives)。\n\n2 此处所列的版本表示 NuGet 用于确定给定 .NET Standard 库是否适用的规则。 虽然 NuGet 将 .NET Framework 4.6.1 视为支持 .NET Standard 1.5 到 2.0，但使用为从 .NET Framework 4.6.1 项目构建的 .NET Standard 库存在一系列问题。 对于需要使用此类库的 .NET Framework 项目，建议将项目升级到面向 .NET Framework 4.7.2 或更高版本。\n\n有关详细信息，请参阅 [.NET Standard 1.5](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.5.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 1.6 提供 37,118 个可用 API 中的 13,501 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 1.0、1.1、2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework 1 | 4.6.1 2、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 4.6、5.4、6.4 |\n| Xamarin.iOS | 10.0、10.14、12.16 |\n| Xamarin.Mac | 3.0、3.8、5.16 |\n| Xamarin.Android | 7.0、8.0、10.0 |\n| 通用 Windows 平台 | 10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n1 针对 .NET framework 列出的版本适用于 .NET Core 2.0 SDK 和更高版本的工具。 旧版本对 .NET Standard 1.5 及更高版本使用了不同映射。 如果无法升级到 Visual Studio 2017 或更高版本，可[下载适用于 Visual Studio 2015 的 .NET Core 工具](https://github.com/dotnet/core/blob/main/release-notes/download-archives)。\n\n2 此处所列的版本表示 NuGet 用于确定给定 .NET Standard 库是否适用的规则。 虽然 NuGet 将 .NET Framework 4.6.1 视为支持 .NET Standard 1.5 到 2.0，但使用为从 .NET Framework 4.6.1 项目构建的 .NET Standard 库存在一系列问题。 对于需要使用此类库的 .NET Framework 项目，建议将项目升级到面向 .NET Framework 4.7.2 或更高版本。\n\n有关详细信息，请参阅 [.NET Standard 1.6](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard1.6.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 2.0 提供 37,118 个可用 API 中的 32,638 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 2.0、2.1、2.2、3.0、3.1、5.0、6.0 |\n| .NET Framework 1 | 4.6.1 2、4.6.2、4.7、4.7.1、4.7.2、4.8 |\n| Mono | 5.4、6.4 |\n| Xamarin.iOS | 10.14、12.16 |\n| Xamarin.Mac | 3.8、5.16 |\n| Xamarin.Android | 8.0、10.0 |\n| 通用 Windows 平台 | 10.0.16299，待定 |\n| Unity | 2018 年 1 月 |\n\n1 针对 .NET framework 列出的版本适用于 .NET Core 2.0 SDK 和更高版本的工具。 旧版本对 .NET Standard 1.5 及更高版本使用了不同映射。 如果无法升级到 Visual Studio 2017 或更高版本，可[下载适用于 Visual Studio 2015 的 .NET Core 工具](https://github.com/dotnet/core/blob/main/release-notes/download-archives)。\n\n2 此处所列的版本表示 NuGet 用于确定给定 .NET Standard 库是否适用的规则。 虽然 NuGet 将 .NET Framework 4.6.1 视为支持 .NET Standard 1.5 到 2.0，但使用为从 .NET Framework 4.6.1 项目构建的 .NET Standard 库存在一系列问题。 对于需要使用此类库的 .NET Framework 项目，建议将项目升级到面向 .NET Framework 4.7.2 或更高版本。\n\n有关详细信息，请参阅 [.NET Standard 2.0](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard2.0.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n.NET Standard 2.1 提供 37,118 个可用 API 中的 37,118 个。\n\n| .NET 实现 | 版本支持 |\n| --- | --- |\n| .NET 和.NET Core | 3.0、3.1、5.0、6.0 |\n| .NET Framework 1 | N/A2 |\n| Mono | 6.4 |\n| Xamarin.iOS | 12.16 |\n| Xamarin.Mac | 5.16 |\n| Xamarin.Android | 10.0 |\n| 通用 Windows 平台 | 待定 |\n| Unity | 2021.2 |\n\n1 针对 .NET framework 列出的版本适用于 .NET Core 2.0 SDK 和更高版本的工具。 旧版本对 .NET Standard 1.5 及更高版本使用了不同映射。 如果无法升级到 Visual Studio 2017 或更高版本，可[下载适用于 Visual Studio 2015 的 .NET Core 工具](https://github.com/dotnet/core/blob/main/release-notes/download-archives)。\n\n2 .NET Framework 不支持 .NET Standard 2.1。 有关详细信息，请参阅 [.NET Standard 2.1 公告](https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-1/)。\n\n有关详细信息，请参阅 [.NET Standard 2.1](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard2.1.md)。 有关交互式表的信息，请参阅 [.NET Standard 版本](https://dotnet.microsoft.com/platform/dotnet-standard#versions)。\n\n### 要定位哪个 .NET Standard 版本\n\n建议定位 .NET Standard 2.0，除非你需要支持早期版本。 最常规用途的库应该不需要除 .NET Standard 2.0 之外的其他 API。 所有新式平台都支持 .NET Standard 2.0，并且它是支持具有一个目标的多个平台的推荐方法。\n\n如果需要定位 .NET Standard 1.x，建议还定位 .NET Standard 2.0。 .NET Standard 1.x 作为一组精细的 NuGet 包分发，它创建了一个大型的包依赖项关系图，并导致开发人员在构建时下载大量的包。 有关详细信息，请参阅本文后续部分的[跨平台定位](https://docs.microsoft.com/library-guidance/cross-platform-targeting)和 [.NET 5+ 和 .NET Standard](about:blank#net-5-and-net-standard)。\n\n### .NET Standard 版本控制规则\n\n版本控制规则主要有两个：\n\n*   累加性：.NET Standard 版本在逻辑上形成同心圆。也就是说，较高的版本包含较低版本的所有 API。 版本之间没有重大更改。\n*   不可变：一旦发布，.NET Standard 版本就会冻结起来。\n\n在 .NET Standard 2.1 版本之后，将不会有新版本。 有关详细信息，请参阅本文后续部分的 [.NET 5+ 和 .NET Standard](about:blank#net-5-and-net-standard)。\n\n规范\n--\n\n.NET Standard 规范是一组标准化的 API。 此规范由 .NET 实现者（具体而言，由 Microsoft（包括 .NET Framework、NET Core 和 Mono）和 Unity）进行维护。\n\n### 正式项目\n\n正式规范是一组用于定义标准中包含的 API 的 .cs 文件。 （现已存档的）[dotnet/standard 存储库](https://github.com/dotnet/standard)中的 [Ref 目录](https://github.com/dotnet/standard/tree/v2.1.0/src/netstandard/ref)定义了 .NET Standard API。\n\n[NETStandard.Library](https://www.nuget.org/packages/NETStandard.Library) 元包（[源代码](https://github.com/dotnet/standard/blob/v2.1.0/src/netstandard/pkg/NETStandard.Library.dependencies.props)）描述用于部分定义一个或多个 .NET Standard 版本的库集。\n\n给定的组件（如 `System.Runtime`）描述：\n\n*   .NET Standard 的一部分（即其范围）。\n*   .NET Standard 在此范围内的多个版本。\n\n标准库提供派生项目以方便读取，并实现某些开发人员方案（例如，使用编译器）。\n\n*   [Markdown 中的 API 列表](https://github.com/dotnet/standard/tree/v2.1.0/docs/versions)。\n*   引用程序集，以 NuGet 包的形式分发，由 [NETStandard.Library](https://www.nuget.org/packages/NETStandard.Library/) 元包引用。\n\n### 包表示形式\n\n.NET Standard 引用程序集的主要分发载体是 NuGet 包。 实现会以适用于每个 .NET 实现的各种方式提供。\n\nNuGet 包面向一个或多个[框架](https://docs.microsoft.com/frameworks)。 .NET Standard 包面向“.NET Standard”框架。 可以使用 `netstandard`[精简 TFM](https://docs.microsoft.com/frameworks)（例如 `netstandard1.4`）来设定 .NET Standard 框架作为目标。 计划在多个 .NET 实现上运行的库应将此框架作为目标。 对于最广泛的 API 集，将 `netstandard2.0` 设定为目标，因为 .NET Standard 2.0 的可用 API 数量比 .NET Standard 1.6 的两倍还多。\n\n[`NETStandard.Library`](https://www.nuget.org/packages/NETStandard.Library/) 元包引用定义 .NET Standard 的一整套 NuGet 包。 要指定 `netstandard` 作为目标，最常见的方法是引用此元包。 它描述并提供了对大约 40 个 .NET 库及定义 .Net Standard 的相关 API 的访问权限。 可以引用以 `netstandard` 为目标的其他包来使用其他 API。\n\n### 版本管理\n\n规范并不是单一的，而是一组以线性方式进行版本控制的 API。 该标准的第一个版本建立了一组基准 API。 后续版本将添加 API，并继承以前的版本定义的 API。 在从 Standard 中移除 API 方面，并没有成文的规定。\n\n.NET Standard 并不特定于任何一种 .NET 实现，也不与其中任一实现的版本控制方案匹配。\n\n如前所述，在 .NET Standard 2.1 版本之后，将不会有新版本。\n\n定位 .NET Standard\n----------------\n\n可以结合使用 `netstandard` 框架和 `NETStandard.Library` 元包来[构建 .NET Standard 库](https://docs.microsoft.com/core/tutorials/libraries)。\n\n.NET Framework 兼容性模式\n--------------------\n\n从 .NET Standard 2.0 开始，引入了 .NET Framework 兼容性模式。 此兼容性模式允许 .NET Standard 项目引用 .NET Framework 库，就像其针对 .NET Standard 编译一样。 引用 .NET Framework 库并不适用于所有项目，，例如使用 Windows Presentation Foundation (WPF) API 的库。\n\n有关详细信息，请参阅 [.NET Framework兼容性模式](https://docs.microsoft.com/core/porting/third-party-deps#net-framework-compatibility-mode)。\n\n.NET Standard 库和 Visual Studio\n------------------------------\n\n要在 Visual Studio 中生成 .NET Standard 库，请确保 Windows 上已安装 [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2022)、[Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) 或 Visual Studio 2017 版本 15.3 或更高版本，或 macOS 上已安装 [Visual Studio for Mac 版本 7.1](https://visualstudio.microsoft.com/vs/mac/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link) 或更高版本。\n\n如果项目中只需使用 .NET Standard 2.0 库，也可在 Visual Studio 2015 中执行此操作。 但是需要安装 NuGet client 3.6 或更高版本。 可从 [NuGet 下载](https://www.nuget.org/downloads)页面下载适用于 Visual Studio 2015 的 NuGet 客户端。\n\n.NET 5+ 和 .NET Standard\n-----------------------\n\n.NET 5 和 .NET 6 是具有一组统一功能和 API 的单一产品，可用于 Windows 桌面应用和跨平台控制台应用、云服务和网站。 例如，.NET 5.0 [TFM](https://docs.microsoft.com/frameworks) 反映了以下广泛的应用场景：\n\n*   `net5.0`\n    \n    此 TFM 适用于在任何位置运行的代码。 它仅包括跨平台工作的技术（少数例外情况除外）。 对于 .NET 5 代码，`net5.0` 替换了 `netcoreapp` 和 `netstandard` TFM。\n    \n*   `net5.0-windows`\n    \n    这是一个[特定于 OS 的 TFM](https://docs.microsoft.com/frameworks#net-5-os-specific-tfms) 的示例，该 TFM 可向 `net5.0` 引用的所有内容添加特定于 OS 的功能。\n    \n\n### 以 net5.0 或 net6.0 为目标与以 netstandard 为目标的情形\n\n对于以 `netstandard` 为目标的现有代码，无需将 TFM 更改为 `net5.0` 或 `net6.0`。 .NET 5 和 .NET 6 可实现 .NET Standard 2.1 及更早版本。 将目标从 .NET Standard 更改为 .NET 5+ 的唯一原因是获取对更多运行时功能、语言功能或 API 的访问权限。 例如，为了使用 C# 9，需要以 .NET 5 或更高版本为目标。 可同时以 .NET 5 或 .NET 6 和 .NET Standard 为目标来访问较新的功能，并仍然可让库供其他 .NET 实现使用。\n\n下面是适用于 .NET 5+ 新代码的一些准则：\n\n*   应用组件\n    \n    如果你是使用库将应用程序分解为多个组件，我们建议以 `net5.0` 或 `net6.0` 为目标。 为简单起见，最好在同一 .NET 版本中保留构成应用程序的所有项目。 然后，可以假设任何位置均具有相同的 BCL 功能。\n    \n*   可重用的库\n    \n    如果要构建计划在 NuGet 上发布的可重用的库，请考虑在覆盖范围和可用功能集之间进行权衡。 .NET Standard 2.0 是 .NET Framework 支持的最新版本，因此它具有相当大的功能集，可提供良好的覆盖范围。 我们建议你不要以 .NET Standard 1.x 作为目标，因为这样会限制可用的功能集，使覆盖范围的增幅降至最低。\n    \n    如果你不需要支持 .NET Framework，可以选择 .NET Standard 2.1 或 .NET 5/6。 我们建议跳过 .NET Standard 2.1，直接选择 .NET 6。 大多数广泛使用的库都将同时面向 .NET Standard 2.0 和 .NET 5+。 支持 .NET Standard 2.0 可提供最大的覆盖范围，而支持 .NET 5+ 可确保你可以为已使用 .NET 5+ 的客户利用最新的平台功能。\n    \n\n### .NET Standard 的问题\n\n下面是一些关于 .NET Standard 的问题，这些问题有助于解释为什么最好使用 .NET 5 及更高版本来跨平台和工作负载共享代码：\n\n*   添加新 API 的速度缓慢\n    \n    .NET Standard 是作为所有 .NET 实现都必须支持的 API 集创建的，因此会对添加新 API 的建议进行审核。 目标是仅标准化可在所有当前和未来的 .NET 平台中实现的 API。 因此，如果某个功能错过了特定版本，则你可能需要等待几年，该功能才会被添加到 Standard 版本中。 然后，你需要等待更长的时间，新版本的 .NET Standard 才能受到广泛支持。\n    \n    .NET 5+ 中的解决方案：实现某项功能时，该功能便已可供所有 .NET 5+ 应用和库使用，因为代码基底是共享的。 由于 API 规范与其实现之间没有区别，因此相较于使用 .NET Standard，你可以更快地利用新功能。\n    \n*   复杂的版本控制\n    \n    API 规范与其实现的分离导致 API 规范版本与实现版本之间出现复杂的映射。 这种复杂性在本文前面显示的表以及其解释方式说明中显而易见。\n    \n    .NET 5+ 中的解决方案：.NET 5+ API 规范与其实现之间不存在任何分离。 由此实现了一个简化的 TFM 方案。 提供了一个适用于所有工作负载的 TFM 前缀：`net5.0` 或 `net6.0` 用于库、控制台应用和 Web 应用。 唯一的变化是针对特定平台[指定特定于平台的 API 的后缀](https://docs.microsoft.com/frameworks#net-5-os-specific-tfms)，例如 `net5.0-windows` 或 `net6.0-windows`。 由于此 TFM 命名约定，你可以轻松判断给定应用是否可以使用给定的库。 不需要版本号等效表（如 .NET Standard 的版本号等效表）。\n    \n*   运行时出现不受平台支持的异常\n    \n    .NET Standard 公开了特定于平台的 API。 代码在编译时可能不会出错，并且看起来可以移植到任何平台（即该代码不可移植也是如此）。 当它在不具有给定 API 实现的平台上运行时，会出现运行时错误。\n    \n    .NET 5+ 中的解决方案：.NET 5+ SDK 包括默认启用的代码分析器。 平台兼容性分析器会检测对你打算在其上运行的平台所不支持的 API 的意外使用情况。 有关详细信息，请参阅[平台兼容性分析器](https://docs.microsoft.com/analyzers/platform-compat-analyzer)。\n    \n\n### 未弃用 .NET Standard\n\n对于可由多个 .NET 实现使用的库，仍需要 .NET Standard。 在以下情况下，建议以 .NET Standard 作为目标：\n\n*   使用 `netstandard2.0` 在 .NET Framework 和 .NET 的所有其他实现之间共享代码。\n*   使用 `netstandard2.1` 在 Mono、Xamarin 和 .NET Core 3.x 之间共享代码。\n\n另请参阅\n----\n\n*   [.NET Standard 版本（源）](https://github.com/dotnet/standard/blob/v2.1.0/docs/versions.md)\n*   [.NET Standard 版本（交互式 UI）](https://dotnet.microsoft.com/platform/dotnet-standard#versions)\n*   [生成 .NET Standard 库](https://docs.microsoft.com/core/tutorials/library-with-visual-studio)\n*   [跨平台定位](https://docs.microsoft.com/library-guidance/cross-platform-targeting)\n', '', 0, 0, 7, 0, 0, 0, 1663146282704, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.33', '::ffff:172.17.0.1', 1663146282704, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (63, 0, 7, 2, 'FreeRedis 历时两年正式发布 v1.0 [C#.NET Redis Client]', '💻 前言\n-----\n\n.NET 下 RedisClient SDK 选择挺多，国人常用免费的有 StackExchange.Redis/CSRedis/Newlife.Redis，收费的有 ServiceStack.Redis。\n\n如果你是 CSRedis 或 ServiceStack.Redis 粉，那么一定要不要错过关注 FreeRedis，它们的 API 非常相似，方法名、参数与 redis.io 官方命令文档保持一致，避免了二次转换的理解成本。 redis 命令可是有接近300个呢~~~\n\n提示：CSRedisCore 与 FreeRedis 是同一个作者，后者是基于 redis6.0 特性重新打造，解决了 CSRedisCore 的一些老问题，扩展性更强。\n\n* * *\n\n🌳 开源理念\n-------\n\nFreeRedis 的命名来自，“自由”、“免费”，它和名字与 FreeSql 是一个理念，简易是他们一致的追寻方向，最低可支持 .NET Framework 4.0 运行环境，支持到 Redis-server 8.0（超时空版本）。\n\n开源地址：[https://github.com/2881099/FreeRedis](https://github.com/2881099/FreeRedis)\n\nFreeRedis 以**最宽松的开源协议** MIT 开源，从第一个版本 v0.0.1 发布至今已有 22个月，时间验证了其可靠性，是时候正式发布 v1.0 版本公开给大家，大家做 .neter 不容易，多一个选择多一条路。\n\n> 由于之前异步方法的优化一直未开放，v1.0 正式开放异步方法\n\nFreeRedis 整个源码是**零依赖**，使用它只会在 bin 目录产生一个 FreeRedis.dll，非常的轻量级，并且其功能非常强大：\n\n* * *\n\n🦄 FreeRedis\n============\n\n基于 .NET 的 Redis 客户端，支持 .NET Core 2.1+、.NET Framework 4.0+ 以及 Xamarin。\n\n*   🌈 所有方法名与 redis-cli 保持一致\n*   🌌 支持 Redis 集群（服务端要求 3.2 及以上版本）\n*   ⛳ 支持 Redis 哨兵模式\n*   🎣 支持主从分离（Master-Slave）\n*   📡 支持发布订阅（Pub-Sub）\n*   📃 支持 Redis Lua 脚本\n*   💻 支持管道（Pipeline）\n*   📰 支持事务、命令拦截、日志事件\n*   🌴 支持 GEO 命令（服务端要求 3.2 及以上版本）\n*   🌲 支持 STREAM 类型命令（服务端要求 5.0 及以上版本）\n*   ⚡ 支持本地缓存（Client-side-cahing，服务端要求 6.0 及以上版本）\n*   🌳 支持 Redis 6 的 RESP3 协议\n\nQQ群：4336577(已满)、8578575(在线)、52508226(在线)\n\n* * *\n\n🚀 快速入门\n-------\n\n```\npublic static RedisClient cli = new RedisClient(\"127.0.0.1:6379,password=123,defaultDatabase=13\");\ncli.Serialize = obj => JsonConvert.SerializeObject(obj); //序列化，存对象\ncli.Deserialize = (json, type) => JsonConvert.DeserializeObject(json, type);\ncli.Notice += (s, e) => Console.WriteLine(e.Log); //打印命令日志\n\ncli.Set(\"key1\", \"value1\");\ncli.MSet(\"key1\", \"value1\", \"key2\", \"value2\");\n\nstring value1 = cli.Get(\"key1\");\nstring[] vals = cli.MGet(\"key1\", \"key2\");\n\n```\n\n> 支持 STRING、HASH、LIST、SET、ZSET、BITMAP、HyperLogLog、GEO、Stream、RedisJSON 以及布隆过滤器等。\n\n| 参数 | 默认值 | 说明 |\n| --- | --- | --- |\n| protocol | RESP2 | 若使用 RESP3 协议，你需要 Redis 6.0 环境 |\n| user | <empty> | Redis 服务端用户名，要求 Redis 6.0 环境 |\n| password | <empty> | Redis 服务端密码 |\n| defaultDatabase | 0 | Redis 服务端数据库 |\n| max poolsize | 100 | 连接池最大连接数 |\n| min poolsize | 5 | 连接池最小连接数 |\n| idleTimeout | 20000 | 连接池中元素的空闲时间（单位为毫秒 ms），适用于连接到远程服务器 |\n| connectTimeout | 10000 | 连接超时，单位为毫秒（ms） |\n| receiveTimeout | 10000 | 接收超时，单位为毫秒（ms） |\n| sendTimeout | 10000 | 发送超时，单位为毫秒（ms） |\n| encoding | utf-8 | 字符串字符集 |\n| retry | 0 | 协议发生错误时，重试执行的次数 |\n| ssl | false | 启用加密传输 |\n| name | <empty> | 连接名，使用 CLIENT LIST 命令查看 |\n| prefix | <empty> | `key` 前辍，所有方法都会附带此前辍，cli.Set(prefix + \"key\", 111); |\n\n> IPv6: \\[fe80::b164:55b3:4b4f:7ce6%15\\]:6379\n\n* * *\n\n### 🎣 Master-Slave (读写分离)\n\n```\npublic static RedisClient cli = new RedisClient(\n    \"127.0.0.1:6379,password=123,defaultDatabase=13\",\n    \"127.0.0.1:6380,password=123,defaultDatabase=13\",\n    \"127.0.0.1:6381,password=123,defaultDatabase=13\"\n    );\n\nvar value = cli.Get(\"key1\");\n\n```\n\n> 写入时连接 127.0.0.1:6379，读取时随机连接 6380 6381\n\n* * *\n\n### ⛳ Redis Sentinel (哨兵高可用)\n\n```\npublic static RedisClient cli = new RedisClient(\n    \"mymaster,password=123\", \n    new [] { \"192.169.1.10:26379\", \"192.169.1.11:26379\", \"192.169.1.12:26379\" },\n    true //是否读写分离\n    );\n\n```\n\n* * *\n\n### 🌌 Redis Cluster (集群)\n\n假如你有一个 Redis Cluster 集群，其中有三个主节点(7001-7003)、三个从节点(7004-7006)，则连接此集群的代码：\n\n```\npublic static RedisClient cli = new RedisClient(\n    new ConnectionStringBuilder[] { \"192.168.0.2:7001\", \"192.168.0.2:7002\", \"192.168.0.2:7003\" }\n    );\n\n```\n\n* * *\n\n### ⚡ Client-side-cahing (本地缓存)\n\n> 服务端要求 6.0 及以上版本\n\n```\ncli.UseClientSideCaching(new ClientSideCachingOptions\n{\n    //本地缓存的容量\n    Capacity = 3,\n    //过滤哪些键能被本地缓存\n    KeyFilter = key => key.StartsWith(\"Interceptor\"),\n    //检查长期未使用的缓存\n    CheckExpired = (key, dt) => DateTime.Now.Subtract(dt) > TimeSpan.FromSeconds(2)\n});\n\n```\n\n重要功能了解详细：[https://www.cnblogs.com/kellynic/p/14009158.html](https://www.cnblogs.com/kellynic/p/14009158.html)\n\n* * *\n\n### 📡 Subscribe (订阅)\n\n```\nusing (cli.Subscribe(\"abc\", ondata)) //wait .Dispose()\n{\n    Console.ReadKey();\n}\n\nvoid ondata(string channel, string data) =>\n    Console.WriteLine($\"{channel} -> {data}\");\n\n```\n\nlpush + blpop：\n\n```\nusing (cli.SubscribeList(\"list_key\", ondata)) //wait .Dispose()\n{\n    Console.ReadKey();\n}\n\nvoid ondata(string listValue) =>\n    Console.WriteLine(listValue);\n\n```\n\n* * *\n\n### 📃 Scripting (脚本)\n\n```\nvar r1 = cli.Eval(\"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\", \n    new[] { \"key1\", \"key2\" }, \"first\", \"second\") as object[];\n\nvar r2 = cli.Eval(\"return {1,2,{3,\'Hello World!\'}}\") as object[];\n\ncli.Eval(\"return redis.call(\'set\',KEYS[1],\'bar\')\", \n    new[] { Guid.NewGuid().ToString() })\n\n```\n\n* * *\n\n### 💻 Pipeline (管道)\n\n```\nusing (var pipe = cli.StartPipe())\n{\n    pipe.IncrBy(\"key1\", 10);\n    pipe.Set(\"key2\", Null);\n    pipe.Get(\"key1\");\n\n    object[] ret = pipe.EndPipe();\n    Console.WriteLine(ret[0] + \", \" + ret[2]);\n}\n\n```\n\n* * *\n\n### 📰 Transaction (事务)\n\n```\nusing (var tran = cli.Multi())\n{\n    tran.IncrBy(\"key1\", 10);\n    tran.Set(\"key2\", Null);\n    tran.Get(\"key1\");\n\n    object[] ret = tran.Exec();\n    Console.WriteLine(ret[0] + \", \" + ret[2]);\n}\n\n```\n\n* * *\n\n### 📯 GetDatabase (切库)\n\n```\nusing (var db = cli.GetDatabase(10))\n{\n    db.Set(\"key1\", 10);\n    var val1 = db.Get(\"key1\");\n}\n\n```\n\n* * *\n\n### 🔍 Scan (扫描)\n\n> 支持集群模式\n\n```\nforeach (var keys in cli.Scan(\"*\", 10, null))\n{\n    Console.WriteLine(string.Join(\", \", keys));\n}\n\n```\n\n* * *\n\n🗄 License (许可证)\n----------------\n\n[MIT](https://www.cnblogs.com/LICENSE)\n\n* * *\n\n⛳ 结束语\n-----\n\n如果你遇到了 StackExchange.Redis Timeout 问题，不妨试试 FreeRedis，它轻巧、强大、听话。\n\n如果你还在使用 ServiceStack.Redis 破解版，不妨试试免费的 FreeRedis，它免费、开源、乖巧。\n\n开源地址：[https://github.com/2881099/FreeRedis](https://github.com/2881099/FreeRedis)\n\n* * *\n\n作者是什么人？\n\n作者是一个入行 18年的老批，他目前写的.net 开源项目有：\n\n| 开源项目 | 描述 | 开源地址 | 开源协议 |\n| --- | --- | --- | --- |\n| FreeIM | 聊天系统架构 | [https://github.com/2881099/FreeIM](https://github.com/2881099/FreeIM) | MIT |\n| FreeRedis | Redis SDK | [https://github.com/2881099/FreeRedis](https://github.com/2881099/FreeRedis) | MIT |\n| csredis |  | [https://github.com/2881099/csredis](https://github.com/2881099/csredis) | MIT |\n| FightLandlord | 斗DI主网络版 | [https://github.com/2881099/FightLandlord](https://github.com/2881099/FightLandlord) | 学习用途 |\n| FreeScheduler | 定时任务 | [https://github.com/2881099/FreeScheduler](https://github.com/2881099/FreeScheduler) | MIT |\n| IdleBus | 空闲容器 | [https://github.com/2881099/IdleBus](https://github.com/2881099/IdleBus) | MIT |\n| FreeSql | ORM | [https://github.com/dotnetcore/FreeSql](https://github.com/dotnetcore/FreeSql) | MIT |\n| FreeSql.Cloud | 分布式tcc/saga | [https://github.com/2881099/FreeSql.Cloud](https://github.com/2881099/FreeSql.Cloud) | MIT |\n| FreeSql.AdminLTE | 低代码后台生成 | [https://github.com/2881099/FreeSql.AdminLTE](https://github.com/2881099/FreeSql.AdminLTE) | MIT |\n| FreeSql.DynamicProxy | 动态代理 | [https://github.com/2881099/FreeSql.DynamicProxy](https://github.com/2881099/FreeSql.DynamicProxy) | 学习用途 |\n\n需要的请拿走，这些都是最近几年的开源作品，以前更早写的就不发了。\n\n本文转自 [https://www.cnblogs.com/FreeSql/p/16667741.html](https://www.cnblogs.com/FreeSql/p/16667741.html)', '', 0, 0, 9, 0, 0, 0, 1663895290666, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.42', '::ffff:172.17.0.1', 1663895290666, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (64, 0, 7, 2, '用SqlSugar连接达梦数据库，显示找不到方法Dm.DmCommand.get_Parameters()', '![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a068eb0-a002-54bb-b54d-b412d4bbdea2_6379615310776854218145080.jpg)\n\n----------\n\n解决方案：\n- 以管理员身份运行cmd，通过cd命令去到gacutil.exe所在的文件夹，这个exe文件一般在C:\\Program Files (x86)\\Microsoft SDKs\\Windows里的各文件夹内都存在。\n- cmd里去到gacutil.exe所在的文件夹后，运行 gacutil /u dmprovider就能卸载。\n- 有时候你不知道dmprovider注册到哪一个目录下的gacutil.exe，你就要一个个的试，有时候就会失败。', '', 0, 0, 63, 1, 0, 0, 1669348623662, 11, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.42', '::ffff:172.17.0.1', 1664241476279, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (65, 0, 7, 2, 'MQTT 订阅主题并接收消息的客户端案例', '概述\n---\nMQTT是一个客户端服务端架构的发布/订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。MQTT 协议在设计之初就包含了以下一些特点：\n- 实现简单\n- 提供数据传输的 QoS\n- 轻量、占用带宽低\n- 可传输任意类型的数据\n- 可保持的会话（session）\n\n简单地来说MQTT协议具有以下特性：\n- 基于 TCP 协议的应用层协议；\n- 采用 C/S 架构；\n- 使用订阅/发布模式，将消息的发送方和接受方解耦；\n- 提供 3 种消息的 QoS（Quality of Service）: 至多一次，最少一次，只有一次；\n- 收发消息都是异步的，发送方不需要等待接收方应答。\n\n---\n\n```\n// See https://aka.ms/new-console-template for more information\nusing ElectronicScaleMqtt;\nusing Microsoft.Extensions.Configuration;\nusing MQTTnet;\nusing MQTTnet.Client;\nusing MQTTnet.Formatter;\nusing Serilog;\nusing System.Text;\nusing System.Text.Encodings.Web;\nusing System.Text.Json;\nusing System.Text.Unicode;\n\nConsole.WriteLine(\"Hello, World!\");\n\n// 初始化配置文件\nIConfigurationRoot Configuration = new ConfigurationBuilder()\n    .SetBasePath(Path.Combine(Directory.GetCurrentDirectory()))\n    .AddJsonFile(\"appsettings.json\", optional: false)\n    .Build();\n// 数据库连接字符串\nvar ConnectionStrings = Configuration.GetSection(\"Db:Oracle\").Value;\n// MQTT 消息队列配置\nvar MqttOptions = Configuration.GetSection(\"Mqtt\");\n// 初始化日志记录器\nLog.Logger = new LoggerConfiguration()\n                .MinimumLevel.Debug()\n                .WriteTo.Console()\n                .WriteTo.File(\"logs/log.txt\", rollingInterval: RollingInterval.Day)\n                .CreateLogger();\n// 初始化mqtt，并订阅消息队列\nvar mqttFactory = new MqttFactory(new MqttNetLogger());\nusing var mqttClient = mqttFactory.CreateMqttClient();\nvar mqttClientOptions = new MqttClientOptionsBuilder()\n    .WithTcpServer(MqttOptions.GetSection(\"Server\").Value)\n    .WithCredentials(MqttOptions.GetSection(\"User\").Value, MqttOptions.GetSection(\"Password\").Value)\n    .WithProtocolVersion(MqttProtocolVersion.V500)\n    .Build();\n// 构建主题选项\nvar topics = MqttOptions.GetSection(\"Topics\").Value.Split(\',\');\nvar mqttSubscribeOptionsBuilder = mqttFactory.CreateSubscribeOptionsBuilder();\nforeach (var topic in topics)\n{\n    mqttSubscribeOptionsBuilder.WithTopicFilter(f => { f.WithTopic(topic); });\n}\nvar mqttSubscribeOptions = mqttSubscribeOptionsBuilder.Build();\n// 连接成功后订阅主题\nmqttClient.ConnectedAsync += async e =>\n{\n    try\n    {\n        await mqttClient.SubscribeAsync(mqttSubscribeOptions, CancellationToken.None);\n        Log.Information(\"Subscribe MQTT Topic Success...\");\n    }\n    catch (Exception ex)\n    {\n        Log.Error(ex, \"Subscribe MQTT Topic Exception\");\n    }\n};\n// 断连后尝试重连\nmqttClient.DisconnectedAsync += async e =>\n{\n    try\n    {\n        Log.Information(\"断开连接，尝试重新连接服务器\");\n        int num = 0;\n        while (num < 10)\n        {\n            var connectResult = await mqttClient.ConnectAsync(mqttClientOptions, CancellationToken.None);\n            if (connectResult.ResultCode == MqttClientConnectResultCode.Success)\n            {\n                num = 10;\n                Log.Information(\"Connected MQTT Server Success...\");\n            }\n            else\n            {\n                num++;\n                await Task.Delay(10 * 1000);\n            }\n        }\n    }\n    catch (Exception ex)\n    {\n        Log.Error(ex, \"DisconnectedAsync Exception\");\n    }\n};\n// 接收到消息并入库\nmqttClient.ApplicationMessageReceivedAsync += async e =>\n{\n    try\n    {\n        var msg = Encoding.UTF8.GetString(e.ApplicationMessage.Payload);\n        Log.Information($\"clientid:{e.ClientId},topic:{e.ApplicationMessage.Topic},msg:{msg}\");\n        var data = JsonSerializer.Deserialize<ElectronicScaleData>(msg, new JsonSerializerOptions\n        {\n            Encoder = JavaScriptEncoder.Create(UnicodeRanges.BasicLatin, UnicodeRanges.CjkUnifiedIdeographs)\n        });\n        if (data != null && !string.IsNullOrWhiteSpace(data.ImeiCode))\n        {\n            await new EsElectronicscaleService(ConnectionStrings).InsertAsync(data);\n        }\n    }\n    catch (Exception ex)\n    {\n        Log.Error(ex, \"ApplicationMessageReceivedAsync\");\n    }\n};\n// 连接\ntry\n{\n    await mqttClient.ConnectAsync(mqttClientOptions, CancellationToken.None);\n    Log.Information(\"Connected MQTT Server Success...\");\n}\ncatch (Exception ex)\n{\n    Log.Error(ex, \"Connected MQTT Server Exception\");\n}\n\nConsole.ReadKey();\n```\n', '', 0, 0, 14, 0, 0, 0, 1665383531176, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.34', '::ffff:172.17.0.1', 1665383531176, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (66, 0, 6, 19, 'IntelliJ IDEA 2021.2.2 简单开发使用教程', 'https://space.bilibili.com/384419389/channel/seriesdetail?sid=2626736\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e28b-4646-391d-1b42-13a20a71d47d_image.png)', '', 0, 0, 17, 0, 0, 0, 1665648268455, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 1665648268455, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (67, 0, 6, 19, 'java工具在哪里？', '内网获取开发工具\n\nGIT工具可以通过<协同办公系统进入>\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e28e-600a-b81e-bf2e-afdc6003a250_image.png)\n\n\n↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓小视频地址\nhttps://space.bilibili.com/384419389/channel/seriesdetail?sid=2626747\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e28d-5c8b-bfd5-ac46-f2cbaae2d050_image.png)', '', 0, 0, 24, 0, 0, 0, 1665648450241, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 1665648450241, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (68, 0, 6, 19, 'java基础的基础的基础的基础的基础的基础 的 基础介绍', '![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e291-8987-08a1-8fb4-42e7c6be19a1_image.png)\n\n↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓小视频\nhttps://space.bilibili.com/384419389/channel/seriesdetail?sid=2626748', '', 0, 0, 16, 0, 0, 0, 1665648639689, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36', '::ffff:172.17.0.1', 1665648639689, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (69, 0, 8, 9, 'node版本对应的  node-sass，sass-loader 版本', 'node-sass安装的时候会对node版本有要求，不然安装不了\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e2ad-31a2-e5e4-c444-32a4f3e5e69f_image.png)\n[说明](https://blog.csdn.net/oowweb/article/details/115960195)', '', 0, 0, 23, 2, 0, 0, 1666316210914, 19, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.37', '::ffff:172.17.0.1', 1665650423555, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (70, 0, 8, 2, 'uniapp监听安卓条码扫描服务的广播', '```\n// 获取activity\nvar main = plus.android.runtimeMainActivity(); \n// 上下文\n// var context = plus.android.importClass(\'android.content.Context\');\nvar receiver = plus.android.implements(\'io.dcloud.feature.internal.reflect.BroadcastReceiver\', {  \n	onReceive: (context, intent) => {\n		plus.android.importClass(intent);\n		var scanContext = intent.getStringExtra(\"Scan_context\");\n		console.log(\'scanContext\', scanContext);\n		// 取消监听\n		// main.unregisterReceiver(receiver);\n	}  \n});\nvar IntentFilter = plus.android.importClass(\'android.content.IntentFilter\');  \n// var Intent = plus.android.importClass(\'android.content.Intent\');  \nvar filter = new IntentFilter();\n// 添加监听\nfilter.addAction(\"com.android.scanservice.scancontext\");\n// 注册监听\nmain.registerReceiver(receiver, filter);\n```', '', 0, 0, 17, 0, 0, 0, 1665650932513, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.42', '::ffff:172.17.0.1', 1665650932513, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (71, 0, 7, 2, 'EasyUI 中 datagrid 底部添加合计行前端实现方案', '- 扩展editors的datagrid方法\n```\n$.extend($.fn.datagrid.methods, {\n    // 合计行\n    statistics: function (jq) {\n        var opt = new Array();\n        opt[0] = new Array();\n        var frozenOpts = $(jq).datagrid(\'options\').frozenColumns;\n        if (frozenOpts.length > 0 && frozenOpts[0].length > 0) {\n            $.each(frozenOpts[0], function (index, item) {\n                opt[0].push(item);\n            });\n        }\n        var opts = $(jq).datagrid(\'options\').columns;\n        if (opts[0].length > 0) {\n            $.each(opts[0], function (index, item2) {\n                opt[0].push(item2);\n            });\n        }\n        var rows = $(jq).datagrid(\"getRows\");\n        var footer = new Array();\n        footer[\'sum\'] = \"\";\n        for (var i = 0; i < opt[0].length; i++) {\n            if (opt[0][i].sum) {\n                var sumNum = 0;\n                var str = \"\";\n                for (var j = 0; j < rows.length; j++) {\n                    var num = rows[j][opt[0][i].field];\n                    sumNum += Number(num);\n                }\n                footer[\'sum\'] = footer[\'sum\'] + \'\"\' + opt[0][i].field + \'\":\"\' +\n                    ((sumNum + \'\').indexOf(\'.\') > -1 ? sumNum.toFixed(2) : sumNum) + \'\"\' + \',\';\n            }\n        }\n        var footerObj = new Array();\n        if (footer[\'sum\'] != \"\") {\n            var tmp = \'{\' + footer[\'sum\'].substring(0, footer[\'sum\'].length - 1) + \"}\";\n            var obj = eval(\'(\' + tmp + \')\');\n            if (obj[opt[0][0].field] == undefined) {\n                footer[\'sum\'] += \'\"\' + opt[0][0].field + \'\":\"<b>合计:</b>\"\';//第0列显示为合计\n                obj = eval(\'({\' + footer[\'sum\'] + \'})\');\n            } else {\n                // obj[opt[0][0].field] = \"<b>合计:</b>\" + obj[opt[0][0].field];\n            }\n            footerObj.push(obj);\n        }\n        if (footerObj.length > 0) {\n            $(jq).datagrid(\'reloadFooter\', footerObj);\n        }\n    }\n});\n```\n- 添加配置 `showFooter: true,`\n- 在需要合计的列上标记 `, sum: true`，并添加如下配置：\n```\n onLoadSuccess: function () {\n     $(\'#DataGridId\').datagrid(\'statistics\');\n }\n```\n\n- 效果\n![合计行](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a071c5d-573d-1bee-1757-f4079675e91e_dgt.jpg)', '', 0, 0, 20, 0, 1, 0, 1666618303591, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.42', '::ffff:172.17.0.1', 1666618303591, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (72, 0, 5, 11, '【DBeaver】一个比达梦管理工具更好用的第三方管理工具', '# 1、下载地址：https://dbeaver.io/download/\n## 直接下载压缩版，解压后就可以使用。\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df6-d46c-7c04-10dc-14fe4306a01c_image.png)\n\n# 2、dbeaver中配置驱动\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df7-aef2-fc51-751f-9029a03adb49_image.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df7-ddbd-170e-4570-ce1d672653af_image.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df8-16d8-97a3-4a97-bdb26f113d2d_image.png)\n\n## 装过达梦自带的管理工具可以在这个路径下找到驱动\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df8-38bc-5f16-2fc3-69757c7dcec5_lQLPJxbUFv8Ja5_NA0jNBBKw7FbKt9ehvVYDXI3k6ECqAA_1042_840.png)\n\n# 3、链接到达梦数据库\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df8-d156-9fe4-d0d9-ae300b9b87be_image.png)\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a073df9-89e8-7c2d-68d5-5c35d73e79bd_image.png)', '', 0, 0, 22, 0, 0, 0, 1667182169831, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.71', '::ffff:172.17.0.1', 1667182169831, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (73, 0, 7, 2, 'C# 11 中的新增功能', 'Visual Studio 2022 版本 17.4 中提供了以下功能：\n\n*   [文件范围类型](about:blank#file-scoped-types)\n\nVisual Studio 2022 版本 17.3 中提供了以下功能：\n\n*   [泛型数学支持](about:blank#generic-math-support)\n*   [自动默认结构](about:blank#auto-default-struct)\n*   [常量 `string` 上的模式匹配 `Span<char>`](about:blank#pattern-match-spanchar-or-readonlyspanchar-on-a-constant-string)\n*   [扩展的 `nameof` 范围](about:blank#extended-nameof-scope)\n*   [数值 IntPtr](about:blank#numeric-intptr-and-uintptr)\n*   [UTF-8 字符串字面量](about:blank#utf-8-string-literals)\n*   [必需的成员](about:blank#required-members)\n*   [`ref` 字段和 `scoped ref`](about:blank#ref-fields-and-ref-scoped-variables)\n\nVisual Studio 2022 版本 17.2 中提供了以下功能：\n\n*   [原始字符串字面量](about:blank#raw-string-literals)\n*   [改进了方法组向委托的转换](about:blank#improved-method-group-conversion-to-delegate)\n*   [警告波 7](https://learn.microsoft.com/language-reference/compiler-messages/warning-waves#cs8981---the-type-name-only-contains-lower-cased-ascii-characters)\n\nVisual Studio 2022 版本 17.1 中提供了以下功能：\n\n*   [泛型属性](about:blank#generic-attributes)\n*   [字符串内插表达式中的换行符](about:blank#newlines-in-string-interpolations)\n*   [列表模式](about:blank#list-patterns)\n\n可以下载 [Visual Studio 2022](https://visualstudio.microsoft.com/vs/) 最新版本。 还可以在 .NET 7 SDK 预览版中试用所有这些功能，该版本可以从[所有 .NET 下载](https://dotnet.microsoft.com/download/dotnet) 页面下载。\n\n泛型属性\n----\n\n可以声明基类为 [](https://learn.microsoft.com/programming-guide/generics/generic-classes)的[泛型类](https://learn.microsoft.com/programming-guide/generics/generic-classes)。 此功能为需要 [System.Type](https://learn.microsoft.com/zh-cn/dotnet/api/system.type) 参数的属性提供了更方便的语法。 以前需要创建一个属性，该属性将 `Type` 作为其构造函数参数：\n\n```\n// Before C# 11:\npublic class TypeAttribute : Attribute\n{\n   public TypeAttribute(Type t) => ParamType = t;\n\n   public Type ParamType { get; }\n}\n\n```\n\n并且为了应用该属性，需要使用 [`typeof`](https://learn.microsoft.com/language-reference/operators/type-testing-and-cast#typeof-operator) 运算符：\n\n```\n[TypeAttribute(typeof(string))]\npublic string Method() => default;\n\n```\n\n使用此新功能，可以改为创建泛型属性：\n\n```\n// C# 11 feature:\npublic class GenericAttribute<T> : Attribute { }\n\n```\n\n然后指定类型参数以使用该属性：\n\n```\n[GenericAttribute<string>()]\npublic string Method() => default;\n\n```\n\n应用属性时，必须提供所有类型参数。 换句话说，泛型类型必须[完全构造](https://learn.microsoft.com/language-reference/language-specification/types#84-constructed-types)。\n\n```\npublic class GenericType<T>\n{\n   [GenericAttribute<T>()] // Not allowed! generic attributes must be fully constructed types.\n   public string Method() => default;\n}\n\n```\n\n类型参数必须满足与 [`typeof`](https://learn.microsoft.com/language-reference/operators/type-testing-and-cast#typeof-operator) 运算符相同的限制。 不允许使用需要元数据注释的类型。 例如，不允许将以下类型用作类型参数：\n\n*   `dynamic`\n*   `string?`（或任何可为 null 的引用类型）\n*   `(int X, int Y)`（或使用 C# 元组语法的任何其他元组类型）。\n\n这些类型不会直接在元数据中表示出来。 它们包括描述该类型的注释。 在所有情况下，都可以改为使用基础类型：\n\n*   `object`（对于 `dynamic`）。\n*   `string`，而不是 `string?`。\n*   `ValueTuple<int, int>`，而不是 `(int X, int Y)`。\n\n泛型数学支持\n------\n\n有几个语言功能支持泛型数学支持：\n\n*   `static virtual` 接口中的成员\n*   已检查的用户定义的运算符\n*   宽松移位运算符\n*   无符号右移运算符\n\n可以在接口中添加 `static abstract` 或 `static virtual` 成员，以定义包含可重载运算符、其他静态成员和静态属性的接口。 此功能的主要场景是在泛型类型中使用数学运算符。 例如，可以在实现 `operator +` 的类型中实现 `System.IAdditionOperators<TSelf, TOther, TResult>` 接口。 其他接口定义其他数学运算或明确定义的值。 可以在有关[接口](https://learn.microsoft.com/language-reference/keywords/interface#static-abstract-and-virtual-members)的文章中了解新语法。 包含 `static virtual` 方法的接口通常是[泛型接口](https://learn.microsoft.com/programming-guide/generics/generic-interfaces)。 此外，大部分将声明一个约束，即类型参数[实现声明接口](https://learn.microsoft.com/programming-guide/generics/constraints-on-type-parameters#type-arguments-implement-declared-interface)。\n\n可以在[探索静态抽象接口成员](https://learn.microsoft.com/tutorials/static-virtual-interface-members)教程或 [.NET 6 中的预览功能 - 泛型数学](https://devblogs.microsoft.com/dotnet/preview-features-in-net-6-generic-math/)博客文章中了解详细信息并亲自尝试该功能。\n\n泛型数学对语言创建了其他要求。\n\n*   无符号右移运算符：在 C# 11 之前，若要强制无符号右移，需要将任何带符号整数类型强制转换为无符号类型，执行移动，然后将结果强制转换回带符号类型。 从 C# 11 开始，可以使用 `>>>`[_无符号移动运算符_](https://learn.microsoft.com/language-reference/operators/bitwise-and-shift-operators#unsigned-right-shift-operator-)。\n*   宽松的移动运算符要求：C# 11 删除了第二个操作数必须是 `int` 或隐式转换为 `int` 的要求。 此更改允许在这些位置使用实现泛型数学接口的类型。\n*   已检查和未检查的用户定义运算符：开发人员现在可以定义 `checked` 和 `unchecked` 算术运算符。 编译器根据当前上下文生成对正确变体的调用。 有关 `checked` 运算符的详细信息，可以阅读有关[算术运算符](https://learn.microsoft.com/language-reference/operators/arithmetic-operators)的文章。\n\n数值 `IntPtr` 和 `UIntPtr`\n-----------------------\n\n现在 `nint` 和 `nuint` 类型的别名分别为 [System.IntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.intptr) 和 [System.UIntPtr](https://learn.microsoft.com/zh-cn/dotnet/api/system.uintptr)。\n\n字符串内插中的换行符\n----------\n\n字符串内插的 `{` 和 `}` 字符内的文本现在可以跨多个行。 `{` 和 `}` 标记之间的文本分析为 C#。 允许任何合法 C#（包括换行符）。 使用此功能可以更轻松地读取使用较长 C# 表达式的字符串内插，例如模式匹配 `switch` 表达式或 LINQ 查询。\n\n可以在语言参考的[字符串内插](https://learn.microsoft.com/language-reference/tokens/interpolated)文章中了解有关换行符功能的详细信息。\n\n列表模式\n----\n\n列表模式扩展了模式匹配，以匹配列表或数组中的元素序列。 例如，当 `sequence` 为数组或三个整数（1、2 和 3）的列表时，`sequence is [1, 2, 3]` 为 `true`。 可以使用任何模式（包括常量、类型、属性和关系模式）来匹配元素。 弃元模式 (`_`) 匹配任何单个元素，新的范围模式 (`..`) 匹配零个或多个元素的任何序列。\n\n可以在语言参考的[模式匹配](https://learn.microsoft.com/language-reference/operators/patterns#list-patterns)文章中了解有关列表模式的更多详细信息。\n\n改进了方法组向委托的转换\n------------\n\n[方法组转换](https://learn.microsoft.com/language-reference/language-specification/conversions#108-method-group-conversions)上的 C# 标准现在包含以下项：\n\n> *   允许转换（但不是必需的）以使用已包含这些引用的现有委托实例。\n\n以前版本的标准禁止了编译器重用为方法组转换而创建的委托对象。 C# 11 编译器缓存从方法组转换创建的委托对象，并重用该单个委托对象。 此功能在 Visual Studio 2022 版本 17.2 中首次作为预览功能提供，在 .NET 7 预览版 2 中首次提供。\n\n原始字符串文本\n-------\n\n原始字符串字面量是字符串字面量的一种新格式。 原始字符串字面量可以包含任意文本，包括空格、新行、嵌入引号和其他特殊字符，无需转义序列。 原始字符串字面量以至少三个双引号 (\"\"\") 字符开头。 它以相同数量的双引号字符结尾。 通常，原始字符串字面量在单个行上使用三个双引号来开始字符串，在另一行上用三个双引号来结束字符串。 左引号之后、右引号之前的换行符不包括在最终内容中：\n\n```\nstring longMessage = \"\"\"\n    This is a long message.\n    It has several lines.\n        Some are indented\n                more than others.\n    Some should start at the first column.\n    Some have \"quoted text\" in them.\n    \"\"\";\n\n```\n\n右双引号左侧的任何空格都将从字符串字面量中删除。 原始字符串字面量可以与字符串内插结合使用，以在输出文本中包含大括号。 多个 `$` 字符表示有多少个连续的大括号开始和结束内插：\n\n```\nvar location = $$\"\"\"\n   You are at {{{Longitude}}, {{Latitude}}}\n   \"\"\";\n\n```\n\n前面的示例指定了两个大括号开始和结束内插。 第三个重复的左大括号和右大括号包括在输出字符串中。\n\n可以在[编程指南](https://learn.microsoft.com/programming-guide/strings/)中关于字符串的文章中，以及关于[字符串字面量](https://learn.microsoft.com/language-reference/builtin-types/reference-types#string-literals)和[内插字符串](https://learn.microsoft.com/language-reference/tokens/interpolated)的语言参考文章中详细了解原始字符串字面量。\n\n自动默认结构\n------\n\nC# 11 编译器可以确保在执行构造函数的过程中，将 `struct` 类型的所有字段初始化为其默认值。 此更改意味着，任何未由构造函数初始化的字段或自动属性都由编译器自动初始化。 现在，构造函数未明确分配所有字段的结构可以进行编译，并且未显式初始化的任何字段都设置为其默认值。 有关此更改如何影响结构初始化的详细信息，请阅读有关[结构](https://learn.microsoft.com/language-reference/builtin-types/struct#struct-initialization-and-default-values)的文章。\n\n常量 `string` 上的模式匹配 `Span<char>` 或 `ReadOnlySpan<char>`\n------------------------------------------------------\n\n你已经能够在几个版本中使用模式匹配来测试 `string` 是否有某个特定的常量值。 现在，可以将同一模式匹配逻辑用于 `Span<char>` 或 `ReadOnlySpan<char>` 的变量。\n\n扩展的 nameof 范围\n-------------\n\n在该方法的[属性声明](https://learn.microsoft.com/programming-guide/concepts/attributes/#using-attributes)中的 `nameof` 表达式中使用时，类型参数名称和参数名称现在处于范围内。 此功能意味着可以使用 `nameof` 运算符在方法或参数声明的属性中指定方法参数的名称。 此功能最常用于为[可为空分析](https://learn.microsoft.com/language-reference/attributes/nullable-analysis)添加属性。\n\nUTF-8 字符串字面量\n------------\n\n可以对字符串字面量指定 `u8` 后缀来指定 UTF-8 字符编码。 如果应用程序需要 UTF-8 字符串，则对于 HTTP 字符串常量或类似的文本协议来说，可以使用此功能来更轻松地创建 UTF-8 字符串。\n\n有关 UTF-8 字符串字面量的详细信息，请参阅关于[内置引用类型](https://learn.microsoft.com/language-reference/builtin-types/reference-types#utf-8-string-literals)的文章的字符串字面量部分。\n\n必需的成员\n-----\n\n可以将 [`required` 修饰符](https://learn.microsoft.com/language-reference/keywords/required)添加到属性和字段，以强制构造函数和调用方初始化这些值。 可以将 [System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/system.diagnostics.codeanalysis.setsrequiredmembersattribute) 添加到构造函数，以通知编译器构造函数将初始化所有必需的成员。\n\n有关所需成员的详细信息，请参阅属性文章的[仅限初始化](https://learn.microsoft.com/properties#init-only)部分。\n\n`ref` 字段和 `ref scoped` 变量\n-------------------------\n\n可以在 [`ref struct`](https://learn.microsoft.com/language-reference/builtin-types/ref-struct) 中声明 `ref` 字段。 这支持没有特殊特性或隐藏的内部类型的 [System.Span<T>](https://learn.microsoft.com/zh-cn/dotnet/api/system.span-1) 等类型。\n\n可向任意 `ref` 声明添加 [`scoped`](https://learn.microsoft.com/language-reference/statements/declarations#scoped-ref) 修饰符。 这限制了可将引用转义到的[范围](https://learn.microsoft.com/language-reference/keywords/method-parameters#scope-of-references-and-values)。\n\n文件范围类型\n------\n\n从 C# 11 开始，可以使用 `file` 访问修饰符创建其可见性范围限定为其声明时所在的源文件的类型。 此功能可帮助源生成器创建者避免命名冲突。 可以在语言参考中有关[文件范围类型](https://learn.microsoft.com/language-reference/keywords/file)的文章中详细了解此功能。\n\n另请参阅\n----\n\n*   [.NET 7 中的新增功能](https://learn.microsoft.com/core/whats-new/dotnet-7)\n\n本文转自 [https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-11](https://learn.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-11)', '', 0, 0, 5, 0, 0, 0, 1668580292218, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42', '::ffff:172.17.0.1', 1668580292218, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (74, 0, 1, 2, 'JS 支持多文件上传组件封装', '- JS 部分\n```\n// 自定义参数异常\nfunction multipleUploadError(message) {\n    this.name = \'multipleUploadError\';\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nmultipleUpload = {\n    // 配置参数\n    options: {\n        // 上传控件前缀\n        _input_file_prefix: \'fileField_\',\n        // 上传按钮的id属性\n        _upload_btn_id: \'\',\n        // 文件扩展属性前缀\n        _file_prefix: \'multiple-upload-f-index-\'\n    },\n    init: function (opt) {\n        Object.assign(this.options, {\n            // 上传按钮\n            elem: opt.elem || \'\',\n            // 显示文件容器\n            c_elem: opt.c_elem || \'\',\n            // 隐藏域字段\n            hiddenField: opt.hiddenField || \'\',\n            // 上传接口地址\n            url: opt.url || \'\',\n            // 允许上传的文件类型\n            accept: opt.accept || \'file/*\',\n            // 允许上传的文件后缀\n            exts: opt.exts || \'jpg|png|jpeg|doc|docx|xls|xlsx|pdf|txt\',\n            // 允许上传的文件大小，默认4M\n            size: opt.size || 4096,\n            // 是否允许多文件上传，默认否\n            multiple: opt.multiple || false,\n            // 设置允许上传的文件数量，默认0不限制\n            limit: opt.limit || 9,\n            // 上传请求失败的回调\n            error: opt.error || null,\n            // 上传请求成功的回调\n            done: opt.done || null,\n            // 文件列表数据\n            data: opt.data || [],\n            // 初始化文件地址，以逗号分隔\n            initUrls: opt.initUrls || \'\',\n            // 操作类型，新增编辑有删除按钮，查看(view)会隐藏删除按钮\n            op: opt.op || \'view\',\n            // 定义数据转换方法\n            // 插件要求的数据格式 [{ \"index\":\"\", \"name\": \"\", \"url\": \"\" }]\n            parseData: opt.parseData || null,\n            // 消息提示方法\n            alt: opt.alt || null\n        });\n        console.log(this.options);\n        // 参数校验\n        this.validateOptions();\n\n        // dom上添加文件上传表单元素\n        this.addFormDom2Document();\n\n        // 设置上传按钮的点击事件\n        this.bindEvent();\n\n        // 如果initUrls有值，初始化显示容器\n        this.initUrls();\n    },\n    initUrls: function () {\n        var that = this;\n        if (that.options.initUrls) {\n            var urls = that.options.initUrls.split(\',\');\n            for (var i = 0; i < urls.length; i++) {\n                var url = urls[i];\n                that.renderContentHtml(url);\n                that.addUploadData(url);\n                that.addHiddenFieldValue(url);\n            }\n        }\n    },\n    validateOptions: function () {\n        // 必传参数校验\n        var mustParameter = [\'elem\', \'url\', \'done\'];\n        for (var x = 0; x < mustParameter.length; x++) {\n            if (!this.options.hasOwnProperty(mustParameter[x]) || !this.options[mustParameter[x]]) {\n                throw new multipleUploadError(mustParameter[x] + \' is must assign ！\');\n            }\n        }\n    },\n    addFormDom2Document: function () {\n        var that = this;\n        var _id = that.options._input_file_prefix + that.generateRandom();\n        var html = \'<form action=\"\" method=\"post\" enctype=\"multipart/form-data\">\';\n        html += \'<input type=\"file\"\';\n        if (that.options.multiple) {\n            html += \' multiple\';\n        }\n        html += \' accept=\"\' + that.options.accept + \'\" id=\"\' + _id + \'\" name=\"\' + _id + \'\" style=\"display: none\" />\';\n        html += \'</form>\';\n        var div = document.createElement(\"div\");\n        div.innerHTML = html;\n        document.body.appendChild(div);\n        that.options._upload_btn_id = _id;\n    },\n    bindEvent: function () {\n        var that = this;\n        // file 控件的 onchange 事件\n        document.getElementById(that.options._upload_btn_id).addEventListener(\'change\', function () {\n            var beforeDataLength = that.options.data.length;\n            var files = document.getElementById(that.options._upload_btn_id).files;\n            for (var i = 0; i < files.length; i++) {\n                var file = files[i];\n                var filename = file.name;\n                var filesize = file.size;\n                console.log(filename, filesize);\n\n                // 文件类型校验\n                if (!that.validateFileExt(filename)) {\n                    return;\n                }\n                // 文件大小校验\n                if (!that.validateFileSize(filesize)) {\n                    return;\n                }\n                // 允许上传文件数量校验\n                if (!that.validateLimit(beforeDataLength, i + 1)) {\n                    return;\n                }\n\n                var formData = new FormData();\n                formData.append(\'file\', file);\n                formData.append(\'name\', filename);\n                $.ajax({\n                    url: that.options.url,\n                    type: \'POST\',\n                    async: true,\n                    data: formData,	\n                    processData: false,\n                    contentType: false,	\n                    beforeSend: function () {\n                    },\n                    success: function (res) {\n                        that.resetFileValue();\n                        that.options.done(res, function (url) {\n                            that.renderContentHtml(url);\n                            that.addUploadData(url);\n                            that.addHiddenFieldValue(url);\n                        });\n                    },\n                    error: function (XMLHttpRequest) {\n                        that.alertMsg(XMLHttpRequest.responseText);\n                        that.resetFileValue();\n                        if (that.options.error) {\n                            that.options.error(filename, file);\n                        }\n                    }\n                });\n            }\n        });\n\n        // 上传按钮的点击事件\n        if (that.options.elem) {\n            document.getElementById(that.options.elem).addEventListener(\'click\', function () {\n                document.getElementById(that.options._upload_btn_id).click();\n            });\n        }\n    },\n    // 生成html显示内容\n    renderContentHtml: function (url) {\n        var that = this;\n        var html = \'<a href=\"javascript:window.open(\\\'\' + url + \'\\\')\" style=\"font-size:16px;align-items:center\">\' + url.substr(url.lastIndexOf(\'/\') + 1) + \'</a>\';\n        if (that.options.op !== \'view\' && that.options.op !== \'View\') {\n            html += \'<img src=\"/Content/images/del.png\" style=\"width: 18px; height: 18px; cursor: pointer;margin-left:20px;\" onclick=\"multipleUpload.delSomeoneFile(this,\\\'\' + url + \'\\\')\" />\';\n        }\n        if (that.options.c_elem) {\n            var div = document.createElement(\"div\");\n            div.style = \'display:flex;height:20px;margin-bottom:5px\';\n            div.innerHTML = html;\n            document.getElementById(that.options.c_elem).appendChild(div);\n        }\n    },\n    // 添加文件列表\n    addUploadData: function (url) {\n        var that = this;\n        var filename = url.substr(url.lastIndexOf(\'/\') + 1);\n        that.options.data.push({\n            name: filename,\n            url: url\n        });\n    },\n    // 设置隐藏域的值\n    addHiddenFieldValue: function (url) {\n        var that = this;\n        if (that.options.hiddenField) {\n            var v = document.getElementById(that.options.hiddenField).value;\n            var va;\n            if (v) {\n                va = v + \',\' + url;\n            } else {\n                va = url;\n            }\n            document.getElementById(that.options.hiddenField).value = va;\n        }\n    },\n    // 删除\n    delSomeoneFile: function (cur, url) {\n        var that = this;\n        var parent = cur.parentNode;\n        var reparent = parent.parentNode;\n        reparent.removeChild(parent);\n        // 删除隐藏字段中的值\n        that.delHiddenFieldValue(url);\n        // 移除文件列表其中的值\n        that.options.data.splice(that.options.data.findIndex(i => i.url === url), 1);\n    },\n    // 删除隐藏域的值\n    delHiddenFieldValue: function (url) {\n        var that = this;\n        if (that.options.hiddenField) {\n            var v = document.getElementById(that.options.hiddenField).value;\n            var va;\n            if (v) {\n                va = v.split(\',\');\n                var van = new Array();\n                for (var i = 0; i < va.length; i++) {\n                    if (va[i] != url) {\n                        van.push(va[i]);\n                    }\n                }\n                document.getElementById(that.options.hiddenField).value = van.join();\n            }\n        }\n    },\n    // 校验文件类型\n    validateFileExt: function (name) {\n        var that = this;\n        var fileExt = name.substr(name.lastIndexOf(\'.\') + 1);\n        if (that.options.exts.indexOf(fileExt) == -1) {\n            that.alertMsg(\'文件类型不允许上传\');\n            return false;\n        }\n        return true;\n    },\n    // 文件大小校验\n    validateFileSize: function (size) {\n        var that = this;\n        if (that.options.size > 0 && size > that.options.size * 1024) {\n            that.alertMsg(\"上传文件大小不允许超过\" + (that.options.size / 1024) + \"M\");\n            return false;\n        }\n        return true;\n    },\n    // 允许上传文件数量校验\n    validateLimit: function (b, c) {\n        var that = this;\n        if (that.options.limit > 0 && b + c > that.options.limit) {\n            that.alertMsg(\"上传数已达上限\");\n            return false;\n        }\n        return true;\n    },\n    // 上传组件 value 重置\n    resetFileValue: function () {\n        var that = this;\n        document.getElementById(that.options._upload_btn_id).value = \'\';\n    },\n    // 弹出消息提醒\n    alertMsg: function (msg) {\n        var that = this;\n        if (that.options.alt) {\n            that.options.alt(msg);\n        } else {\n            alert(msg);\n        }\n    },\n    // 生成随机数\n    generateRandom: function () {\n        return Math.ceil(Math.random() * 10000);\n    }\n}\n```\n- 页面部分\n```\n        multipleUpload.init({\n            elem: \'WS_FILE_BTN\',\n            c_elem: \'WS_FILE_HTML\',\n            hiddenField: \'WS_FILE\',\n            url: \'/BasedManagements/UploadSelectedFile\',\n            multiple: true,\n            done: function (res, callback) {\n                if (res.message == \'OK\') {\n                    callback(res.url);\n                } else {\n                    $.messager.alert(\"提示\", res.message);\n                }\n            },\n            op: \'add\',\n            initUrls: \'\',\n            alt: function (msg) {\n                $.messager.alert(\"提示\", msg);\n            }\n        });\n```', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a0792a0-a493-1408-b187-93ffc401beb6_30C0C193-3336-49b6-81A5-44A3789E0FEE.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0792a0-a493-1408-b187-93ffc401beb6_30C0C193-3336-49b6-81A5-44A3789E0FEE.png\"}]', 0, 0, 19, 0, 2, 0, 1668602410534, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42', '::ffff:172.17.0.1', 1668602410534, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (75, 0, 7, 9, '列表返回的时候字典名称问题显示', '表里面存的都是字典Code值，列表显示的时候需要显示字典名称。联表查询，有一个需要去联表一次，很麻烦。在Sqlsuagr里面有个扩展方法可以写扩展方法，不分库的情况下是可以的\n``` C#\n /// <summary>\n        /// 进行分库的时候无法满足(todo)\n        /// </summary>\n        /// <returns></returns>\n        public static List<SqlFuncExternal> ExtendMethods()\n        {\n            return new List<SqlFuncExternal>() {\n                new SqlFuncExternal()\n                {\n                    UniqueMethodName = \"GetDictName\",\n                    MethodValue = (expInfo, dbType, expContext) =>\n                    {\n                        var sql= $\"(select Label from sys_dict where  ParentValue=\'{expInfo.Args[0].MemberValue}\' and Value=\'{expInfo.Args[1].MemberValue}\' ) \";\n                    return sql;\n                    }\n                }              \n            };\n        }\n\n```\n如果涉及到分库下是无法满足的，这样写的话在查询列表 里面还需要使用select 多个字段，比较麻烦。\n前提：在维护字典数据的时候就把数据同步更新到redis里面存着，后面统一获取redis里面的数据\n1.在前端缓存下字典数据，让前端来处理\n每次在请求菜单的时候去更新数据，也就是页面刷新的时候,请求接口字典数据\n``` vue\n    const storesDictAll = useDictAllState(pinia);\n    storesDictAll.setDictAll();\n```\n封装两个方法来处理字典数据\n```vue \n\n//获取字典下拉框\nexport function dictSelect(name: string): DictStatesDto[] {\n	const storesDictAllState = useDictAllState(pinia);\n	const { dictAll } = storeToRefs(storesDictAllState);\n	const obj = _.find(dictAll.value, a => a.label == name)?.child ?? [];\n	return obj;\n}\n\n//获取字典名称\nexport function dictName(name: string, lable: string):string {\n	const storesDictAllState = useDictAllState(pinia);\n	const { dictAll } = storeToRefs(storesDictAllState);\n	const obj = _.find(dictAll.value, a => a.label == name)?.child ?? null;\n	let str = \'\';\n	if (obj) {\n		str = _.find(obj, a => a.label == lable)?.name ?? \'\';\n	}\n	return str;\n}\n\n```\n2.后台映射的时候去处理-----推荐\n创建一个获取字典名称的帮助方法\n``` C#\n /// <summary>\n    /// redis缓存帮助\n    /// </summary>\n    public  class WjRedisHelper\n    {\n\n        private static  RedisClient _redisClient;\n        public WjRedisHelper(RedisClient redisClient)\n        {\n            _redisClient = redisClient;\n        }\n\n        /// <summary>\n        ///  获取字典名称\n        /// </summary>\n        /// <param name=\"key\"></param>\n        /// <param name=\"field\"></param>\n        /// <returns></returns>\n        public  static string GetDictName(string key,string field)\n        {\n            return _redisClient.HGet($\"{WjConst.DICT}:{key}\", field);\n        }\n    }\n```\n我们在注入redis的时候把帮助类进行注入\n``` C#\n                string str = context.Configuration[\"Redis:RedisStr\"];\n\n                RedisClient cli = new RedisClient(str);\n                context.Services.AddSingleton(cli);\n\n                context.Services.AddSingleton(new WjRedisHelper(cli));\n\n```\n\n使用：我们在映射的时候直接进去读取缓存数据\n``` C#\n        cfg.NewConfig<CompanyEntity, OutCompanyTableDto>()\n              .Map(dest => dest.CmpId, src => src.Id.ToString())\n              .Map(dest => dest.Type, src => WjRedisHelper.GetDictName(\"QYLX\",src.Type))    \n```\n\n\n\n\n', '', 0, 0, 18, 1, 2, 0, 1669629355034, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.52', '::ffff:172.17.0.1', 1669280299365, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (76, 0, 7, 2, '多环境下Web.config配置', '- **背景**\n\n在我们的项目开发中，大概率会经历从开发、测试、演示、到生产环境的过程。在之前的开发过程中在`Web.config`中切换不同环境的参数配置，比如数据库链接字符串、`appSettings`中的参数配置等，都是通过手动修改和注释的方式完成的，既容易导致错误，也不利于版本管理。\n\n- **配置**\n\n默认项目中, 会创建`Web.Debug.config`和`Web.Release.config`文件，分别对应于`Debug`和`Release`环境。如果我们需要其它环境，可以在解决方案的配置管理器中增加一个配置，比如`Production`环境：\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a07cfe4-862e-e042-6b16-4cd995381d50_image.png)\n\n在我们的项目中增加一个`Web.base.config`文件，作为`Web.config`的基础文件。\n在项目的`Web.Debug.config`文件中增加如下配置：\n```\n<connectionStrings>\n		<add name=\"DefaultDB\" providerName=\"System.Data.OracleClient\" connectionString=\"\"\n			    xdt:Transform=\"SetAttributes\" xdt:Locator=\"Match(name)\"/>\n	</connectionStrings>\n```\n> 意思是`Debug`环境下`Web.config`文件中的`DefaultDB`数据库链接字符串会替换成上面的字符串\n\n`appSettings`的配置同理：\n```\n<appSettings>\n		<add key=\"isSendXfx\" value=\"1\" xdt:Transform=\"SetAttributes\" xdt:Locator=\"Match(key)\" />\n	</appSettings>\n```\n> 在项目编译生成的时候`Web.config`中的`isSendXfx`配置值会被替换成 1\n\n- **重要**\n\n在项目文件中增加如下配置项：\n```\n<Target Name=\"BeforeBuild\">\n    <TransformXml Source=\"Web.base.config\" Transform=\"Web.$(Configuration).config\" Destination=\"Web.config\" />\n  </Target>\n```\n> 如此配置后，可以将 Web.confg 文件添加到 svn 的忽略列表中，当切换不同环境编译后，虽然 Web.config 文件变化了，但是不会显示 svn 的红色图标\n\n- **补充**\n\n- xdt:Transform\n\n|转换|描述|\n|-|-|\n|xdt:Transform=\"Replace\"|替换第一个匹配的节点|\n|xdt:Transform=\"Remove\"|清除第一个匹配的节点|\n|xdt:Transform=\"RemoveAll\"|清除所有匹配的节点|\n|xdt:Transform=\"Insert\"|在末尾插入节点|\n|xdt:Transform=\"SetAttributes(attributeNames)\"|创建或更改现有属性的值|\n|xdt:Transform=\"RemoveAttributes(attributeNames)\"|清除属性（如果有）|\n|xdt:Transform=\"InsertBefore(XPath)\"|在指定Xpath前插入节点|\n|xdt:Transform=\"InsertAfter(XPath)\"|在指定Xpath后插入节点|\n\n- xdt:Locator\n\n|定位符|描述|\n|-|-|\n|xdt:Locator=\"Match(attributeName)\"|可以使用逗号分隔属性名称|\n|xdt:Locator=\"Condition(xPath Predicate)\"|可以接受任何 Xpath 谓词，如xdt:Locator=\"Condition(@name=\'Northwind\' or @providerName=\'System.Data.SqlClient\')\"|\n|xdt:Locator=\"Xpath(/configuration/…)\"|可以接受任何复杂的 Xpath，如 \"XPath(//system.web)\"|', '', 0, 0, 16, 1, 1, 0, 1669711591452, 9, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.56', '::ffff:172.17.0.1', 1669631568781, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (77, 0, 7, 2, 'EasyUI前端导出组件优化版', '- 前端导出组件js代码\n```\n(function($){\n    function getRows(target){\n        var state = $(target).data(\'datagrid\');\n        if (state.filterSource){\n            return state.filterSource.rows;\n        } else {\n            return state.data.rows;\n        }\n    }\n    function getFooterRows(target){\n        var state = $(target).data(\'datagrid\');\n        return state.data.footer || [];\n    }\n    /**\n     * 导出表格页面\n     * @param {any} target\n     * @param {any} rows\n     * @param {any} footer\n     * @param {any} caption\n     * @param {any} mergeFields 需合并列\n     */\n    function toHtml(target, rows, footer, caption, mergeFields){\n        rows = rows || getRows(target);\n        rows = rows.concat(footer||getFooterRows(target));\n        var dg = $(target);\n        var data = [\'<table border=\"1\" rull=\"all\" style=\"border-collapse:collapse\">\'];\n        var fields = dg.datagrid(\'getColumnFields\', true).concat(dg.datagrid(\'getColumnFields\', false));\n        var trStyle = \'height:48px\';\n        var tdStyle0 = \'vertical-align:middle;padding:0 4px\';\n        if (caption){\n            data.push(\'<caption>\'+caption+\'</caption>\');\n        }\n        // 写入表头信息\n        // 获取所有列信息\n        var frozenColumns = dg.datagrid(\'options\').frozenColumns;\n        var columns = dg.datagrid(\'options\').columns;\n        var cc = [];\n        if (frozenColumns.length > 0) {\n            for (var i = 0; i < frozenColumns.length; i++) {\n                var tmpCc = [];\n                if (columns.length > i) {\n                    tmpCc = [...frozenColumns[i], ...columns[i]];\n                } else {\n                    tmpCc = [...frozenColumns[i]];\n                }\n                cc.push(tmpCc);\n            }\n            for (var i = frozenColumns.length; i < columns.length; i++) {\n                cc.push(columns[i]);\n            }\n        } else {\n            cc = columns;\n        }\n        console.log(cc, rows);\n        for (var j = 0; j < cc.length; j++) {\n            data.push(\'<tr style=\"\' + trStyle + \'\">\');\n            var cols = cc[j];\n            for (var i = 0; i < cols.length; i++) {\n                if (cols[i].hidden == true) {\n                    continue;\n                }\n                var tdStyle = tdStyle0 + \';width:\' + (cols[i].boxWidth * 3) + \'px;\';\n                tdStyle += \';text-align:\' + (cols[i].halign || cols[i].align || \'\');\n                var colspans = 1;\n                var rowspans = 1;\n                if (cols[i].rowspan === undefined) {\n\n                } else {\n                    rowspans = cols[i].rowspan;\n                }\n                if (cols[i].colspan === undefined) {\n\n                } else {\n                    colspans = cols[i].colspan;\n                }\n                cols[i].title = cols[i].title.replace(/<br\\/>/g, \'\');\n                data.push(\'<td style=\"\' + tdStyle + \'\" colspan=\"\' + colspans + \'\" rowspan=\"\' + rowspans + \'\">\' + cols[i].title + \'</td>\');\n            }\n            data.push(\'</tr>\');\n        }\n        /**\n         * 原方法\n        data.push(\'<tr style=\"\'+trStyle+\'\">\');\n        for(var i=0; i<fields.length; i++){\n            var col = dg.datagrid(\'getColumnOption\', fields[i]);\n            var tdStyle = tdStyle0 + \';width:\'+col.boxWidth+\'px;\';\n            tdStyle += \';text-align:\'+(col.halign||col.align||\'\');\n            data.push(\'<td style=\"\'+tdStyle+\'\">\'+col.title+\'</td>\');\n        }\n        data.push(\'</tr>\');\n        */\n\n        // 处理数据，合并单元格\n        var _rows = [];\n        var mergeFields = mergeFields || [];\n        var mergeIndexs = mergeFields.length > 0 ? new Array(mergeFields.length) : [];\n        if (mergeFields.length > 0) {\n            for (var i = 0; i < mergeFields.length; i++) {\n                mergeIndexs[i] = 0;\n            }\n        }\n        $.map(rows, function (row, index) {\n            var _row = [];\n            for (var i = 0; i < fields.length; i++) {\n                var field = fields[i];\n                var col = dg.datagrid(\'getColumnOption\', field);\n                if (col.hidden == true) {\n                    continue;\n                }\n                var value = row[field];\n                if (value == undefined) {\n                    value = \'\';\n                }\n                var mergeFieldIndex = mergeFields.indexOf(field);\n                // 如果是第一行或者不是需要合并的列\n                if (index == 0 || mergeFieldIndex == -1) {\n                    _row.push({ field: field, value: value, align: col.align, rowspan: 1, colspan: 1 });\n                    continue;\n                }\n                if (!_rows[mergeIndexs[mergeFieldIndex]]) {\n                    _row.push({ field: field, value: value, align: col.align, rowspan: 1, colspan: 1 });\n                    continue;\n                }\n                // 如果合并列值一致\n                if (_rows[mergeIndexs[mergeFieldIndex]].find(x => x.field == field).value == value) {\n                    _rows[mergeIndexs[mergeFieldIndex]].find(x => x.field == field).rowspan++;\n                } else {\n                    mergeIndexs[mergeFieldIndex] = index;\n                    _row.push({ field: field, value: value, align: col.align, rowspan: 1, colspan: 1 });\n                }\n            }\n            _rows.push(_row);\n        });\n        console.log(_rows);\n        $.map(_rows, function (row) {\n            data.push(\'<tr style=\"\' + trStyle + \'\">\');\n            $.map(row, function (field) {\n                var tdStyle = tdStyle0;\n                tdStyle += \';text-align:\' + (field.align || \'\');\n                data.push(\n                    \'<td style=\"\' + tdStyle + \'\" colspan=\"\' + field.colspan + \'\" rowspan=\"\' + field.rowspan + \'\">\' + field.value + \'</td>\'\n                );\n            });\n            data.push(\'</tr>\');\n        });\n        /**\n         * 原方法\n        $.map(rows, function(row){\n            data.push(\'<tr style=\"\'+trStyle+\'\">\');\n            for(var i=0; i<fields.length; i++){\n                var field = fields[i];\n                var col = dg.datagrid(\'getColumnOption\', field);\n                if (col.hidden == true) {\n                    continue;\n                }\n                var value = row[field];\n                if (value == undefined){\n                    value = \'\';\n                }\n                var tdStyle = tdStyle0;\n                tdStyle += \';text-align:\'+(col.align||\'\');\n                data.push(\n                    \'<td style=\"\'+tdStyle+\'\">\'+value+\'</td>\'\n                );\n            }\n            data.push(\'</tr>\');\n        });\n        */\n        data.push(\'</table>\');\n        return data.join(\'\');\n    }\n\n    function toArray(target, rows){\n        rows = rows || getRows(target);\n        var dg = $(target);\n        var fields = dg.datagrid(\'getColumnFields\',true).concat(dg.datagrid(\'getColumnFields\',false));\n        var data = [];\n        var r = [];\n        for(var i=0; i<fields.length; i++){\n            var col = dg.datagrid(\'getColumnOption\', fields[i]);\n            r.push(col.title);\n        }\n        data.push(r);\n        $.map(rows, function(row){\n            var r = [];\n            for(var i=0; i<fields.length; i++){\n                r.push(row[fields[i]]);\n            }\n            data.push(r);\n        });\n        return data;\n    }\n\n    function print(target, param){\n        var title = null;\n        var rows = null;\n        var footer = null;\n        var caption = null;\n        if (typeof param == \'string\'){\n            title = param;\n        } else {\n            title = param[\'title\'];\n            rows = param[\'rows\'];\n            footer = param[\'footer\'];\n            caption = param[\'caption\'];\n        }\n        var newWindow = window.open(\'\', \'\', \'width=800, height=500\');\n        var document = newWindow.document.open();\n        var content = \n            \'<!doctype html>\' +\n            \'<html>\' +\n            \'<head>\' +\n            \'<meta charset=\"utf-8\">\' +\n            \'<title>\'+title+\'</title>\' +\n            \'</head>\' +\n            \'<body>\' + toHtml(target, rows, footer, caption) + \'</body>\' +\n            \'</html>\';\n        document.write(content);\n        document.close();\n        newWindow.print();\n    }\n\n    function b64toBlob(data){\n        var sliceSize = 512;\n        var chars = atob(data);\n        var byteArrays = [];\n        for(var offset=0; offset<chars.length; offset+=sliceSize){\n            var slice = chars.slice(offset, offset+sliceSize);\n            var byteNumbers = new Array(slice.length);\n            for(var i=0; i<slice.length; i++){\n                byteNumbers[i] = slice.charCodeAt(i);\n            }\n            var byteArray = new Uint8Array(byteNumbers);\n            byteArrays.push(byteArray);\n        }\n        return new Blob(byteArrays, {\n            type: \'\'\n        });\n    }\n\n    function toExcel(target, param){\n        var filename = null;\n        var rows = null;\n        var footer = null;\n        var caption = null;\n        var worksheet = \'Worksheet\';\n        var mergeFields = null;\n        if (typeof param == \'string\'){\n            filename = param;\n        } else {\n            filename = param[\'filename\'];\n            rows = param[\'rows\'];\n            footer = param[\'footer\'];\n            caption = param[\'caption\'];\n            worksheet = param[\'worksheet\'] || \'Worksheet\';\n            mergeFields = param[\'mergeFields\'];\n        }\n        var dg = $(target);\n        var uri = \'data:application/vnd.ms-excel;base64,\'\n        , template = \'<html xmlns:o=\"urn:schemas-microsoft-com:office:office\" xmlns:x=\"urn:schemas-microsoft-com:office:excel\" xmlns=\"http://www.w3.org/TR/REC-html40\"><meta http-equiv=\"content-type\" content=\"application/vnd.ms-excel; charset=UTF-8\"><head><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>{worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head><body>{table}</body></html>\'\n        , base64 = function (s) { return window.btoa(unescape(encodeURIComponent(s))) }\n            , format = function (s, c) { return s.replace(/{(\\w+)}/g, function (m, p) { return c[p]; }) }\n        \n        var table = toHtml(target, rows, footer, caption, mergeFields);\n        var ctx = { worksheet: worksheet, table: table };\n        var data = base64(format(template, ctx));\n        if (window.navigator.msSaveBlob){\n            var blob = b64toBlob(data);\n            window.navigator.msSaveBlob(blob, filename);\n        } else {\n            var alink = $(\'<a style=\"display:none\"></a>\').appendTo(\'body\');\n            alink[0].href = uri + data;\n            alink[0].download = filename;\n            alink[0].click();\n            alink.remove();\n        }\n    }\n\n    $.extend($.fn.datagrid.methods, {\n        toHtml: function(jq, rows){\n            return toHtml(jq[0], rows);\n        },\n        toArray: function(jq, rows){\n            return toArray(jq[0], rows);\n        },\n        toExcel: function(jq, param){\n            return jq.each(function(){\n                toExcel(this, param);\n            });\n        },\n        print: function(jq, param){\n            return jq.each(function(){\n                print(this, param);\n            });\n        }\n    });\n})(jQuery);\n\n```\n\n- 页面中使用方式\n```\nvar data = $(\"#actionTable\").datagrid(\'getData\');\n        if (data.total == 0) {\n            $.messager.alert(\"提示\", \"没有数据需要导出\", \"info\");\n            return;\n        }\n        $(\"#actionTable\").datagrid(\'toExcel\', {\n            filename: \'班列数据汇总.xls\',\n            worksheet: \'Sheet1\',\n            caption: \'班列数据汇总\',\n            mergeFields: [\"GJ\", \"XL\"]//合并列\n        });\n```', '', 0, 0, 5, 0, 0, 0, 1671518725759, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54', '::ffff:172.17.0.1', 1671518725759, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (78, 0, 9, 2, 'ORACLE使用exp和imp导入导出命令', '- 导出\n```\nexp ZYW_DSLY32/ZYW_DSLY32@192.168.1.136:1521/ORCL \nowner=ZYW_DSLY32 \nfile=d:/copy/ZYW_DSLY32.dmp \nlog=d:/copy/ZYW_DSLY32.log\n```\n- 导入\n```\nimp YC_DSLY/YC_DSLY@192.168.1.136:1521/ORCL \nfile=d:/copy/ZYW_DSLY32.dmp \nlog=d:/copy/YC_DSLY.log \nFROMUSER=ZYW_DSLY32 \nTOUSER=YC_DSLY \nIGNORE=Y FEEDBACK=1000\n```\n\n## 导出出现缺表的情况\noracle11g有个新特性，增加了一个新特性 \"deferred\\_segment\\_creation\" 含义是段延迟创建，默认是true。\n\n>如果这个参数设置为true，你新创建了一个Table，并且没有向其中插入数据，那么这个表不会立即分配extend，也就是不占数据空间，即表不分配segment以节省空间，所以这些表也没能导出来。在系统表user_tables中也可以看到segment_treated的字段里是“NO”或者“YES”说明了某张表是否分配了segment。说白了是为了可以节省少量的空间。\n\n用下面的SQL语句查询，可以发现没有导出的表其 segment_created 字段值都是 \'NO\'。\n\n```\nSelect segment_created,table_name from user_tables where segment_created = \'NO\';\n```\n\n#### 解决办法：\n\n*   第一种  \n    1、最原始最笨的办法(不推荐):insert一行，再rollback或者删除就产生segment了。\n\n该方法是在在空表中插入数据，再删除，则产生segment。导出时则可导出空表。\n\n*   第二种  \n    设置deferred\\_segment\\_creation 参数：  \n    设置deferred\\_segment\\_creation 参数为FALSE来禁用\"段推迟创建\"(也就是直接创建segment)，无论是空表还是非空表，都分配segment。  \n    在sqlplus中，执行如下命令：\n\n```\nSQL>alter system set deferred_segment_creation=false;\n```\n\n查看：\n\n```\nSQL>show parameter deferred_segment_creation;\n```\n\n注意：该值设置后只对后面新增的表产生作用，对之前建立的空表(已经存在的)不起作用，仍不能导出。  \n并且要重新启动数据库，让参数生效。\n\n*   第三种：  \n    使用ALLOCATE EXTENT可以为数据库对象的每一张表分配Extent(注意针对每一张表，就是说一张表需要一条SQL代码)，但要是每一张表写一条语句的话太过麻烦，为了方便我们使用SQL命令拼写出每一张表的alter语句。\n\n##### 构建对空表分配空间的SQL命令。\n\n查询当前用户下的所有空表（一个用户最好对应一个默认表空间）。命令如下：\n\n```\nselect table_name from user_tables where num_rows=\'0\'\n```\n\n2.根据上述查询的语句，可以构建针对空表分配空间的命令语句，具体如下;\n\n```\nselect \'alter table \'||table_name||\' allocate extent;\' from user_tables where num_rows=0 or num_rows is null;\n\n```\n\n这段代码可产生批量的修改表extent的SQL语句(有多少张空表就产生多少条)，我们只需要将其生成的所有sql代码全部执行，就可以给每一张已经存在的表来分配segment，就OK了。\n\n再用exp命令进行导出即可。', '', 0, 0, 42, 1, 0, 0, 1674010567758, 12, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54', '::ffff:172.17.0.1', 1672897512482, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (79, 0, 9, 2, '达梦-动态视图诊断', '利用动态视图可以便捷查询数据库相关信息，并定位数据库性能问题。以下介绍 4 种动态性能视图的诊断方法，分别是查询活动会话数、查询耗时超过 2 秒的 SQL、查询锁和查询阻塞。\n\n1.  查询活动会话数，活动会话数量达到一定程度后会对数据库性能造成影响。\n\n```\nSELECT COUNT(*) FROM V$SESSIONS WHERE STATE=\'ACTIVE\';\n\n```\n\n2.  查询已执行超过 2 秒的活动 SQL。\n\n```\nSELECT* FROM (\nSELECT SESS_ID,SQL_TEXT,DATEDIFF(SS,LAST_RECV_TIME,SYSDATE) Y_EXETIME,\n       SF_GET_SESSION_SQL(SESS_ID) FULLSQL,CLNT_IP\nFROM V$SESSIONS WHERE STATE=\'ACTIVE\')\nWHERE Y_EXETIME>=2;\n\n```\n\n3.  查询锁。\n\n```\nSELECT O.NAME,L.* FROM V$LOCK L,SYSOBJECTS O WHERE L.TABLE_ID=O.ID AND BLOCKED=1;\n\n```\n\n4.  查询阻塞。\n\n```\nWITH LOCKS\n     AS (SELECT O.NAME,L.*,S.SESS_ID,S.SQL_TEXT,S.CLNT_IP,S.LAST_SEND_TIME\n           FROM V$LOCK L, SYSOBJECTS O, V$SESSIONS S\n          WHERE L.TABLE_ID = O.ID AND L.TRX_ID = S.TRX_ID),\n     LOCK_TR\n     AS (SELECT TRX_ID WT_TRXID, TID BLK_TRXID\n           FROM LOCKS\n          WHERE BLOCKED = 1),\n     RES\n     AS (SELECT SYSDATE STATTIME,T1.NAME,T1.SESS_ID WT_SESSID,S.WT_TRXID,\n                T2.SESS_ID BLK_SESSID,S.BLK_TRXID,T2.CLNT_IP,\n                SF_GET_SESSION_SQL (T1.SESS_ID) FULSQL,\n                DATEDIFF (SS, T1.LAST_SEND_TIME, SYSDATE) SS,\n                T1.SQL_TEXT WT_SQL\n           FROM LOCK_TR S, LOCKS T1, LOCKS T2\n          WHERE     T1.LTYPE = \'OBJECT\'\n                AND T1.TABLE_ID <> 0\n                AND T2.LTYPE = \'OBJECT\'\n                AND T2.TABLE_ID <> 0\n                AND S.WT_TRXID = T1.TRX_ID\n                AND S.BLK_TRXID = T2.TRX_ID)\nSELECT DISTINCT WT_SQL,CLNT_IP,SS,WT_TRXID,BLK_TRXID\n  FROM RES;\n\n```', '', 0, 0, 7, 0, 0, 0, 1674873108752, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.69', '::ffff:172.17.0.1', 1674873108752, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (80, 0, 9, 2, '达梦-初始化参数BLANK_PAD_MODE', '初始化参数 BLANK\\_PAD\\_MODE 的具体含义是什么？[](about:blank#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%82%E6%95%B0BLANK-PAD-MODE%E7%9A%84%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88-)\n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nBLANK\\_PAD\\_MODE 主要用于 Oracle 数据的兼容，达梦默认设置 BLANK\\_PAD\\_MODE=0，即在做数据对比时，默认会截断字符结尾的空格，而 Oracle 默认是会识别到字符结尾的空格。  \n设置如下场景验证：\n\n```\n1. 在BLANK_PAD_MODE=0时\nSQL> create table student(id int, name varchar(20));\nSQL> insert into student values (1,\'blank \');\nSQL> commit;\nSQL> insert into student values (1,\'blank\');\nSQL> commit;\nSQL> create unique index idx_test_blank on student(name);\ncreate unique index idx_test_blank on student(name);\n[-6612]:违反唯一性约束.\n已用时间: 4.925(毫秒). 执行号:0.\n\n2. 在BLANK_PAD_MODE=1时，同样的表和数据\n登录使用时间 : 4.018(ms)\ndisql V8\nSQL> create unique index idx_test_blank on student(name);\n操作已执行\n已用时间: 5.721(毫秒). 执行号:50700.\n\n```\n\n执行创建唯一索引会成功；', '', 0, 0, 5, 0, 0, 0, 1677113498602, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.46', '::ffff:172.17.0.1', 1677113498602, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (81, 0, 9, 2, '达梦-语法兼容性参数COMPATIBLE_MODE', '如何修改兼容性参数，使达梦对 ORACLE 语法的兼容性更高[](about:blank#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8F%82%E6%95%B0-%E4%BD%BF%E8%BE%BE%E6%A2%A6%E5%AF%B9-ORACLE-%E8%AF%AD%E6%B3%95%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%9B%B4%E9%AB%98)\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n**【问题解答】**：\n\nDM 提供了 COMPATIBLE\\_MODE 参数来设置数据库的兼容性模式，0：不兼容，1：兼容 SQL92 标准，2：部分兼容 ORACLE，3：部分兼容 MS SQL SERVER，4：部分兼容 MYSQL， 5：兼容 DM6，6：部分兼容 TERADATA。该参数默认为 0，修改方式有两种：\n\n*   在 dm.ini 文件中修改 COMPATIBLE\\_MODE 参数的值。  \n    \\+ 利用 SQL 语句修改 COMPATIBLE\\_MODE 参数的值。\n\n```\nSP_SET_PARA_VALUE(2,\'COMPATIBLE_MODE\',2);\n或\nALTER SYSTEM SET \'COMPATIBLE_MODE\'=2 SPFILE;\n\n```\n\n该参数为静态参数，需要重启数据库后生效。\n\n> 达梦数据库默认NULL与空字符串不等价；\nSP_SET_PARA_VALUE(2,‘COMPATIBLE_MODE’,2)；\n改数据库兼容oracle，重启库生效。\n空字符串会被当作null。', '', 0, 0, 8, 0, 0, 0, 1677113813916, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36 Edg/110.0.1587.46', '::ffff:172.17.0.1', 1677113813916, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (82, 0, 7, 2, 'SqlSugar-半扩展函数', '```\n/例1：\n Where(it=>it.IDCard==SqlFunc.MappingColumn(default(string), \"Sf_Translate(IdCard, IdType)\")\n//生成的Sql如下 \n//IDCard=Sf_Translate(IdCard, IdType)\n \n//例2：\n.GroupBy(it => SqlFunc.MappingColumn(default(string), \" CONVERT(varchar(10),t.F_OutTime, 120)\"))\n//生成的Sql如下\n//CONVERT(varchar(10),t.F_OutTime, 120)\n \n//例3: 部分表达式SQL\nvar sql=\" id>1 \";\nWhere(it=> SqlFunc.MappingColumn(default(bool), sql)  || it.Name==\"a\")\n//生成的Sql如下\n// id>1 or name=\'a\'\n \n//例4: 全部SQL\nvar sql=\" id>1 \";\nWhere(sql)\n```', '', 0, 0, 4, 0, 0, 0, 1679274180275, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.44', '::ffff:172.17.0.1', 1679274180275, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (83, 0, 1, 11, 'datetimebox 日期控件绑定双击日期选择时间', 'easyui自带的datetimebox日期控件选择日期后必选点击确定键才能够关闭日期面板，对于不需要选择时分秒时间的场景非常不方便，修改源码可以给日期绑定双击直接关闭日期面板，并选中当前日期。\n\n源码修改\neasyui版本：jQuery EasyUI 1.4.4\n\n修改代码位置：\n\n全文件搜索 \"click.calendar\"定位在触发单击日期事件，在单击事件后继续添加如下代码：\n\n------------------------------------\n\n``` language\n  .bind(\"dblclick.calendar\",function(e){\n        var t = _562(e.target);\n        if(t.hasClass(\"calendar-day\")){\n            var clickOk=$(_560).parent().siblings(\".datebox-button\").find(\"a[datebox-button-index=\\\'1\\\']\");\n            clickOk.trigger(\"click\");\n        }\n    });//注意此处_560为日期面板对象\n```\n------------------------------------\n添加好后就可以实现带时间的日期控件双击选中效果了', '', 0, 0, 3, 1, 0, 0, 1684293720471, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Edg/111.0.1661.44', '::ffff:172.17.0.1', 1681719080003, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (84, 0, 7, 2, 'NPOI帮助类、包括解析导入excel文件内容', '```\n    public class NpoiHelper\n    {\n        /// <summary>\n        /// 合并单元格\n        /// </summary>\n        /// <param name=\"sheet\">excel sheet</param>\n        /// <param name=\"firstRow\">开始行</param>\n        /// <param name=\"lastRow\">结束行</param>\n        /// <param name=\"firstCell\">开始列</param>\n        /// <param name=\"lastCell\">结束列</param>\n        public static void MergeCell(XSSFSheet sheet, int firstRow, int lastRow, int firstCell, int lastCell)\n        {\n            sheet.AddMergedRegion(new CellRangeAddress(firstRow, lastRow, firstCell, lastCell));\n        }\n        /// <summary>\n        /// 设置单元格\n        /// </summary>\n        /// <param name=\"row\">行</param>\n        /// <param name=\"columnindex\">列</param>\n        /// <param name=\"value\">设置值</param>\n        /// <param name=\"style\">样式</param>\n        public static void SetCellValue(XSSFRow row, int columnindex, object value, ICellStyle style)\n        {\n            if (value == null)\n            {\n                SetStringCell(row, columnindex, \"\", style);\n                return;\n            }\n            var type = value.GetType().ToString();\n            switch (type)\n            {\n                case \"System.String\":\n                    SetStringCell(row, columnindex, value.ToString(), style);\n                    break;\n                case \"System.Double\":\n                case \"System.Decimal\":\n                    SetNumberCell(row, columnindex, Convert.ToDouble(value), style);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /// <summary>\n        /// 设置数字型单元格\n        /// </summary>\n        /// <param name=\"row\">行</param>\n        /// <param name=\"columnindex\">列</param>\n        /// <param name=\"value\">值</param>\n        /// <param name=\"style\">样式</param>\n        public static void SetNumberCell(XSSFRow row, int columnindex, double value, ICellStyle style)\n        {\n            ICell cell = row.CreateCell(columnindex);\n            cell.SetCellValue(value);\n            cell.CellStyle = style;\n        }\n        /// <summary>\n        /// 设置字符串型单元格\n        /// </summary>\n        /// <param name=\"row\">行</param>\n        /// <param name=\"columnindex\">列</param>\n        /// <param name=\"value\">值</param>\n        /// <param name=\"style\">样式</param>\n        public static void SetStringCell(XSSFRow row, int columnindex, string value, ICellStyle style)\n        {\n            ICell cell = row.CreateCell(columnindex);\n            cell.SetCellValue(value);\n            cell.CellStyle = style;\n        }\n        /// <summary>\n        /// 设置单元格公式\n        /// </summary>\n        /// <param name=\"row\"></param>\n        /// <param name=\"columnindex\"></param>\n        /// <param name=\"formula\"></param>\n        /// <param name=\"style\"></param>\n        public static void SetCellFormula(XSSFRow row, int columnindex, string formula, ICellStyle style)\n        {\n            ICell cell = row.CreateCell(columnindex);\n            cell.SetCellFormula(formula);\n            cell.CellStyle = style;\n        }\n        /// <summary>\n        /// 创建单元格样式\n        /// </summary>\n        /// <param name=\"wk\">工作簿</param>\n        /// <param name=\"verticalAlignment\">垂直方向</param>\n        /// <param name=\"alignment\">水平方向</param>\n        /// <param name=\"borderLeft\">左边边框样式</param>\n        /// <param name=\"borderTop\">顶部边框样式</param>\n        /// <param name=\"borderRight\">右边边框样式</param>\n        /// <param name=\"borderBottom\">底部边框样式</param>\n        /// <param name=\"font\">字体</param>\n        /// <returns></returns>\n        public static ICellStyle CreateCellStyle(IWorkbook wk,\n            VerticalAlignment verticalAlignment = VerticalAlignment.Center,\n            HorizontalAlignment alignment = HorizontalAlignment.Center,\n            BorderStyle borderLeft = BorderStyle.Thin,\n            BorderStyle borderTop = BorderStyle.Thin,\n            BorderStyle borderRight = BorderStyle.Thin,\n            BorderStyle borderBottom = BorderStyle.Thin,\n            IFont font = null)\n        {\n            ICellStyle style = wk.CreateCellStyle();\n            style.VerticalAlignment = verticalAlignment;\n            style.Alignment = alignment;\n            style.BorderBottom = borderBottom;\n            style.BorderLeft = borderLeft;\n            style.BorderRight = borderRight;\n            style.BorderTop = borderTop;\n            if (font != null)\n            {\n                style.SetFont(font);\n            }\n            return style;\n        }\n\n        /// <summary>\n        /// 创建单元格样式\n        /// gjl 2023.3.1\n        /// </summary>\n        /// <param name=\"wk\">工作簿</param>\n        /// <param name=\"verticalAlignment\">垂直方向</param>\n        /// <param name=\"alignment\">水平方向</param>\n        /// <param name=\"borderLeft\">左边边框样式</param>\n        /// <param name=\"borderTop\">顶部边框样式</param>\n        /// <param name=\"borderRight\">右边边框样式</param>\n        /// <param name=\"borderBottom\">底部边框样式</param>\n        /// <param name=\"font\">字体</param>\n        /// <returns></returns>\n        public static ICellStyle CreateCellStyles(IWorkbook wk,\n           VerticalAlignment verticalAlignment = VerticalAlignment.Center,\n           HorizontalAlignment alignment = HorizontalAlignment.Center,\n           BorderStyle borderLeft = BorderStyle.Thin,\n           BorderStyle borderTop = BorderStyle.Thin,\n           BorderStyle borderRight = BorderStyle.Thin,\n           BorderStyle borderBottom = BorderStyle.Thin,\n           IFont font = null)\n        {\n            ICellStyle style = wk.CreateCellStyle();\n            style.VerticalAlignment = verticalAlignment;\n            style.Alignment = alignment;\n            style.BorderBottom = borderBottom;\n            style.BorderLeft = borderLeft;\n            style.BorderRight = borderRight;\n            style.BorderTop = borderTop;\n            style.WrapText = true;    //自动换行\n            if (font != null)\n            {\n                style.SetFont(font);\n            }\n            return style;\n        }\n\n        public static ICellStyle CreateCellStyle(IWorkbook wk,\n            VerticalAlignment verticalAlignment = VerticalAlignment.Center,\n            HorizontalAlignment alignment = HorizontalAlignment.Center,\n            IFont font = null)\n        {\n            ICellStyle style = wk.CreateCellStyle();\n            style.VerticalAlignment = verticalAlignment;\n            style.Alignment = alignment;\n            style.BorderBottom = BorderStyle.Thin;\n            style.BorderLeft = BorderStyle.Thin;\n            style.BorderRight = BorderStyle.Thin;\n            style.BorderTop = BorderStyle.Thin;\n            if (font != null)\n            {\n                style.SetFont(font);\n            }\n            return style;\n        }\n\n        /// <summary>\n        /// 创建字体\n        /// </summary>\n        /// <param name=\"wk\">工作簿</param>\n        /// <param name=\"FontName\">字体</param>\n        /// <param name=\"FontHeight\">字号</param>\n        /// <param name=\"IsBold\">是否加粗</param>\n        /// <param name=\"IsItalic\">是否斜体</param>\n        /// <param name=\"IsStrikeout\">是否加删除线</param>\n        /// <param name=\"Color\">字体颜色</param>\n        /// <returns></returns>\n        public static IFont CreateFont(IWorkbook wk,\n            string FontName = \"宋体\",\n            double FontHeight = 14,\n            bool IsBold = false,\n            bool IsItalic = false,\n            bool IsStrikeout = false,\n            XSSFColor Color = null)\n        {\n            IFont font = wk.CreateFont();\n            font.FontName = FontName;\n            font.FontHeight = FontHeight;\n            font.IsBold = IsBold;\n            font.IsItalic = IsItalic;\n            font.IsStrikeout = IsStrikeout;\n            if (Color != null)\n            {\n                font.Color = Color.Indexed;\n            }\n            return font;\n        }\n\n        /// <summary>\n        /// 获取单元格的值\n        /// </summary>\n        /// <param name=\"cell\"></param>\n        /// <returns></returns>\n        public static string GetCellValue(ICell cell)\n        {\n            string value = string.Empty;\n            if (cell.CellType == CellType.Numeric && DateUtil.IsCellDateFormatted(cell))\n            {\n                value = cell.DateCellValue.ToString();\n            }\n            else if (cell.CellType == CellType.Numeric)\n            {\n                value = cell.NumericCellValue.ToString();\n            }\n            else if (cell.CellType == CellType.String)\n            {\n                value = cell.StringCellValue;\n            }\n            return value.Trim();\n        }\n\n        /// <summary>\n        /// 读取导入文件的数据\n        /// </summary>\n        /// <typeparam name=\"T\">数据实体模型</typeparam>\n        /// <param name=\"filePath\">导入文件地址</param>\n        /// <param name=\"columns\">列名：T实体的字段名</param>\n        /// <param name=\"startRowNum\">数据开始行号</param>\n        /// <param name=\"columnNameRowNum\">列名行号</param>\n        /// <param name=\"defaultSheetIndex\">页签序号</param>\n        /// <returns></returns>\n        /// <exception cref=\"Exception\"></exception>\n        public static List<T> AnalysisImportData<T>(string filePath, Dictionary<string, string> columns, int startRowNum = 1\n            , int columnNameRowNum = 0\n            , int defaultSheetIndex = 0) where T : new()\n        {\n            if (string.IsNullOrWhiteSpace(filePath))\n                throw new Exception(\"导入文件地址不能为空\");\n            if (columns == null || columns.Keys.Count == 0)\n                throw new Exception(\"导入文件列名配置不能为空\");\n            List<T> datas = new List<T>();\n            using (FileStream fs = File.OpenRead(filePath))\n            {\n                IWorkbook wk = null;\n                if (filePath.EndsWith(\"xls\"))\n                {\n                    wk = new HSSFWorkbook(fs);\n                }\n                else\n                {\n                    wk = new XSSFWorkbook(fs);\n                }\n                \n                ISheet ws = wk.GetSheetAt(defaultSheetIndex);\n                // 获取列名行\n                var columnNameRow = ws.GetRow(columnNameRowNum);\n                if (columnNameRow == null)\n                    throw new Exception(\"未获取到列名行数据\");\n                // 列位置数据\n                Dictionary<string, int> columnPosition = new Dictionary<string, int>();\n                int index = 0;\n                foreach (var cell in columnNameRow.Cells)\n                {\n                    var columnName = GetCellValue(cell);\n                    if (!string.IsNullOrWhiteSpace(columnName))\n                    {\n                        if (columnPosition.ContainsKey(columnName))\n                        {\n                            columnPosition[columnName] = index;\n                        }\n                        else\n                        {\n                            columnPosition.Add(columnName, index);\n                        }\n                    }\n                    index++;\n                }\n                // 读取导入数据\n                for (int i = startRowNum; i < ws.PhysicalNumberOfRows; i++)\n                {\n                    var row = ws.GetRow(i);\n                    if (row == null) continue;\n                    T entity = new T();\n                    bool hasValue = false;\n                    foreach (var key in columns.Keys)\n                    {\n                        if (!columnPosition.ContainsKey(key)) \n                            continue;\n                        var cell = row.GetCell(columnPosition[key]);\n                        if (cell == null)\n                            continue;\n                        var field = columns[key];\n                        var fieldValue = GetCellValue(cell);\n                        if (!string.IsNullOrWhiteSpace(fieldValue))\n                        {\n                            hasValue = true;\n                        }\n                        // 设置实体值\n                        if (cell != null && cell.CellType == CellType.Numeric && DateUtil.IsCellDateFormatted(cell))\n                        {\n                            // 将单元格的值格式化为时间格式\n                            DateTime dateValue = cell.DateCellValue;\n                            string dateString = dateValue.ToString(\"yyyy-MM-dd HH:mm:ss\");\n                            entity.SetPropertyValue(field, dateString);\n                        }\n                        else\n                        {\n                            entity.SetPropertyValue(field, fieldValue);\n                        }\n                    }\n                    if (hasValue)\n                    {\n                        datas.Add(entity);\n                    }\n                }\n            }\n            return datas;\n        }\n    }\n```', '', 0, 0, 2, 0, 0, 0, 1684293622503, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42', '::ffff:172.17.0.1', 1684293622503, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (85, 0, 7, 2, 'Span<T>', '引言\n--\n\n`Span<T>` 是C# 中的一种结构体，它是一种内存安全的类型，可以用来表示连续的内存区域。`Span<T>` 可以被用于访问和操作数组、堆上分配的内存和栈上分配的内存。使用 `Span<T>` 可以避免不必要的内存拷贝，从而提高性能。\n\n对数组使用Span\n---------\n\n如果需要快速访问托管或非托管的连续内存，可以使用 `Span<T>`结构。`Span<T>` 结构表示存储连续的内存。所以使用它的数据结构一般也使用连续的内存。例如：\n\n*   数组\n    \n*   长字符串(实际上也是数组)\n    \n\n**「使用 `Span<T>`，可以直接访问数组元素。且数组的元素不会复制，可以直接使用它们，这样比复制效率要高」**。例如下面的代码：\n\n```\nstatic void Main(string[] args)\n{\n    int[] source = new int[]\n    {\n        1, 2, 3\n    };\n    int[] arr = new int[]\n    {\n        source[0], source[1], source[2]\n    };\n    arr[0] = 33;\n    Console.WriteLine($ \"The first element of source is {source[0]}\");\n    Console.WriteLine($ \"The first element of arr is {arr[0]}\");\n    Span < int > span = new(source);\n    span[0] = 11;\n    Console.WriteLine($ \"The first element of source is {arr[0]}\");\n    Console.WriteLine($ \"The first element of span is {span[0]}\");\n    Console.ReadLine();\n}  \n```\n\n可以先猜测以下上述代码的输出是什么？\n\n输出：\n\n```\nThe first element of source is 1   \nThe first element of arr is 33   \nThe first element of source is 11   \nThe first element of span is 11   \n```\n\n上述代码段中，先声明了一个源数组 `source` 和一个数组 `arr` ,并将 `source` 的值复制给 `arr` 。然后修改 `arr` 中的第一个元素值为33，可以看到结果 `arr` 的第一个元素已经改变为33，`source` 保持不变。然后又声明了一个 `Span<int>` ，它引用 `source` 数组。因为`Span<T>`是直接访问数组元素，而不是复制元素，所以修改 `span` 中的第一个元素为11， `source` 中的第一个元素也被修改为11。\n\n创建切片\n----\n\n`Span<T>` 的一个强大特性是，可以使用它访问数组的部分或切片。使用切片时，不会复制数组元素，它们是从span 中直接访问的。\n\n有如下代码段：\n\n```\nstatic void Main(string[] args)\n{\n    int[] source = {\n        1, 6, 23, 76, 88, 213\n    };\n    Span < int > span1 = new Span < int > (source, start: 1, length: 4);\n    Span < int > span2 = span1.Slice(start: 1, length: 3);\n    DisplaySpan(\"span1 contains the elements:\", span1);\n    DisplaySpan(\"span2 contains the elements:\", span2);\n    Console.ReadLine();\n}\nprivate static void DisplaySpan(string content, Span < int > span1)\n{\n    Console.Write(content);\n    foreach(var item in span1)\n    {\n        Console.Write(item + \",\");\n    }\n    Console.WriteLine();\n}  \n```\n\n下面的代码片段展示了创建切片的两种方法。\n\n1.  除默认构造函数传参数组之外，另一种重载是直接使用构造函数传递源数组，起始位置和长度。例如上述代码中 `new Span<int>(source, start: 1, length: 4)` 它表示在源数组中从第2个元素开始访问数组的4个元素。\n    \n2.  直接从span中再次切片，传入起始位置和长度，例如上述代码中`span1.Slice(start: 1, length: 3)`表示从span1中第2个元素开始包含3个元素的切片。\n    \n\n输出：\n\n```\nspan1 contains the elements:6,23,76,88,   \nspan2 contains the elements:23,76,88,   \n```\n\n这里使用时一定注意传入参数 `start` 和 `length` 后的越界问题。\n\n使用Span改变值\n---------\n\n在文章开头，介绍了如何使用 `Span<T>` 的索引器，直接更改由 span 直接引用的数组元素，实际上它还有其他改变值的方法。\n\n例如：\n\n*   `Slice(int start, int length)`：返回一个新的 `Span<T>`，它表示从 `Span<T>` 的指定起始位置开始的指定长度部分。可以使用该方法来获取或更改 `Span<T>` 中的子集。\n    \n*   `Clear()`：将 `Span<T>` 中的所有元素设置为默认值 `default<T>`。\n    \n*   `Fill(T value)`：将 `Span<T>` 中的所有元素设置为指定的值。\n    \n*   `CopyTo(Span<T> destination)`：将 `Span<T>` 中的所有元素复制到指定的目标 `Span<T>`。\n    \n*   `CopyTo(T[] destination)`：将 `Span<T>` 中的所有元素复制到指定的目标数组。\n    \n*   `Reverse()`：反转 `Span<T>` 中的元素顺序。\n    \n*   `Sort()`：对 `Span<T>` 中的元素进行排序。\n    \n\n请注意，这些方法都是按值传递的，而不是按引用传递的。这意味着在调用这些方法时，将复制 `Span<T>` 中的值。如果您想要修改原始 `Span<T>` 中的值，请使用引用传递方式，例如使用 `ref Span<T>` 参数。\n\n只读的Span\n-------\n\n如果只需要对数组片段进行读访问，则可以使用 `ReadOnlySpan<T>`,可以使用它来读取内存块中的数据，而不必担心其他代码同时修改了该内存块。\n\n对于 `ReadOnlySpan<T>` ，它的索引器是只读的，所以这种类型没有提供 `Clear` 和 `Fill` 方法，但是可以调用 `CopyTo()` 方法，将 `ReadOnlySpan<T>` 的内容复制到 `Span<T>` 。\n\n此外，它支持隐式转换，由数组或 `Span<T>` 直接赋值给 `ReadOnlySpan<T>`，如下：\n\n```\nstatic void Main(string[] args)\n{\n    int[] source = {\n        1, 6, 23, 76, 88, 213\n    };\n    Span < int > span = new Span < int > (source);\n    DisplaySpan(\"span contains the elements:\", span);\n    ReadOnlySpan < int > readOnlySpan = source;\n    DisplaySpan(\"readOnlySpan contains the elements:\", readOnlySpan);\n    Console.ReadLine();\n}\nprivate static void DisplaySpan(string content, ReadOnlySpan < int > span1)\n{\n    Console.Write(content);\n    foreach(var item in span1)\n    {\n        Console.Write(item + \",\");\n    }\n    Console.WriteLine();\n}\n```\n\n输出：\n\n```\nspan contains the elements:1,6,23,76,88,213,   \nreadOnlySpan contains the elements:1,6,23,76,88,213,   \n```\n\n与 `Span<T>` 相比，`ReadOnlySpan<T>` 的一个重要的限制是不允许修改其包含的内存块。这使得 `ReadOnlySpan<T>` 更适合于读取内存块中的数据，而不是修改它们。', '', 0, 0, 2, 0, 0, 0, 1684302471333, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.42', '::ffff:172.17.0.1', 1684302471333, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (86, 0, 5, 11, '新建快捷方式', '## 桌面右键  新建 快捷方式\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8887-bc36-c6e3-07d5-883e7d5e789b_image.png)\n\n## 输入   http://183.214.218.135:7312/Login\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8888-11cc-ef1a-4878-b75b45509851_image.png)\n\n## 点击下一步\n## 重命名为 长沙新港平板作业\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8888-990f-0af9-aba9-f3a6fe8ff65b_image.png)\n\n## 点击快捷方式 右键\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b888e-cc8d-57e8-8485-96ef28f16fb9_image.png)\n## 点击更改图标\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8890-39fc-5ca1-1ce9-608748fe4871_image.png)\n## 点击浏览  选择 长沙新港平板作业.ico\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8895-1d31-b6da-7643-d84989da1f44_image.png)\n\n## 最后就变成这样\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8893-54c0-4d68-7d83-f9ffbed83daf_image.png)\n\n长沙新港平板作业.ico放在下面 右键点击保存\n', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a0b8893-8ddd-f507-705f-648bbc3d9a5b_长沙新港平板作业.ico\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0b8893-8ddd-f507-705f-648bbc3d9a5b_长沙新港平板作业.ico\"}]', 0, 0, 14, 0, 0, 0, 1685612979954, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.50', '::ffff:172.17.0.1', 1685612979954, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (87, 0, 9, 2, 'ORACLE关于参数_optimizer_use_feedback', '问题背景：  \n有时候会遇到比较奇怪的现象，首次执行sql速度很快，后面再执行就变得很慢\n\n正常来讲同样的一条SQL查询语句，根据执行计划，第一次查询完以后，后续再执行相同的语句应该很快才对。  \n可是，现实却是第一次查询不慢（优化后2秒内查询），第二次以后就很慢。\n\n  \n对于执行计划中，在note部分有“cardinality feedback used for this statement”，表示使用了基数反馈（Cardinality Feedback）  \n基数反馈（Cardinality Feedback）是 Oracle 11.2 中引入的新特性，主要针对统计信息旧、无直方图或有直方图但仍基数计算不准确的情况，  \nCardinality 基数的计算直接影响到后续的 JOIN COST 等重要的成本计算评估，造成 CBO 选择错误的执行计划。但是该参数存在不稳定因素，可能会带来执行效率的问题，建议关闭\n\n```\nalter system set \"_optimizer_use_feedback\"=FALSE;\n```\n\n此处先在session级别关闭\n\n```\nalter session set \"_optimizer_use_feedback\"=FALSE;\n```\n\n接下来反复执行sql，发现执行时间恢复正常', '', 0, 0, 3, 0, 0, 0, 1688541816383, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.67', '::ffff:172.17.0.1', 1688541816383, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (88, 0, 9, 2, 'ORACLE密码过期', '- oracle 密码默认有效期180天，超时后会报错如下\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c550a-0960-2e41-ac89-094457ab5b9f_ca4e091355a0e86f82e4a313d1784a5.png)\n- 用 sysdba 账号登录后，查看密码有效期\n```\nSELECT * FROM dba_profiles WHERE profile=\'DEFAULT\' AND resource_name=\'PASSWORD_LIFE_TIME\' \n```\n- 修改密码有效期，永不过期\n```\nALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED \n```\n- 修改密码\n```\nalter user zxx identified by zxx;\n```', '', 0, 0, 2, 0, 0, 0, 1689044121200, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.67', '::ffff:172.17.0.1', 1689044121200, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (89, 0, 7, 2, '如何在 .NET Framework 中实现一个线程安全的 System.Random 对象？', '`System.Random` 类表示伪随机数生成器，这是一种能够产生满足某些随机性统计要求的数字序列的算法。\n\n```\nvar rand = new Random();\nvar i = rand.Next();\nConsole.WriteLine(i);\n```\n\n如果要在多线程环境下使用上述代码：\n\n```\nParallel.For(0, 10, x =>\n{\n    var rand = new Random();\n    var i = rand.Next();\n    Console.WriteLine(i);\n});\n```\n\n在 .NET Framework 平台上，会产生相同的输出（即所有的随机结果都是相同的）：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c7394-3bc1-999b-f543-499c694a063e_image.png)\n\n  \n\n如果目标平台是 .NET 6.0 及以上，可以用以下代码替代：\n\n```\nParallel.For(0, 10, x =>\n{\n    var rand = Random.Shared;\n    var i = rand.Next();\n    Console.WriteLine(i);\n});\n```\n\n此时，输出结果是符合预期的。\n\n实际上，如果在 .NET 6.0 平台上即使每次都创建新的 Random 对象，输出结果也是符合预期的：  \n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c7394-e169-8830-933e-fb9c22b73f29_image.png)\n\n为了可以在 .NET Framework 及 .NET 6.0 之前的平台上获取正确的输出， 可以先尝试在多个线程中共用一个 Random 对象：  \n\n```\nConsole.WriteLine(\"Dotnet Version: \" + Environment.Version);\nvar rand = new Random();\nParallel.For(0, 10, x =>\n{\n    var i = rand.Next();\n    Console.WriteLine(i);\n});\n```\n\n这种方式似乎可以，因为小规模测试获得了正确的结果：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c7395-a9d3-4b95-695f-b1654ced03c6_image.png)\n  \n\n以下代码创建了 10 个并发，并在每个并发中尝试获取了 10000 个随机数。然后将结果为零的数据统计出来：\n\n```\nConsole.WriteLine(\"Dotnet Version: \" + Environment.Version);\nvar rand = new Random();\nParallel.For(0, 10, _ =>\n{\n    var numbers = new int[10_000];\n    for (int i = 0; i < numbers.Length; ++i)\n    {  \n        numbers[i] = rand.Next(); //获取 10000 个随机数，引发线程安全问题。\n    }\n    var numZeros = numbers.Count(x => x == 0); // 统计异常数据\n    Console.WriteLine($\"得到 {numZeros} 个为零的结果\");\n});\n```\n\n运行结果如下：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c7396-f67f-771d-f451-ecfbb9819105_image.png)\n\n这表明：System.Random 在高并发下确实出现了异常。如果使用了 Release 发布，则异常结果会更多。\n\n如果我们愿意用自己的类型来包装 `Random`，我们可以创建一个更好的解决方案。在下面的示例中，我们使用 `[ThreadStatic]` 为每个线程创建一个 `Random` 实例。这意味着我们重复使用 `Random` 实例，但是所有的访问总是来自单线程，因此保证了线程安全。这样我们最多创建 `n` 个实例，其中 `n` 是线程数。\n\n```\nusing System;\ninternal static class ThreadLocalRandom\n{\n    [ThreadStatic]\n    private static Random _local; \n\n    public static Random Instance\n    {\n        get\n        {\n            if (_local is null)\n            {\n                _local = new Random();\n            }\n\n            return _local;\n        }\n    }\n}\n```\n\n使用方式如下：\n\n```\nConsole.WriteLine(\"Dotnet Version: \" + Environment.Version);\nParallel.For(0, 10, _ =>\n{\n  var numbers = new int[10_000];\n  for (int i = 0; i < numbers.Length; ++i)\n  {\n    numbers[i] = ThreadLocalRandom.Instance.Next(); //获取 10000 个随机数，引发线程安全问题。\n  }\n\n  var numZeros = numbers.Count(x => x == 0); // 统计异常数据\n  Console.WriteLine($\"得到 {numZeros} 个为零的结果\");\n});\n```\n\n请注意，在这个简单的示例中，如果在线程之间传递 `ThreadLocalRandom.Instance`，仍然有可能遇到线程安全问题。例如，下面显示了与之前相同的问题：\n\n```\nConsole.WriteLine(\"Dotnet Version: \" + Environment.Version);\nvar rand = ThreadLocalRandom.Instance;\nParallel.For(0, 10, _ =>\n{\n  var numbers = new int[10_000];\n  for (int i = 0; i < numbers.Length; ++i)\n  {\n    numbers[i] = rand.Next(); //获取 10000 个随机数，引发线程安全问题。\n  }\n\n  var numZeros = numbers.Count(x => x == 0); // 统计异常数据\n  Console.WriteLine($\"得到 {numZeros} 个为零的结果\");\n});\n\n```\n\n一个简单的方案就是隐藏 Random 实例，仅暴露 Next 方法：\n\n```\nusing System;\n\ninternal static class ThreadSafeRandom\n{\n    [ThreadStatic]\n    private static Random _local;\n\n    private static Random Instance\n    {\n        get\n        {\n            if (_local is null)\n            {\n                _local = new Random();\n            }\n\n            return _local;\n        }\n    }\n\n    public static int Next() => Instance.Next();\n}\n```\n\n但这仍然无法解决在 .NET Framework 上因为系统时钟的分辨率过低造成的重复值问题：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c7398-2514-2c08-96d9-48e4c1f18142_image.png)\n\n  \n\n可以看到 1147840056 重复出现了很多次。\n\n要解决该问题，只要在创建 `Random` 对象时，指定不同的随机种子即可：\n\n```\nusing System;\n\ninternal static class ThreadSafeRandom\n{\n    [ThreadStatic]\n    private static Random _local;\n    private static readonly Random Global = new Random(); // 全局实例，用于生成随机种子\n\n    private static Random Instance\n    {\n        get\n        {\n            if (_local is null)\n            {\n                int seed;\n                lock (Global) // 确保 Global 不会被并发访问\n                {\n                    seed = Global.Next();\n                }\n\n                _local = new Random(seed);\n            }\n\n            return _local;\n        }\n    }\n\n    public static int Next() => Instance.Next();\n}\n```\n\n如果您使用的是 .NET 6+ ，我仍然建议您使用内置的 `Random.Shared`，但如果您没有那么幸运，您可以使用 `ThreadSafeRandom` 来解决您的问题。\n\n  \n\n如果您的目标是 .NET 6 和其他框架，您可以使用 #if 指令将您的 .NET 6 实现委托给 `Random.Shared` ，从而保持调用干净。\n', '', 0, 0, 4, 0, 0, 0, 1689556627841, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.79', '::ffff:172.17.0.1', 1689556627841, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (90, 0, 7, 2, '.NET开源库、实用工具、组件分享', '- `Jint`\n\n  如果您想在您的 .NET 程序中使用 Javascript，那么我推荐您使用 Jint。\n\n  Jint 是适用于 .NET 的 开源 Javascript 解释器，功能强大，它可以在任何现代 .NET 平台上运行，因为它支持 .NET Standard 2.0 和 .NET 4.6.2 以及更高版本），包括最新的 .NET 6。\n\n  因为 Jint 既不生成任何 .NET 字节码也不使用 DLR，所以在执行比较少的代码时，它的运行效率很快。\n\n  [GitHub](https://github.com/sebastienros/jint)\n\n\n---------------\n- `Ip2region`\n\n  ip2region - 是一个离线IP地址定位库和IP定位数据管理框架，10微秒级别的查询效率，提供了众多主流编程语言的 xdb 数据生成和查询客户端实现。\n\n  [GitHub](https://github.com/lionsoul2014/ip2region)\n\n----\n- `FluentFTP`\n \n  FluentFTP 是一个适用于 .NET 和 .NET Standard 的 FTP 和 FTPS 客户端。\n  并且针对速度进行了优化，没有外部依赖， 完全用 C# 编写。\n\n  完全支持 FTP、FXP、FTPS、带 TLS 1.3 的 FTPS、带客户端证书的 FTPS和FTPS 代理。\n全面支持 30 多种 FTP Server 类型。\n\n  支持各种文件和目录列表（Unix、Windows/IIS、Azure、Pure-FTPd、ProFTPD、Vax、VMS、OpenVMS、Tandem、HP NonStop Guardian、IBM z/OS 和 OS/400、Windows CE、Serv- U等）。\n\n  支持递归目录列出和进行目录删除。\n  通过进度跟踪可以轻松从服务器上传和下载文件。\n  创建、追加、读取、写入、重命名、移动和删除文件和文件夹。\n  异步支持，所有操作都可以使用 async await。\n\n  [GitHub](https://github.com/robinrodricks/FluentFTP)\n\n----\n\n- `Spectre.Console`\n  \n  一个.NET库，可以更容易地创建漂亮的、跨平台的控制台应用程序。\n  [GitHub](https://github.com/spectreconsole/spectre.console)\n\n---\n\n- `LoadTestToolbox`\n\n   用于负载测试web应用程序的轻量级工具，使用 .NET6 开发\n   [GitHub](https://github.com/ecoAPM/LoadTestToolbox)\n\n----\n\n- `QrCodeGenerator`\n  \n  QrCodeGenerator 是开源的 .NET 二维码生成库，它支持从文本字符串和字节数组生成二维码图片。\n\n  这个库是基于 .NET Standard 2.0 构建的，所以它可以在大多数现代 .NET 平台（.NET Core、.NET Framework、Mono 等）上运行，包括 .NET 6, .NET 7。\n [GitHub](https://github.com/manuelbl/QrCodeGenerator)\n\n---\n\n- `MethodTimer.Fody`\n  MethodTimer.Fody 是一个功能强大的库，可以用于测量 .NET 应用程序中的方法的执行时间。\n  \n  它使用 Fody 插件框架可以无缝集成到您的项目中，所以向代码中添加性能测量功能变得非常容易。\n  [GitHub](https://github.com/Fody/MethodTimer)\n\n---\n\n- `Clarity`\n  \n  微软Clarity是一款免费的网站分析工具，可以提供全面的用户行为分析和可视化数据，更好地理解用户。\n\n  Clarity 有很多功能，包括用户会话重放、热力图、点击地图、用户浏览路径追踪等，这些功能可以帮助您深入了解用户如何与您的网站互动，从而优化用户体验并提高转化率。\n  [GitHub](https://github.com/microsoft/clarity)', '[{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a0c741b-8f69-68af-ce4f-d93c901bffda_bou.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c741b-8f69-68af-ce4f-d93c901bffda_bou.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a0c741d-e6ab-5d55-55ff-1a8e5ebe451d_bou3.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c741d-e6ab-5d55-55ff-1a8e5ebe451d_bou3.png\"},{\"preview\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=preview_3a0c741d-e6c4-b1bc-73a3-5fb1aaaa6dad_bou2.png\",\"url\":\"http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0c741d-e6c4-b1bc-73a3-5fb1aaaa6dad_bou2.png\"}]', 0, 0, 53, 2, 0, 0, 1695799959933, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.79', '::ffff:172.17.0.1', 1689564669290, NULL, b'0', 1692066344095);
INSERT INTO `t_topic` VALUES (91, 0, 7, 2, '.NET基于WebUploader大文件分片上传、断网续传、秒传', '现在的项目开发基本上都用到了上传文件功能，或图片，或文档，或视频。\n\n  \n\n我们常用的常规上传已经能够满足当前要求了，然而有时会出现如下问题：\n\n  \n\n文件过大（比如1G以上），超出服务端的请求大小限制；\n\n  \n\n1.  请求时间过长，请求超时；\n    \n      \n    \n2.  传输中断，必须重新上传导致前功尽弃；\n    \n      \n    \n3.  设置了webconfig和iis后还是不能上传成功；\n    \n      \n    \n4.  不想使用FTP，只想用http。\n    \n\n我们这里只讲分片上传，至于断网续传和秒传已经写好Demo，下载地址放在文末，有兴趣的可以下载自己玩玩。\n\n  \n\n\n  \n\nhttp的网络请求中本身就已经具备了分片上传功能，那么什么是分片上传？我们来看看：\n\n  \n\n**分片上传原理**\n\n  \n\n片上传支持将一个文件切割为一系列特定大小的数据片，分别将这些小数据片上传到服务端，全部上传完后再在服务端将这些数据片合并成为一个资源。\n\n  \n\n分片上传引入了两个概念：块（Block）和片（Chunk）。每个块由一到多个片组成，而一个资源则由一到多个块组成。他们之间的关系可以用下图表述：\n\n  \n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0cd0d5-7b23-8976-52e1-6232fb093187_image.png)\n  \n\n**块和片**是上传过程中作为临时存储的单位。服务端会以约七天为单位的周期清除上传后未被合并为块(文件)的数据片(块)。\n\n  \n\n与分片上传相关的 API 有：创建块(mkblk)、上传片(bput)、创建文件(mkfile)。一个完整的分片上传流程可用下图表示：\n\n  \n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0cd0d5-c342-57c1-8db4-ba8a4328ff69_image.png)\n\n  \n\n其中的关键点如下：\n\n  \n\n将待上传的文件按预定义块大小切分为若干个块（每块大小不大于 4MB：块的大小可以自定义）。如果这个文件小于 4MB，就只有一个块。  \n\n  \n\n将每个块再按预定义的片大小切分为若干个片，先在服务端创建一个相应块（通过调用mkblk，并带上第一个片的内容），然后再循环将所有剩下的片全部上传（通过调用bput，从而完成一个块的上传）\n\n  \n\n在所有块上传完成后，通过调用mkfile将这些上传完成的块信息再严格的按顺序组装出一个逻辑资源的元信息，从而完成整个资源的分片上传过程。\n\n  \n\n在这个理论基础上，结合WebUploade插件（百度上传插件）和net mvc进行demo编写。\n\n\n\n**代码展示**\n\n  \n\n下载webuploader插件后引入项目中，主要引用文件：\n\n  \n\n```\n<script src=\"~/Scripts/jquery-1.10.2.min.js\"></script>  \n<link href=\"~/Content/webuploader.css\" rel=\"stylesheet\" />  \n<script src=\"~/Scripts/webuploader.js\"></script>  \n<script src=\"~/Scripts/bootstrap.min.js\"></script>\n```\n\n  \n\n**前端完整代码**\n\n  \n\n```\n<!DOCTYPE html>  \n<html xmlns=\"http://www.w3.org/1999/xhtml\">  \n<head>  \n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />  \n    <title></title>  \n</head>  \n<body>  \n<script src=\"~/Scripts/jquery-1.10.2.min.js\"></script>  \n<link href=\"~/Content/webuploader.css\" rel=\"stylesheet\" />  \n<script src=\"~/Scripts/webuploader.js\"></script>  \n<script src=\"~/Scripts/bootstrap.min.js\"></script>  \n<div id=\"uploader\" class=\"wu-example\">  \n    <!--用来存放文件信息-->  \n    <div id=\"thelist\" class=\"uploader-list\"></div>  \n    <div class=\"btns\">  \n        <div id=\"picker\">选择文件</div>  \n        <input id=\"ctlBtn\" type=\"button\" value=\"开始上传\" class=\"btn btn-default\" />  \n    </div>  \n</div>  \n    <table width=\"50%\" border=\"1\" class=\"fileList_parent\">  \n        <thead>  \n            <tr style=\"background-color:#DADADA\">  \n                <th>文件名称</th>  \n                <th>类型</th>  \n                <th>大小</th>  \n                <th>进度</th>  \n                <th>说明</th>  \n            </tr>  \n        </thead>  \n        <tbody class=\"fileList\">  \n        </tbody>  \n    </table>  \n</body>  \n</html>  \n<script>    var applicationPath = window.applicationPath === \"\" ? \"\" : window.applicationPath || \"../../\";  \n    var GUID = WebUploader.Base.guid();//一个GUID  \n    $(function () {  \n        var $ = jQuery;  \n        var $list = $(\'#thelist\');  \n        var uploader = WebUploader.create({  \n            // 选完文件后，是否自动上传。  \n            auto: false,  \n            // swf文件路径  \n            swf: applicationPath + \'../Content/Uploader.swf\',  \n            // 文件接收服务端。  \n            server: applicationPath + \'Home/Upload\',  \n            // 选择文件的按钮。可选。  \n            // 内部根据当前运行是创建，可能是input元素，也可能是flash.  \n            pick: \'#picker\',  \n            chunked: true,//开始分片上传  \n            chunkSize: 2048000,//每一片的大小  \n            formData: {  \n                guid: GUID //自定义参数，待会儿解释  \n            },  \n            // 不压缩image, 默认如果是jpeg，文件上传前会压缩一把再上传！  \n            resize: false  \n        });  \n        // 当有文件被添加进队列的时候  \n        uploader.on(\'fileQueued\', function (file) {  \n            $list.append(\'<div id=\"\' + file.id + \'\" class=\"item\">\' +  \n                \'<h4 class=\"info\">\' + file.name + \'</h4>\' +  \n                \'<p class=\"state\">等待上传...</p>\' +  \n                \'</div>\');  \n            var name = file.name;    //文件名  \n            var type = fileType(file.name);    //文件类型，获取的是文件的后缀  \n            var volume = bytesToSize(file.size);    //文件大小格式化  \n            var oTr = $(\"<tr></tr>\");  \n            var str = \'<td><cite title=\"\' + name + \'\">\' + name + \'</cite></td>\';  \n            str += \'<td>\' + type + \'</td>\';  \n            str += \'<td>\' + volume + \'</td>\';  \n            str += \'<td id=\"jintutiao\">\';  \n            str += \'<span id=\"baifenbi\"></span>0%\';  \n            str += \'</td>\';  \n            str += \'<td id=\"uploding\">等待上传</td>\';  \n            $(\".fileList\").html(str)  \n        });  \n        var aa = 1;  \n        // 文件上传过程中创建进度条实时显示。  \n        uploader.on(\'uploadProgress\', function (file, percentage) {  \n            var $li = $(\'#\' + file.id),  \n                $percent = $li.find(\'.progress .progress-bar\');  \n            // 避免重复创建  \n            if (!$percent.length) {  \n                $percent = $(\'<div class=\"progress progress-striped active\">\' +  \n                    \'<div class=\"progress-bar\" role=\"progressbar\" style=\"width: 0%\">\' +  \n                    \'</div>\' +  \n                    \'</div>\').appendTo($li).find(\'.progress-bar\');  \n            }  \n  \n            $li.find(\'p.state\').text(\'上传中\');  \n            $(\"#uploding\").html(\"上传中\");  \n            $percent.css(\'width\', percentage * 100 + \'%\');  \n            if (percentage == 1)  \n            {  \n                aa++;  \n            }  \n            if (aa<=2)  \n            {  \n               var shuzi=percentage * 100;  \n                $(\"#baifenbi\").html(shuzi.toFixed(2));  \n            }  \n        });  \n  \n        // 文件上传成功，给item添加成功class, 用样式标记上传成功。  \n        uploader.on(\'uploadSuccess\', function (file, response) {  \n            $(\'#\' + file.id).find(\'p.state\').text(\'已上传\');  \n            $.post(\'Home/Merge\', { guid: GUID, fileName: file.name }, function (data) {  \n                $(\"#uploader .state\").html(\"上传成功...\");  \n                $(\"#uploding\").html(\"上传成功\");  \n            });  \n        });  \n  \n        // 文件上传失败，显示上传出错。  \n        uploader.on(\'uploadError\', function (file) {  \n            $(\'#\' + file.id).find(\'p.state\').text(\'上传出错\');  \n        });  \n  \n        // 完成上传完了，成功或者失败，先删除进度条。  \n        uploader.on(\'uploadComplete\', function (file) {  \n            $(\'#\' + file.id).find(\'.progress\').fadeOut();  \n        });  \n  \n        //所有文件上传完毕  \n        uploader.on(\"uploadFinished\", function () {  \n            //提交表单  \n        });  \n  \n        //开始上传  \n        $(\"#ctlBtn\").click(function () {  \n            uploader.upload();  \n        });  \n    });  \n    //字节大小转换，参数为b  \n    function bytesToSize(bytes) {  \n        var sizes = [\'Bytes\', \'KB\', \'MB\', \'G\'];  \n        if (bytes == 0) return \'n/a\';  \n        var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));  \n        return (bytes / Math.pow(1024, i)).toFixed(1) + \' \' + sizes[i];  \n    };  \n  \n    //通过文件名，返回文件的后缀名  \n    function fileType(name) {  \n        var nameArr = name.split(\".\");  \n        return nameArr[nameArr.length - 1].toLowerCase();  \n    }</script>\n```\n\n  \n\n**后端控制器完整代码展示**\n\n  \n\n```\nusing System;  \nusing System.Collections.Generic;  \nusing System.IO;  \nusing System.Linq;  \nusing System.Web;  \nusing System.Web.Mvc;  \nnamespace BigFileUploader.Controllers  \n{  \n    public class HomeController : Controller  \n    {  \n        #region 文件上传  \n        [HttpPost]  \n        public ActionResult Upload()        {  \n            string fileName = Request[\"name\"];  \n            string fileRelName = fileName.Substring(0, fileName.LastIndexOf(\'.\'));//设置临时存放文件夹名称  \n  \n            int index = Convert.ToInt32(Request[\"chunk\"]);//当前分块序号  \n            var guid = Request[\"guid\"];//前端传来的GUID号  \n            var dir = Server.MapPath(\"~/Upload\");//文件上传目录  \n            dir = Path.Combine(dir, fileRelName);//临时保存分块的目录  \n            if (!System.IO.Directory.Exists(dir))  \n                System.IO.Directory.CreateDirectory(dir);  \n            string filePath = Path.Combine(dir, index.ToString());//分块文件名为索引名，更严谨一些可以加上是否存在的判断，防止多线程时并发冲突  \n            var data = Request.Files[\"file\"];//表单中取得分块文件  \n            string extension = data.FileName.Substring(data.FileName.LastIndexOf(\".\") + 1,  \n                (data.FileName.Length - data.FileName.LastIndexOf(\".\") - 1));//获取文件扩展名  \n            //if (data != null)//为null可能是暂停的那一瞬间  \n            //{  \n            data.SaveAs(filePath + fileName);  \n            //}  \n            return Json(new { erron = 0 });//Demo，随便返回了个值，请勿参考  \n        }  \n        public ActionResult Merge()        {  \n            var guid = Request[\"guid\"];//GUID  \n            var uploadDir = Server.MapPath(\"~/Upload\");//Upload 文件夹  \n            var fileName = Request[\"fileName\"];//文件名  \n            string fileRelName = fileName.Substring(0, fileName.LastIndexOf(\'.\'));  \n            var dir = Path.Combine(uploadDir, fileRelName);//临时文件夹            \n            var files = System.IO.Directory.GetFiles(dir);//获得下面的所有文件  \n            var finalPath = Path.Combine(uploadDir, fileName);//最终的文件名（demo中保存的是它上传时候的文件名，实际操作肯定不能这样）  \n            var fs = new FileStream(finalPath, FileMode.Create);  \n            foreach (var part in files.OrderBy(x => x.Length).ThenBy(x => x))//排一下序，保证从0-N Write  \n            {  \n                var bytes = System.IO.File.ReadAllBytes(part);  \n                fs.Write(bytes, 0, bytes.Length);  \n                bytes = null;  \n                System.IO.File.Delete(part);//删除分块  \n            }  \n            fs.Flush();  \n            fs.Close();  \n            System.IO.Directory.Delete(dir);//删除文件夹  \n            return Json(new { error = 0 });//随便返回个值，实际中根据需要返回  \n        }  \n        #endregion  \n    }  \n}\n```', '', 0, 0, 2, 0, 0, 0, 1691120956379, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188', '::ffff:172.17.0.1', 1691120956379, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (92, 0, 7, 2, '一个.NET 6开发的轻量级Web应用程序压测工具', '今天给大家推荐一款C#开发的轻量级Web应用程序压测工具LoadTestToolbox，LoadTestToolbox使用.NET 6开发。它提供了一种可靠的方式来模拟高负载情况，以确定系统的瓶颈和性能极限。\n\n  \n\n解决方案\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce538-eed1-66e3-f765-f4e9b8333a58_image.png)\n\n  \n\n  \n\n**使用方式**\n\n下载对应版本的LoadTestToolbox，我使用的是win-x64版本的，可以看到，LoadTestToolbox提供了三种工具：`drill`、`hammer`和`nailgun`。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce539-40b6-cb0d-e7e8-c276703ffd0e_image.png)\n\n了解各命令使用方式之前，先要了解下各命令的选项，LoadTestToolbo支持的选项包括：  \n\n  \n\n必选参数：\n\n`-u/--url`：要发送到的网址\n\n`-f/--filename`：要将图表输出到的文件\n\n可选参数\n\n`-m/--method`：要发送的 HTTP 方法（默认：GET)  \n`-H/--header`：要发送的 HTTP 标头（默认：无）  \n`-b/--body`：要发送的 HTTP 正文（默认：无）\n\ndrill必需的参数\n\n`-r/--rps`：每秒要发送的请求数  \n`-d/--duration`：发送请求的秒数\n\nhammer必需的参数\n\n`--min`：要发送的最小请求数  \n`--max`：要发送的最大请求数\n\nnailgun必需的参数\n\n`-r/--requests`要发送的请求数\n\n  \n\n在了解了各命令需要的参数选项后，我们可以尝试使用各条命令进行测试了。  \n\n  \n- drill  \n\nDrill 通过在较长的时间段内以一致的间隔不断请求页面来帮助衡量长期稳定性。例如\n\n```\nltt drill --url https://www.baidu.com/ --rps 500 --duration 10 --filename baidu.png\n```\n\n  \n\n\n上述命令中，表示LoadTestToolbox 每秒将发出 500 个请求（以一致的 20 毫秒间隔）持续 10 秒。请求完成后，将结果输出到指定的文件。  \n\n  \n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce539-a4fa-4aae-accb-4c16105bcc91_image.png)\n\n结果  \n\n  \n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce539-d6e5-74bc-965e-5d8271882a2c_image.png)\n\n  \n\n- hammer  \n\n  \nHammer 通过使用给定的并发请求范围“锤击”指定的 URL 来帮助测量负载峰值，并返回每个请求的平均响应时间。例如：\n\n```\nltt hammer --url https://www.baidu.com/ --min 1 --max 100 --filename baidu.png\n```\n\n  \n\n\n上述命令将同时发出 1 个请求，然后是 2 个，然后是 3 个，依此类推，最多 100 个。LoadTestToolbox 的Hammer 命令从10到100，每一次会增加10并发个请求。100到1000,每一次增加100个并发请求，以此类推。请求完成后，会将结果输出到指定文件。\n\n  \n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce53a-5d24-f04b-e463-b33be03b63ce_image.png)\n\n结果  \n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce53a-83e6-430f-b43c-0db44cf8a9e5_image.png)\n\n  \n\n- nailgun  \n\n  \nNailgun 显示指定的 URL 如何处理单个大量请求。例如：\n\n```\nltt nailgun --url https://www.baidu.com/ --requests 1000 --filename baidu.png\n```\n\n\n  \n\n上述的命令一次发送 1000 个请求，并记录每个请求的响应时间。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce53a-c7c3-69b1-e0bb-bdad747429a5_image.png)\n\n结果\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0ce53a-f28a-9560-4326-dbce8c64f92d_image.png)\n\n好啦，LoadTestToolbox 的功能就介绍到这里啦，有兴趣的同学可以自己下载源码研究，也可以下载发行版直接使用。\n\n ****资源获取方式**** \n\n[https://github.com/ecoAPM/LoadTestToolbox](https://github.com/ecoAPM/LoadTestToolbox)\n\n  ', '', 0, 0, 5, 0, 0, 0, 1691463098600, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.188', '::ffff:172.17.0.1', 1691463098600, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (93, 0, 9, 11, 'Oracle实现把B表某一字段更新到A表', '# 一、SQL命令UPDATE语句\n\n``` language\nUPDATE A\nSET A.field = (SELECT B.field FROM B WHERE B.key = A.key)\nWHERE EXISTS (SELECT 1 FROM B WHERE B.key = A.key);\n```\nA和B分别为要更新的目标表和源表，field是要更新的字段，key是用来匹配两个表的关键字。\n此外，子查询(SELECT B.field FROM B WHERE B.key = A.key)用于从B表中查询出需要更新到A表中的字段值，最后使用WHERE EXISTS子句确保只有匹配的记录被更新。\n\n# 二、使用MERGE语句\n\n``` language\nMERGE INTO A\nUSING B\nON (A.key = B.key)\nWHEN MATCHED \nTHEN UPDATE SET A.field = B.field;\n```\nUSING子句指定源表B；\nON子句指定匹配两个表的条件；\nWHEN MATCHED THEN UPDATE子句将匹配到的记录按照指定的规则（此处为将B表中的字段值更新到A表中）进行更新。', '', 0, 0, 3, 0, 0, 0, 1692615001108, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36 Edg/115.0.1901.183', '::ffff:172.17.0.1', 1692615001108, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (94, 0, 7, 2, 'AgileConfig 配置中心介绍及使用指南', '- 简介\n \n  这是一个基于.net core开发的轻量级配置中心。说起配置中心很容易让人跟微服务联系起来，如果你选择微服务架构，那么几乎逃不了需要一个配置中心。事实上我这里并不是要蹭微服务的热度。这个世界上有很多分布式程序但它并不是微服务。比如有很多传统的SOA的应用他们分布式部署，但并不是完整的微服务架构。这些程序由于分散在多个服务器上所以更改配置很困难。又或者某些程序即使不是分布式部署的，但是他们采用了容器化部署，他们修改配置同样很费劲。所以我开发AgileConfig并不是为了什么微服务，我更多的是为了那些分布式、容器化部署的应用能够更加简单的读取、修改配置。\n\n  AgileConfig秉承轻量化的特点，部署简单、配置简单、使用简单、学习简单，它只提取了必要的一些功能，并没有像Apollo那样复杂且庞大。但是它的功能也已经足够你替换webconfig，appsettings.json这些文件了。如果你不想用微服务全家桶，不想为了部署一个配置中心而需要看N篇教程跟几台服务器那么你可以试试AgileConfig ：）\n\n  [GitHub](https://github.com/dotnetcore/AgileConfig)\n\n-------\n- 特点\n  1. 部署简单，最少只需要一个数据节点，支持docker部署\n  2. 支持多节点分布式部署来保证高可用\n  3. 配置支持按应用隔离，应用内配置支持分组隔离\n  4. 支持多环境\n  5. 应用支持继承，可以把公共配置提取到一个应用然后其它应用继承它\n  6. 使用长连接技术，配置信息实时推送至客户端\n  7. 支持IConfiguration，IOptions模式读取配置，原程序几乎可以不用改造\n  8. 配置修改支持版本记录，随时回滚配置\n  9. 如果所有节点都故障，客户端支持从本地缓存读取配置\n  10. 如果所有节点都故障，客户端支持从本地缓存读取配置\n  \n---\n- 架构\n  ![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0d7f8c-cd20-5f32-3c99-a95b2417e732_image.png)\n \n**客户端**\n  \n客户端程序是使用netstandard2.0开发的一个类库，方便.net core程序接入，nuget搜agileconfig.client就可以安装。可以在启动客户端的时候配置多个节点的地址，客户端会随机挑选一个进行连接，连接成功后会维持一个websocket长连接。如果连接的节点发生故障导致连接中断，客户端会继续随机一个节点进行连接，直到连接成功。\n\n**节点、管理程序**\n\n节点是使用asp.net core开发的一个服务。为了部署简单，直接把管理程序跟节点服务合二为一了。任何一个节点都可以在启动的时候配置环境变量开启管理程序功能。\n\n**数据库**\n\n使用数据库来存储数据，目前支持Sqlserver, Mysql, Sqlite, PostgreSql,Oracle 五种数据库。最新版本已经切换为Freesql为数据访问组件。Freesql对多数据库的支持更加强劲，特别是对国产数据库的支持。\n\n**关于高可用**\n\nAgileConfig的节点都是无状态的，所以可以横向部署多个节点来防止单点故障。在客户端配置多个节点地址后，客户端会随机连接至某个节点。\n|问题|影响|说明|\n|-|-|-|\n|控制台下线|无法维护配置，客户端无影响|因为控制台跟节点是共存的，所以某个控制台下线一般来说同样意味着一个节点的下线|\n|某个节点下线|客户端重连至其他节点|无任何影响|\n|所有节点下线|客户端从内存读取配置|启动的客户端会从内存读取配置，未启动的客户端会再尝试连接到节点多次失败后，尝试从本地文件缓存读取配置，保证应用可以启动|\n\n----\n- 部署\n\n**服务端**\n\n使用 docker 运行\n```\nsudo docker run \\\n--name agile_config \\\n-e TZ=Asia/Shanghai \\\n-e adminConsole=true \\\n-e db__provider=sqlite \\\n-e db__conn=\"Data Source=agile_config.db\" \\\n-p 5000:5000 \\\n#-v /your_host_dir:/app/db \\\n-d kklldog/agile_config:latest\n```\n通过docker建立一个agile_config实例，其中有3个环境变量需要配置:\n1. adminConsole 配置程序是否为管理控制台。如果为true则启用控制台功能，访问该实例会出现管理界面。\n2. db__provider 配置程序的数据库类型。目前程序支持：sqlserver，mysql，sqlite, PostgreSql，Oracle 五种数据库。\n3. db__conn 配置数据库连接串\n\n> 如果通过IIS或者别的方式部署，请自行从主页上的releases页面下载最新的部署包。如果自己使用源码编译，请先编译react-ui-antd项目把dist内的产物复制到apisite项目的wwwroot/ui目录下。调试的时候需要复制到bin目录下。\n\n>如果节点使用nginx反代的话，需要对nginx进行配置，使其支持websocket协议，不然客户端跟节点的长连接没法建立。\n\n----------\n- 客户端\n\n**.NetCore版本**\n\n客户端AgileConfig_Client是使用.net core standard2.0编写的一个类库，已发布到nuget，方便用户集成。\n\n在appsettings.json文件配置agileconfig的配置信息。\n```\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n\n  //agile_config\n  \"AgileConfig\": {\n    \"appId\": \"app\",\n    \"secret\": \"xxx\",\n    \"nodes\": \"http://localhost:5000,http://localhost:5001\"//多个节点使用逗号分隔,\n    \"name\": \"client_name\",\n    \"tag\": \"tag1\",\n    \"env\": \"DEV\"\n  }\n}\n```\n使用 UseAgileConfig 扩展方法配置一个配置源。\n```\npublic static IHostBuilder CreateHostBuilder(string[] args) =>\n            Host.CreateDefaultBuilder(args)\n                .UseAgileConfig(new ConfigClient($\"appsettings.{Environment.GetEnvironmentVariable(\"ASPNETCORE_ENVIRONMENT\")}.json\"), e => Console.WriteLine($\"configs {e.Action}\"))\n                .ConfigureWebHostDefaults(webBuilder =>\n                {\n                    webBuilder.UseStartup<Startup>();\n                });\n```\n\nAgileConfig支持asp.net core 标准的IConfiguration，跟IOptions模式读取配置。\n```\npublic class HomeController : Controller\n{\n    private readonly ILogger<HomeController> _logger;\n    private readonly IConfiguration _IConfiguration;\n    private readonly IOptions<DbConfigOptions> _dbOptions;\n\n    public HomeController(ILogger<HomeController> logger, IConfiguration configuration, IOptions<DbConfigOptions> dbOptions)\n    {\n        _logger = logger;\n        _IConfiguration = configuration;\n        _dbOptions = dbOptions;\n    }\n\n    public IActionResult Index()\n    {\n        return View();\n    }\n\n    /// <summary>\n    /// 使用IConfiguration读取配置\n    /// </summary>\n    /// <returns></returns>\n    public IActionResult ByIConfiguration()\n    {\n        var userId = _IConfiguration[\"userId\"];\n        var dbConn = _IConfiguration[\"db:connection\"];\n\n        ViewBag.userId = userId;\n        ViewBag.dbConn = dbConn;\n\n        return View();\n    }\n\n    /// <summary>\n    /// 使用Options模式读取配置\n    /// </summary>\n    /// <returns></returns>\n    public IActionResult ByOptions()\n    {\n        var dbConn = _dbOptions.Value.connection;\n        ViewBag.dbConn = dbConn;\n\n        return View(\"ByOptions\");\n    }\n}\n```\n也可以通过IConfigClient来获取这个实例\n```\npublic class HomeController : Controller\n{\n    private readonly IConfigClient _configClient\n\n    public HomeController(IConfigClient configClient)\n    {\n        _configClient = configClient;\n    }\n\n    public IActionResult Index()\n    {\n        return View();\n    }\n\n    /// <summary>\n    /// 使用IConfigClient读取配置\n    /// </summary>\n    /// <returns></returns>\n    public IActionResult ByIConfigClient()\n    {\n        var userId = _configClient[\"userId\"];\n        var dbConn = _configClient[\"db:connection\"];\n\n        foreach (var item in _configClient.Data)\n        {\n            Console.WriteLine($\"{item.Key} = {item.Value}\");\n        }\n\n        ViewBag.userId = userId;\n        ViewBag.dbConn = dbConn;\n\n        return View();\n    }\n}\n```\n\n**.NetFramework版本**\n\n切换文景nuget私有仓库后，安装包 `Wj.AgileConfigHelper`\n配置文件添加如下配置\n```\n<!--agileconfig配置-->\n<add key=\"agile_config_appid\" value=\"default\" />\n<add key=\"agile_config_secret\" value=\"default\" />\n<add key=\"agile_config_servers\" value=\"http://192.168.1.83:5500,http://192.168.1.83:5600\" />\n<add key=\"agile_config_env\" value=\"DEV\" />\n```\nGlobal程序启动的地方初始化配置\n```\n    public class AgileConfigs\n    {\n        public static void RegisterAgileConfig()\n        {\n            var appid = ConfigHelper.GetConfigString(\"agile_config_appid\");\n            var secret = ConfigHelper.GetConfigString(\"agile_config_secret\");\n            var servers = ConfigHelper.GetConfigString(\"agile_config_servers\");\n            var env = ConfigHelper.GetConfigString(\"agile_config_env\");\n\n            if (appid.IsNullOrEmpty() || secret.IsNullOrEmpty() || servers.IsNullOrEmpty())\n            {\n                return;\n            }\n            env = env ?? \"DEV\";\n\n            AgileConfigHelper.Init(appid, secret, servers, env, new AgileConfigLogger());\n        }\n    }\n    public class AgileConfigLogger : ILogger\n    {\n        public void LogError(string msg)\n        {\n            LogHelper.WriteErrorLog(msg);\n        }\n        public void LogError(Exception ex, string msg)\n        {\n            LogHelper.WriteErrorLog(ex, msg);\n        }\n        public void LogTrace(string msg)\n        {\n        }\n    }\n```\n使用方式如下，支持分组参数\n```\nAgileConfigHelper.Get(\"redis\", \"def\", ConfigHelper.GetConfigString(\"redis.def\"));\nAgileConfigHelper.Get(\"SystemMode\", ConfigHelper.GetConfigString(\"SystemMode\"));\n```\n', '', 0, 0, 16, 1, 0, 0, 1694053802092, 2, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.62', '::ffff:172.17.0.1', 1694053718335, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (95, 0, 7, 2, '将string[]组装成一个字符串的推荐做法', '- NetCore\n\n```\nreturn string.Create(length, values, (span, strings) => {\n                    int offset = 0;\n                    // Skip null and empty values\n                    for (int i = 0; i < strings.Length; i++)\n                    {\n                        string? value = strings[i];\n                        if (value != null && value.Length > 0)\n                        {\n                            if (offset > 0)\n                            {\n                                // Add separator\n                                span[offset] = \',\';\n                                offset++;\n                            }\n\n                            value.AsSpan().CopyTo(span.Slice(offset));\n                            offset += value.Length;\n                        }\n                    }\n                });\n```\n\n- NetFramework\n\n```\nvar sb = new ValueStringBuilder(length);\n                bool hasAdded = false;\n                // Skip null and empty values\n                for (int i = 0; i < values.Length; i++)\n                {\n                    string? value = values[i];\n                    if (value != null && value.Length > 0)\n                    {\n                        if (hasAdded)\n                        {\n                            // Add separator\n                            sb.Append(\',\');\n                        }\n\n                        sb.Append(value);\n                        hasAdded = true;\n                    }\n                }\n\n                return sb.ToString();\n```', '', 0, 0, 1, 0, 0, 0, 1694504630404, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.76', '::ffff:172.17.0.1', 1694504630404, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (96, 0, 7, 2, '推荐一个 .NET 异步、跨平台、支持分段下载的开源项目', 'Downloader 是一个现代化、流畅、异步、可测试和可移植的 .NET 库。这是一个具有异步进度事件的分段下载项目。这个库可以添加到您的 .Net Core v2 及更高版本或 .Net Framework v4.5 或更高版本的项目中。\n\nDownloader 与 .NET Standard 2.0 及更高版本兼容，在 Windows、Linux 和 macOS 上运行，支持完整的 .NET Framework 或 .NET Core。\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0de7c0-cf0f-cf8e-9584-8913e6020925_image.png)\n\n  \n\n  \n\n**功能特性**\n\n  \n\n  \n\n  \n\n  \n\n*   • 异步且非阻塞下载文件。\n    \n*   • 下载任何类型的文件，如图像、视频、pdf、apk 等。\n    \n*   • 跨平台库可下载任何大小的任何文件。\n    \n*   • 获取每个区块的实时进度信息。\n    \n*   • 并行分段下载文件。\n    \n*   • 支持异步快速暂停和恢复下载。\n    \n*   • 代码很小、速度很快并且不依赖于外部库。\n    \n\n  \n\n  \n\n**如何使用?**\n\n  \n\n  \n\n  \n\n  \n\n安装下载库。\n\n```\ndotnet add package Downloader\n```\n\n第一步，创建下载配置。\n\n```\nvar downloadOpt = new DownloadConfiguration()  \n{  \n    // 分段下载数量，默认为1  \n    ChunkCount = 8,   \n    ParallelDownload = true  // 并行下载  \n};\n```\n\n初始化下载服务。\n\n```\nvar downloader = new DownloadService(downloadOpt);\n```\n\n处理下载事件。\n\n```\n// 下载开始  \ndownloader.DownloadStarted += OnDownloadStarted;  \n  \n// 下载进度信息更新  \ndownloader.ChunkDownloadProgressChanged += OnChunkDownloadProgressChanged;    \n  \n// 下载完成  \ndownloader.DownloadFileCompleted += OnDownloadFileCompleted;\n```\n\n使用 url 和文件名开始下载\n\n```\nstring file = @\"Your_Path\\fileName.zip\";  \nstring url = @\"https://file-examples.com/fileName.zip\";  \nawait downloader.DownloadFileTaskAsync(url, file);\n```\n\n暂停和恢复下载\n\n```\n// 暂停  \nDownloadService.Pause();  \n  \n// 恢复  \nDownloadService.Resume();\n```\n\n使用 Fluent API 进行下载。\n\n```\nawait DownloadBuilder.New()  \n    .WithUrl(@\"https://host.com/test-file.zip\")  \n    .WithDirectory(@\"C:\\temp\")  \n    .Build()  \n    .StartAsync();\n```\n\n  ', '', 0, 0, 2, 0, 0, 0, 1695800396012, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.41', '::ffff:172.17.0.1', 1695800396012, NULL, b'0', 0);
INSERT INTO `t_topic` VALUES (97, 0, 7, 2, '一种对数据库友好的GUID的变种使用方法', '### 概述\n\n.NET生成的GUID唯一性很好，用之方便，但是，缺少像雪花算法那样的有序性。虽然分布式系统中做不到绝对的有序，但是，相对的有序对于目前数据库而言，索引效率等方面的提升还是有明显效果的（当然，我认为，这是数据库的问题，而非编程的问题，数据库应该处理好任何类型数据作为主键索引时的性能，除非在SQL标准中明确写不支持哪些数据类型）。在当前数据库无法解决这些问题的时候，除了使用雪花算法，是否能够改造GUID，利用微软已经相当成熟的GUID的性能与效率的同时，加上序列的特性呢。本文就是做此尝试。\n\n### GUID与雪花算法\n\n个人主观的感受，雪花算法生成简单，但是，在生产环境配置需要注意，同时，有范围限制（时间、数据中心、工作机器、单位时间生成个数都有限制），正常情况下，这些范围足够使用，但是，毕竟GUID是没有限制的，唯一的问题就是有极低的概念会重复，这种重复在插入的时候，通过数据库的Pk是可以及时发现并处理的，不会产生生产故障。\n\nclaus是这样评价这两个算法的：\n\n```\nGUID 和 Snowflake 都是常见的唯一ID生成方案,主要有以下区别:\n\n优点:\n\n1. GUID是完全随机的,碰撞概率极低,唯一性非常好。\n\n2. GUID不依赖中心节点,分布式环境下也能生成,更适合于分布式系统。\n\n3. GUID包含版本信息,可以对不同算法生成的GUID进行区分,向下兼容。\n\n缺点: \n\n1. GUID是无序的,不能进行排序,对数据库索引不友好。\n\n2. GUID较长,作为主键会占用更多存储空间。\n\n3. GUID包含 BPSK 码,大小写字母和短划线,可读性较差。\n\n\nSnowflake算法:\n\n优点:\n\n1. 可以按时间有序生成ID,对数据库索引更友好。\n\n2. 整体ID更短小,节省存储空间。\n\n3. 不包含特殊字符,可读性更好。\n\n缺点:\n\n1. 依赖中心节点时间戳,必须保证节点时间同步。\n\n2. 不适合大规模分布式环境,扩展性较弱。\n\n3. 序列号周期较短,需要自定义优化。\n\n4. 不向下兼容,算法变更会导致ID不连续。\n\n总之,应根据分布式需求、时间序需求、存储空间和可读性等进行权衡选择。\n```\n\n### 我们需要用到时间值（戳？还是不蹭UNIX的概念吧）\n\n1 毫秒=1000000 纳秒\n\n```\n\nvar dt = DateTime.Now;// 当前时间\nConsole.WriteLine(dt.Ticks);// 638322150575422659，这是.net自带的运算，其它语言可以使用下面的方式生成。\nConsole.WriteLine((dt - new DateTime(1, 1, 1)).TotalMilliseconds*10000); // 638322150575422700\n// 通过Ticks，可以取得100ns，即万分之一毫秒的精度。\n```\n\n到3023年（1千年以后），Ticks的值也不会进位，其值为953650368000000000。\n\n### 了解一下GUID\n\nGUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”。\n\n其含义为：【时间值低位 32bit】-【时间值中位 16bit】-【版本号 4bit】【时间值高位 4bit】【时间值高位 8bit】-【变体值 2bit】【时间序列高位 6bit】-【节点值 48bit】\n\n位数为：8hex-4hex-4hex-4hex-12hex。\n\n```\nvar uuidN = Guid.NewGuid().ToString(\"N\"); // e0a953c3ee6040eaa9fae2b667060e09\n```\n\n### 时间值+GUID\n\n时间值本身是一个long类型的数字，其大小为Int64，即8byte。\n\nguid本身就是一个byte\\[\\]，其长度为16位。\n\n所以，我们生成一个byte\\[\\]，前8位放时间值，后面放GUID，在比较大小的时候，前端的位置优先级更高，所以，后面的GUID的无序特性会被覆盖。\n\n<table id=\"iD4Rg\" class=\"ne-table\"><tbody><tr><td width=\"542\"><p id=\"u6117cbe1\" class=\"ne-p\"><span class=\"ne-text\">8 位 Byte</span></p></td><td width=\"542\"><p id=\"u042fa979\" class=\"ne-p\"><span class=\"ne-text\">8 位 Byte</span></p></td><td width=\"543\"><p id=\"u10c34c00\" class=\"ne-p\"><span class=\"ne-text\">8 位 Byte</span></p></td></tr><tr><td width=\"542\"><p id=\"u76e0a32a\" class=\"ne-p\"><span class=\"ne-text\">时间值</span></p></td><td colspan=\"2\" width=\"1085\"><p id=\"u6fb80627\" class=\"ne-p\"><span class=\"ne-text\">GUID值</span></p></td></tr></tbody></table>\n\n加在一起，一共24个字节。\n\n### Base64字符串化\n\n因为数据库、前端、CSV等环境下，无法描述所有的Byte（原因是部分AscII是非可见字符），故而，需要将其进行类似Base64的转换。\n\n转换后，我们会得到一个长度大概24/3\\*4=32位长度的字符串。这个字符串的字节数至少是32，但是，其具体更好的可读性。\n\n但是，Base64有一个缺陷，我们来看一下它的码表：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0e1b74-57e2-a9ac-830e-7c20ca361105_image.png)\n\n可以看到，【大写字母】<【小写字母】<【数字】<【+】<【/】。\n\n但是，我们的程序进行比较时，并非如此，而是遵循了AscII码表的次序。我们来看一下AscII码表的次序：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0e1b74-9d3b-3829-9a02-765783159d9a_image.png)\n\n在AscII码表中，【/】<【数字】<【=】<【大写字母】<【小写字母】。\n\n与上面的base64对比可以发现，如果我们将两串二进制用base64表示，则他们将无法使用base64字面的字符进行大小比较。所以，我们需要对base64进行一次转换，转换的结果要与ascii对应，起到和ascii大小次序一次的效果。\n\n### BaseSortValue-BSV\n\n为了解决这个问题，我们需要将base64的二进制拿出来，然后， 给予他们有次序的新的码表即可。\n\n但是，我们要做更长远的考虑，我们的BSV大概率会被用作主键，会用来查询，用出现在URL中，所以，我们应该避开URL的字义字符。URL的转义表如下：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0e1b74-f6a3-4dc6-7c47-eadb0611f2db_image.png)\n\n除了大小写字母、数字以外，我们还需要3个字符。除去URL转义字符，ASCII中可用的可视字符只剩下 `!\"$\'()*,-.;<>[\\]^_{|}~`。其中\"\'出现在代码中容易影响代码本身的转义，故而不可。\\_符号在查询时，经常因为疏忽看不见。所以，最好的应该是!$-。因为这三者的中英文区别较大，具有较高的可识别度。同时，!小于数字及字母，作为补位可以不影响大小。最终形成的码表如下：\n\n![ ](http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a0e1b75-4584-13ca-d76b-ee2d24549fb2_image.png)\n\n生成的结果如下：\n\n```\n0Bj4hRXIFkDoc$DXPivPF7nPBmO-smcF\n0Bj4hU4f674ny-f0keZnG6VpDZm1b75r\n0Bj4hU4h3WXnCsIKnnrrG7LHBzpH4yMF\n0Bj4hU4h4FhniG-wH57BF6pSCVD$5sGp\n0Bj4hU4h4Za$B5tkH2sIEtjA39M-nGuQ\n0Bj4hU4h4qL0M-4nKRLZFcrU8qF$yezv\n0Bj4hU4h548bDgf6ypAiFvI-HQSzZFeH\n0Bj4hU4h5I47IsKrnkfdF7bfvOjMXWXm\n0Bj4hU4h5V3P7fTSP0lBEcbZbF5h2CXV\n0Bj4hU4h5iCiT-m$R7PfEeko7oaFcIPO\n0Bj4hU4h5vDF6VNYTDSSFsHi1FUQt93p\n```\n\n### 实现 - .Net\n\n```\n\n    public static class SeqGuid\n    {\n        /// <summary>\n        /// 生成BSV的GUID。\n        /// </summary>\n        /// <returns></returns>\n        public static string NewGuid()\n        {\n\n            var gid = Guid.NewGuid().ToByteArray();// 获取唯一的guid，对应uuid的版本应该是v4。此处直接获取其byte数组。\n            var dtvalue = DateTime.Now.Ticks;//获取当前时间到1年1月1日的总ticks数，ticks单位是100ns，即万分之一毫秒。\n            var dtbytes = BitConverter.GetBytes(dtvalue);// 将ticks时间戳转换为字节数组，默认是小端。\n            var bytes = new Byte[gid.Length + dtbytes.Length];// 实例化新的数字，用以存放时间值和GUID值。\n\n            // 因为BitConverter.GetBytes获得的Byte[]是小端，不符合排序要求，所以，要逆序写入bytes数组中，形成大端的方式。\n            // 将时间值放入bytes数组中。\n            for (long i = 0; i < dtbytes.Length; i++)\n            {\n                var cvalue = dtbytes[dtbytes.Length - i - 1];\n                bytes[i] = cvalue;\n            }\n\n            // 将guid的值，放入bytes数组中。\n            gid.CopyTo(bytes, dtbytes.Length);\n            // 将值转换为base64，主要原因是，前端、数据库比较容易处理字符串类型的数据。\n            var b64 = Convert.ToBase64String(bytes);\n            // 将无序的base64转换为有序的伪base64格式。\n\n            var ss = b64.ToArray();\n            for (var i = 0; i < ss.Length; i++)\n            {\n                ss[i] = dic[ss[i]];\n            }\n            return new string(ss);\n        }\n        /// <summary>\n        /// 仿base64的有序字典，其与base64相似，使用有限的字符，表示6bit的二进制，不足的地方补=。但是，与base64的区别是，字符串是按从小到大的次序表示000000到111111的数值的。\n        /// </summary>\n        public static readonly Dictionary<char, char> dic = new Dictionary<char, char>()\n        {\n            {\'A\',\'$\'},{\'B\',\'-\'},{\'C\',\'0\'},{\'D\',\'1\'},{\'E\',\'2\'},{\'F\',\'3\'},{\'G\',\'4\'},{\'H\',\'5\'},{\'I\',\'6\'},{\'J\',\'7\'},{\'K\',\'8\'},\n            {\'L\',\'9\'},{\'M\',\'A\'},{\'N\',\'B\'},{\'O\',\'C\'},{\'P\',\'D\'},{\'Q\',\'E\'},{\'R\',\'F\'},{\'S\',\'G\'},{\'T\',\'H\'},{\'U\',\'I\'},{\'V\',\'J\'},\n            {\'W\',\'K\'},{\'X\',\'L\'},{\'Y\',\'M\'},{\'Z\',\'N\'},{\'a\',\'O\'},{\'b\',\'P\'},{\'c\',\'Q\'},{\'d\',\'R\'},{\'e\',\'S\'},{\'f\',\'T\'},{\'g\',\'U\'},\n            {\'h\',\'V\'},{\'i\',\'W\'},{\'j\',\'X\'},{\'k\',\'Y\'},{\'l\',\'Z\'},{\'m\',\'a\'},{\'n\',\'b\'},{\'o\',\'c\'},{\'p\',\'d\'},{\'q\',\'e\'},{\'r\',\'f\'},\n            {\'s\',\'g\'},{\'t\',\'h\'},{\'u\',\'i\'},{\'v\',\'j\'},{\'w\',\'k\'},{\'x\',\'l\'},{\'y\',\'m\'},{\'z\',\'n\'},{\'0\',\'o\'},{\'1\',\'p\'},{\'2\',\'q\'},\n            {\'3\',\'r\'},{\'4\',\'s\'},{\'5\',\'t\'},{\'6\',\'u\'},{\'7\',\'v\'},{\'8\',\'w\'},{\'9\',\'x\'},{\'+\',\'y\'},{\'/\',\'z\'},{\'=\',\'!\'}\n        };\n    }\n```\n```\n    internal class Program\n    {\n        static void Main(string[] args)\n        {\n            var preone = SeqGuid.NewGuid();\n            for(int i = 0; i < 9999999; i++)\n            {\n                var newone = SeqGuid.NewGuid();\n                if (String.CompareOrdinal(newone, preone)<0)//必须使用CompareOrdinal，因为Compare和CompareTo等都受本地的CultureInfo影响，可能会忽略大小写。\n                {\n                    Console.WriteLine($\"error ,{newone} < {preone}\");\n\n                }\n                preone = newone;\n\n            }\n            Console.WriteLine(\"done...\");\n            Console.ReadLine();\n        }\n    }\n```\n\n运行结果：\n\n\n执行1000万次，没有大小次序错误。单线程 的情况下，每秒生成143万个。\n\n### 多线程并发测试\n\n因为我的电脑只有20核，所以，使用15个线程来处理，为了避免受Task的优化影响，我们直接使用Thread来模拟。\n\n```\nstatic ConcurrentBag<string> exists = new ConcurrentBag<string>();\n        static void 测试并发唯一性()\n        {\n            Thread[] tks = new Thread[15];\n            for(var t = 0; t < 15; t++)\n            {\n                tks[t] = new Thread(workThread);\n                tks[t].Start();\n\n            }\n            Console.WriteLine(\"所有任务启动完成，等待执行完成中……\");\n\n            for (var t = 0; t < 15; t++)\n            {\n                tks[t].Join();\n            }\n            Console.WriteLine($\"全部执行完成，总生成guid个数:\"+exists.Count);\n\n        }\n        static void workThread()\n        {\n            var count = 1000;\n            Console.WriteLine(Thread.CurrentThread.ManagedThreadId + \"：启动\");\n            for (int i = 0; i < count; i++)\n            {\n                var nid = SeqGuid.NewGuid();\n                if (exists.Contains(nid))\n                {\n                    Console.WriteLine(\"出现重复guid:\" + nid);\n                }\n                else\n                {\n                    exists.Add(nid);\n                }\n            }\n            Console.WriteLine(Thread.CurrentThread.ManagedThreadId + \"：完成\");\n        }\n```\n\n测试结果如下：\n\n\n\n 说明，借着.net原本的GUID，完美的避开了并发情况下唯一的问题。至于说，高并发情况下次序问题，如果两个动作在100ns以内，是否区分次序或者不是那么重要了。并且，此GUID也并非是提供强一致次序（这种需求还是需要用Redis之类的来实现），而是提供有限的次序，以便解决数据库优化的问题。\n\n  \n[链接](https://www.cnblogs.com/ensleep/p/17745166.html)', '', 0, 0, 3, 0, 0, 0, 1696668046745, 0, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36 Edg/117.0.2045.47', '::ffff:172.17.0.1', 1696668046745, NULL, b'0', 0);

-- ----------------------------
-- Table structure for t_topic_node
-- ----------------------------
DROP TABLE IF EXISTS `t_topic_node`;
CREATE TABLE `t_topic_node`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `sort_no` bigint(20) NULL DEFAULT NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `logo` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE,
  INDEX `idx_sort_no`(`sort_no`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_topic_node
-- ----------------------------
INSERT INTO `t_topic_node` VALUES (1, '交流', '交流', 0, 0, 1644198944000, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056585-9a92-9284-cdbb-f4ee829043e4_交流.png');
INSERT INTO `t_topic_node` VALUES (3, '反馈', '反馈', 2, 0, 1651214903232, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056586-10d0-aca6-1559-10ccf2991824_意见反馈.png');
INSERT INTO `t_topic_node` VALUES (5, '提问', '提问', 1, 0, 1651217744245, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056585-d591-7fee-7a32-d205c1f04119_提问.png');
INSERT INTO `t_topic_node` VALUES (6, 'Java', '', 5, 0, 1659083735728, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056586-6540-ea4a-5538-a5c1b8f67954_java.png');
INSERT INTO `t_topic_node` VALUES (7, '.NET', '', 4, 0, 1659083752384, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056586-3df3-0298-a927-7f2fa396e0d7_dot-net.png');
INSERT INTO `t_topic_node` VALUES (8, 'Vue', '', 6, 0, 1659084122284, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056586-9079-d767-9bbe-b12411820bd1_Vue.png');
INSERT INTO `t_topic_node` VALUES (9, '数据库', '', 7, 0, 1659339471926, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a83-afb7-5955-5c29-653c19aaf271_database.png');
INSERT INTO `t_topic_node` VALUES (10, '行业资讯', '', 8, 0, 1659409575850, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056eb1-68aa-8326-b50a-c1141c865bcd_资讯.png');
INSERT INTO `t_topic_node` VALUES (11, '数据可视化', '', 9, 0, 1660293595886, 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a362-8e82-0a7e-f1cc-9c4e5651adaf_ddd.png');

-- ----------------------------
-- Table structure for t_topic_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_topic_tag`;
CREATE TABLE `t_topic_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `topic_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  `status` bigint(20) NOT NULL,
  `last_comment_time` bigint(20) NULL DEFAULT NULL,
  `last_comment_user_id` bigint(20) NULL DEFAULT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_topic_tag_topic_id`(`topic_id`) USING BTREE,
  INDEX `idx_topic_tag_tag_id`(`tag_id`) USING BTREE,
  INDEX `idx_topic_tag_status`(`status`) USING BTREE,
  INDEX `idx_topic_tag_last_comment_time`(`last_comment_time`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 251 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_topic_tag
-- ----------------------------
INSERT INTO `t_topic_tag` VALUES (52, 10, 26, 0, 1659271041343, 0, 1659271041343);
INSERT INTO `t_topic_tag` VALUES (53, 10, 27, 0, 1659271041343, 0, 1659271041343);
INSERT INTO `t_topic_tag` VALUES (54, 20, 28, 0, 1659317088153, 0, 1659317088153);
INSERT INTO `t_topic_tag` VALUES (55, 20, 29, 0, 1659317088153, 0, 1659317088153);
INSERT INTO `t_topic_tag` VALUES (56, 20, 30, 0, 1659317088153, 0, 1659317088153);
INSERT INTO `t_topic_tag` VALUES (57, 8, 17, 0, 1659318775556, 0, 1659318775556);
INSERT INTO `t_topic_tag` VALUES (58, 21, 32, 0, 1659319121246, 0, 1659319121246);
INSERT INTO `t_topic_tag` VALUES (59, 22, 28, 0, 1659321115025, 0, 1659321115025);
INSERT INTO `t_topic_tag` VALUES (60, 22, 33, 0, 1659321115025, 0, 1659321115025);
INSERT INTO `t_topic_tag` VALUES (61, 22, 34, 0, 1659321115025, 0, 1659321115025);
INSERT INTO `t_topic_tag` VALUES (63, 24, 36, 0, 1659332620405, 0, 1659332620405);
INSERT INTO `t_topic_tag` VALUES (64, 26, 37, 0, 1659336646546, 0, 1659336646546);
INSERT INTO `t_topic_tag` VALUES (65, 27, 38, 0, 1659339231176, 0, 1659339231176);
INSERT INTO `t_topic_tag` VALUES (66, 27, 39, 0, 1659339231176, 0, 1659339231176);
INSERT INTO `t_topic_tag` VALUES (67, 23, 35, 0, 1659339516372, 0, 1659339516372);
INSERT INTO `t_topic_tag` VALUES (75, 28, 28, 0, 1659412655892, 0, 1659412655892);
INSERT INTO `t_topic_tag` VALUES (76, 29, 41, 0, 1659421045704, 0, 1659421045704);
INSERT INTO `t_topic_tag` VALUES (77, 29, 28, 0, 1659421045704, 0, 1659421045704);
INSERT INTO `t_topic_tag` VALUES (78, 30, 41, 0, 1659422208185, 2, 1659422060034);
INSERT INTO `t_topic_tag` VALUES (79, 31, 28, 0, 1659491647853, 0, 1659491647853);
INSERT INTO `t_topic_tag` VALUES (80, 31, 8, 0, 1659491647853, 0, 1659491647853);
INSERT INTO `t_topic_tag` VALUES (85, 34, 1, 0, 1659508055886, 0, 1659508055886);
INSERT INTO `t_topic_tag` VALUES (86, 34, 42, 0, 1659508055886, 0, 1659508055886);
INSERT INTO `t_topic_tag` VALUES (89, 33, 1, 0, 1659508101130, 0, 1659508101130);
INSERT INTO `t_topic_tag` VALUES (90, 33, 42, 0, 1659508101130, 0, 1659508101130);
INSERT INTO `t_topic_tag` VALUES (91, 35, 1, 0, 1659509600982, 0, 1659509600982);
INSERT INTO `t_topic_tag` VALUES (92, 35, 42, 0, 1659509600982, 0, 1659509600982);
INSERT INTO `t_topic_tag` VALUES (96, 38, 28, 0, 1659597746610, 0, 1659597746610);
INSERT INTO `t_topic_tag` VALUES (97, 38, 43, 0, 1659597746610, 0, 1659597746610);
INSERT INTO `t_topic_tag` VALUES (100, 39, 28, 0, 1659602614131, 0, 1659602614131);
INSERT INTO `t_topic_tag` VALUES (101, 39, 44, 0, 1659602614131, 0, 1659602614131);
INSERT INTO `t_topic_tag` VALUES (102, 37, 13, 0, 1659662627336, 0, 1659662627336);
INSERT INTO `t_topic_tag` VALUES (103, 40, 28, 0, 1659667631266, 0, 1659667631266);
INSERT INTO `t_topic_tag` VALUES (104, 40, 45, 0, 1659667631266, 0, 1659667631266);
INSERT INTO `t_topic_tag` VALUES (105, 41, 28, 0, 1659669431962, 0, 1659669431962);
INSERT INTO `t_topic_tag` VALUES (106, 41, 46, 0, 1659669431962, 0, 1659669431962);
INSERT INTO `t_topic_tag` VALUES (107, 42, 28, 0, 1659678181654, 0, 1659678181654);
INSERT INTO `t_topic_tag` VALUES (108, 45, 41, 0, 1660015567139, 0, 1660015567139);
INSERT INTO `t_topic_tag` VALUES (109, 45, 28, 0, 1660015567139, 0, 1660015567139);
INSERT INTO `t_topic_tag` VALUES (110, 46, 41, 0, 1660186198431, 0, 1660186198431);
INSERT INTO `t_topic_tag` VALUES (111, 46, 28, 0, 1660186198431, 0, 1660186198431);
INSERT INTO `t_topic_tag` VALUES (118, 47, 47, 0, 1660209184585, 10, 1660204017910);
INSERT INTO `t_topic_tag` VALUES (119, 47, 48, 0, 1660209184585, 10, 1660204017910);
INSERT INTO `t_topic_tag` VALUES (126, 48, 28, 0, 1660272251473, 0, 1660272251473);
INSERT INTO `t_topic_tag` VALUES (127, 50, 28, 0, 1660698992358, 0, 1660698992358);
INSERT INTO `t_topic_tag` VALUES (128, 50, 49, 0, 1660698992358, 0, 1660698992358);
INSERT INTO `t_topic_tag` VALUES (129, 19, 25, 0, 1665648742448, 19, 1661133373098);
INSERT INTO `t_topic_tag` VALUES (130, 19, 40, 0, 1665648742448, 19, 1661133373098);
INSERT INTO `t_topic_tag` VALUES (131, 52, 50, 0, 1661235598658, 0, 1661235598658);
INSERT INTO `t_topic_tag` VALUES (132, 52, 51, 0, 1661235598658, 0, 1661235598658);
INSERT INTO `t_topic_tag` VALUES (133, 53, 51, 0, 1661239117835, 0, 1661239117835);
INSERT INTO `t_topic_tag` VALUES (134, 32, 1, 0, 1661311482351, 0, 1661311482351);
INSERT INTO `t_topic_tag` VALUES (135, 32, 42, 0, 1661311482351, 0, 1661311482351);
INSERT INTO `t_topic_tag` VALUES (149, 56, 51, 0, 1661506770402, 0, 1661506770402);
INSERT INTO `t_topic_tag` VALUES (150, 57, 33, 0, 1661842364167, 0, 1661842364167);
INSERT INTO `t_topic_tag` VALUES (151, 57, 34, 0, 1661842364167, 0, 1661842364167);
INSERT INTO `t_topic_tag` VALUES (154, 59, 51, 0, 1662086765902, 0, 1662086765902);
INSERT INTO `t_topic_tag` VALUES (155, 60, 51, 0, 1662342191225, 0, 1662342191225);
INSERT INTO `t_topic_tag` VALUES (156, 60, 43, 0, 1662342191225, 0, 1662342191225);
INSERT INTO `t_topic_tag` VALUES (169, 58, 51, 0, 1662519590475, 0, 1662519590475);
INSERT INTO `t_topic_tag` VALUES (170, 61, 50, 0, 1662535147093, 0, 1662535147093);
INSERT INTO `t_topic_tag` VALUES (171, 62, 28, 0, 1663146282808, 0, 1663146282808);
INSERT INTO `t_topic_tag` VALUES (172, 62, 52, 0, 1663146282808, 0, 1663146282808);
INSERT INTO `t_topic_tag` VALUES (173, 63, 53, 0, 1663895290706, 0, 1663895290706);
INSERT INTO `t_topic_tag` VALUES (176, 64, 50, 0, 1669348623662, 11, 1664241623081);
INSERT INTO `t_topic_tag` VALUES (177, 64, 51, 0, 1669348623662, 11, 1664241623081);
INSERT INTO `t_topic_tag` VALUES (179, 65, 54, 0, 1665394340145, 0, 1665394340145);
INSERT INTO `t_topic_tag` VALUES (181, 70, 55, 0, 1665651021391, 0, 1665651021391);
INSERT INTO `t_topic_tag` VALUES (184, 71, 56, 0, 1666780232905, 0, 1666780232905);
INSERT INTO `t_topic_tag` VALUES (185, 71, 57, 0, 1666780232905, 0, 1666780232905);
INSERT INTO `t_topic_tag` VALUES (187, 72, 41, 0, 1667182216163, 0, 1667182216163);
INSERT INTO `t_topic_tag` VALUES (188, 73, 58, 0, 1668580292225, 0, 1668580292225);
INSERT INTO `t_topic_tag` VALUES (189, 74, 59, 0, 1668602410662, 0, 1668602410662);
INSERT INTO `t_topic_tag` VALUES (190, 76, 60, 0, 1669711591452, 9, 1669631568785);
INSERT INTO `t_topic_tag` VALUES (191, 77, 41, 0, 1671518725768, 0, 1671518725768);
INSERT INTO `t_topic_tag` VALUES (192, 77, 56, 0, 1671518725768, 0, 1671518725768);
INSERT INTO `t_topic_tag` VALUES (193, 77, 61, 0, 1671518725768, 0, 1671518725768);
INSERT INTO `t_topic_tag` VALUES (199, 36, 1, 0, 1673488382225, 0, 1673488382225);
INSERT INTO `t_topic_tag` VALUES (200, 36, 42, 0, 1673488382225, 0, 1673488382225);
INSERT INTO `t_topic_tag` VALUES (201, 55, 50, 0, 1673598315914, 0, 1673598315914);
INSERT INTO `t_topic_tag` VALUES (202, 55, 51, 0, 1673598315914, 0, 1673598315914);
INSERT INTO `t_topic_tag` VALUES (203, 79, 51, 0, 1674873108758, 0, 1674873108758);
INSERT INTO `t_topic_tag` VALUES (207, 78, 1, 0, 1674873692450, 0, 1674873692450);
INSERT INTO `t_topic_tag` VALUES (208, 78, 62, 0, 1674873692450, 0, 1674873692450);
INSERT INTO `t_topic_tag` VALUES (209, 78, 63, 0, 1674873692450, 0, 1674873692450);
INSERT INTO `t_topic_tag` VALUES (210, 80, 51, 0, 1677113498611, 0, 1677113498611);
INSERT INTO `t_topic_tag` VALUES (211, 80, 64, 0, 1677113498611, 0, 1677113498611);
INSERT INTO `t_topic_tag` VALUES (214, 81, 51, 0, 1677114734745, 0, 1677114734745);
INSERT INTO `t_topic_tag` VALUES (215, 81, 65, 0, 1677114734745, 0, 1677114734745);
INSERT INTO `t_topic_tag` VALUES (216, 82, 28, 0, 1679274180284, 0, 1679274180284);
INSERT INTO `t_topic_tag` VALUES (217, 82, 50, 0, 1679274180284, 0, 1679274180284);
INSERT INTO `t_topic_tag` VALUES (218, 82, 66, 0, 1679274180284, 0, 1679274180284);
INSERT INTO `t_topic_tag` VALUES (219, 54, 51, 0, 1681009739650, 0, 1681009739650);
INSERT INTO `t_topic_tag` VALUES (220, 83, 56, 0, 1684293720471, 2, 1681719080007);
INSERT INTO `t_topic_tag` VALUES (221, 84, 67, 0, 1684293622511, 0, 1684293622511);
INSERT INTO `t_topic_tag` VALUES (222, 85, 68, 0, 1684302471342, 0, 1684302471342);
INSERT INTO `t_topic_tag` VALUES (223, 87, 41, 0, 1688541816388, 0, 1688541816388);
INSERT INTO `t_topic_tag` VALUES (224, 88, 41, 0, 1689044121205, 0, 1689044121205);
INSERT INTO `t_topic_tag` VALUES (225, 89, 28, 0, 1689556627852, 0, 1689556627852);
INSERT INTO `t_topic_tag` VALUES (226, 89, 69, 0, 1689556627852, 0, 1689556627852);
INSERT INTO `t_topic_tag` VALUES (237, 91, 41, 0, 1691120956385, 0, 1691120956385);
INSERT INTO `t_topic_tag` VALUES (240, 92, 41, 0, 1691463639920, 0, 1691463639920);
INSERT INTO `t_topic_tag` VALUES (243, 94, 41, 0, 1694053802092, 2, 1694053718344);
INSERT INTO `t_topic_tag` VALUES (244, 94, 28, 0, 1694053802092, 2, 1694053718344);
INSERT INTO `t_topic_tag` VALUES (245, 94, 70, 0, 1694053802092, 2, 1694053718344);
INSERT INTO `t_topic_tag` VALUES (246, 95, 28, 0, 1694504630409, 0, 1694504630409);
INSERT INTO `t_topic_tag` VALUES (247, 90, 41, 0, 1695799959933, 2, 1695258020852);
INSERT INTO `t_topic_tag` VALUES (248, 96, 28, 0, 1695800396017, 0, 1695800396017);
INSERT INTO `t_topic_tag` VALUES (249, 97, 28, 0, 1696668046753, 0, 1696668046753);
INSERT INTO `t_topic_tag` VALUES (250, 97, 41, 0, 1696668046753, 0, 1696668046753);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `email` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `email_verified` tinyint(1) NOT NULL DEFAULT 0,
  `nickname` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `avatar` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `background_image` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `password` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `home_page` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `score` bigint(20) NOT NULL,
  `status` bigint(20) NOT NULL,
  `topic_count` bigint(20) NOT NULL,
  `comment_count` bigint(20) NOT NULL,
  `roles` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `type` bigint(20) NOT NULL DEFAULT 0,
  `forbidden_end_time` bigint(20) NOT NULL DEFAULT 0,
  `create_time` bigint(20) NULL DEFAULT NULL,
  `update_time` bigint(20) NULL DEFAULT NULL,
  `fans_count` bigint(20) NOT NULL,
  `follow_count` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE,
  UNIQUE INDEX `email`(`email`) USING BTREE,
  INDEX `idx_user_score`(`score`) USING BTREE,
  INDEX `idx_user_status`(`status`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 20 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, 'admin', 'a@example.com', 0, 'bbs站长', '', NULL, '05CED1B30620FC8D8C3A95D9C21D8339', NULL, '轻轻地我走了，正如我轻轻的来。', 0, 0, 0, 0, 'owner', 0, 0, 1644198944000, 1659335164982, 0, 0);
INSERT INTO `t_user` VALUES (2, 'lilei', 'lilei@winjoinit.com', 0, '慢慢', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05659b-ca2f-9877-9eca-24ea68d0be05_20150610120432_NH4ef.jpeg', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05659a-e0cd-cea9-5bf0-9f7f7cb8603c_1.jpg', '1b1d0a51d8e4ce88209acc87633d9426', 'http://192.168.1.83:5000/user/2', '大家好！！', 186, 0, 62, 15, 'user', 0, 0, 1644203319175, 1658816460170, 1, 3);
INSERT INTO `t_user` VALUES (7, 'ceshi', 'ceshi@winjoinit.com', 0, '测试', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05659d-e086-b197-e947-a240e9d0f0cb_cat.jpg', NULL, 'E10ADC3949BA59ABBE56E057F20F883E', NULL, NULL, 1, 0, 0, 1, 'user', 0, 0, 1656056831953, 1656056831953, 0, 0);
INSERT INTO `t_user` VALUES (8, 'liulingfeng', 'liulingfeng@winjoinit.com', 0, 'liulingfeng', NULL, NULL, '5d93ceb70e2bf5daa84ec3d0cd2c731a', NULL, '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1659334391430, 1659334391430, 0, 0);
INSERT INTO `t_user` VALUES (9, 'SeaLee', '654029739@qq.com', 0, 'SeaLee', NULL, NULL, 'cb8968b9dd3c1c6e9bfc1de1aab02dce', NULL, '这家伙很懒，什么都没留下', 8, 0, 4, 4, 'user', 0, 0, 1659334994442, 1659334994442, 3, 0);
INSERT INTO `t_user` VALUES (10, '2vvc', '2816997021@qq.com', 0, '2vvc', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a4c-6ee2-f1cb-0cd4-08444e250e5e_247e05443df744ada96576c3fafe53b4_1.jpg', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05bd15-8755-76e4-9818-6e7aed953cbc_247e05443df744ada96576c3fafe53b4_1.jpg', '2856bf39683c75f3e39d0715556e97b1', NULL, '这家伙很懒，什么都没留下', 40, 0, 0, 2, 'user', 0, 0, 1659335823334, 1659335823334, 0, 1);
INSERT INTO `t_user` VALUES (11, 'ZENGQHAO', 'zengqinghao@winjoinit.com', 0, 'ZENGQHAO', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056a4c-cb40-8e27-b596-17224318b67e_下载.png', NULL, 'f5bb0c8de146c67b44babbf4e6584cc0', NULL, '这家伙很懒，什么都没留下', 34, 0, 8, 6, 'user', 0, 0, 1659335842308, 1659335842308, 1, 2);
INSERT INTO `t_user` VALUES (12, 'GoranZhou', 'zhougan@winjoinit.com', 0, 'GoranZhou', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a056e9a-982a-16e5-01e3-5684ea3fbb31_4aaa1cd289e0443d9e14e70cc6626dec.png', NULL, 'f907fe4ddc8af0b7e9ac528c4a870c8a', NULL, '这家伙很懒，什么都没留下', 5, 0, 1, 2, 'user', 0, 0, 1659408062663, 1659408062663, 0, 0);
INSERT INTO `t_user` VALUES (13, 'longyq', 'dxyqxk@qq.com', 0, '龙义强', NULL, NULL, '01920ef43e4a00637c452122c930a52f', NULL, '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1659429238291, 1659429238291, 0, 0);
INSERT INTO `t_user` VALUES (14, 'W', 'weiyingying@winjoinit.com', 0, 'W', NULL, NULL, 'f6ad85dcb05110646e10fe54f136b0d5', NULL, '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1660204320937, 1660204320937, 0, 0);
INSERT INTO `t_user` VALUES (15, 'NAN', 'luyanan@winjoinit.com', 0, 'NAN', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05a38b-aec2-ee72-984b-b14001c0fbd7_微信图片_20220812172259.jpg', NULL, 'e10adc3949ba59abbe56e057f20f883e', 'http://192.168.1.83:5000/user/15', '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1660296092933, 1660296092933, 0, 0);
INSERT INTO `t_user` VALUES (16, '何斐', 'hefei@winjoinit.com', 0, '何斐', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a05c736-6a77-c488-6a9b-282f4116761b_工作照2-小.jpg', NULL, '16875a14b6e5b0f7eb083411ce9dbb10', NULL, '这家伙很懒，什么都没留下', 1, 0, 1, 0, 'user', 0, 0, 1660894540925, 1660894540925, 1, 0);
INSERT INTO `t_user` VALUES (17, 'zhangmeng', '792856781@qq.com', 0, 'zhangmeng', NULL, NULL, 'e10adc3949ba59abbe56e057f20f883e', NULL, '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1663309153946, 1663309153946, 0, 0);
INSERT INTO `t_user` VALUES (18, 'Heaven', 'chenkang@winjoinit.com', 0, 'Heaven', NULL, NULL, 'e551075351299234c31ecdbe68b30908', NULL, '这家伙很懒，什么都没留下', 0, 0, 0, 0, 'user', 0, 0, 1664248325924, 1664248325924, 0, 0);
INSERT INTO `t_user` VALUES (19, 'huxiaoping', 'huxiaoping@winjoinit.com', 0, '胡涂蛋', 'http://192.168.1.83:5128/api/file/blob-picture-visit?name=3a06e286-f590-e976-059c-591935aa9c14_74397f53d476e808f6ab2f534a312291.jpeg', NULL, 'f42301e0ab4d8d2e325892d8183babab', NULL, '我不懒，但啥也不想留', 7, 0, 3, 3, 'user', 0, 0, 1665647867645, 1665647867645, 0, 0);

-- ----------------------------
-- Table structure for t_user_feed
-- ----------------------------
DROP TABLE IF EXISTS `t_user_feed`;
CREATE TABLE `t_user_feed`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `data_id` bigint(20) NOT NULL,
  `data_type` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `author_id` bigint(20) NOT NULL,
  `create_time` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_data`(`user_id`, `data_id`, `data_type`) USING BTREE,
  INDEX `idx_search`(`user_id`, `data_type`, `create_time`) USING BTREE,
  INDEX `idx_data_id`(`data_id`, `data_type`) USING BTREE,
  INDEX `idx_user_id`(`user_id`, `author_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 49 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_feed
-- ----------------------------
INSERT INTO `t_user_feed` VALUES (3, 2, 44, 'topic', 9, 1659681626208);
INSERT INTO `t_user_feed` VALUES (4, 2, 49, 'topic', 11, 1660294367424);
INSERT INTO `t_user_feed` VALUES (5, 11, 50, 'topic', 2, 1660698992372);
INSERT INTO `t_user_feed` VALUES (6, 11, 52, 'topic', 2, 1661235598671);
INSERT INTO `t_user_feed` VALUES (7, 11, 53, 'topic', 2, 1661239117849);
INSERT INTO `t_user_feed` VALUES (8, 11, 54, 'topic', 2, 1661493923261);
INSERT INTO `t_user_feed` VALUES (9, 11, 55, 'topic', 2, 1661495280588);
INSERT INTO `t_user_feed` VALUES (10, 11, 56, 'topic', 2, 1661501255292);
INSERT INTO `t_user_feed` VALUES (11, 11, 57, 'topic', 2, 1661842364179);
INSERT INTO `t_user_feed` VALUES (12, 11, 58, 'topic', 2, 1661931552887);
INSERT INTO `t_user_feed` VALUES (13, 11, 59, 'topic', 2, 1662086765916);
INSERT INTO `t_user_feed` VALUES (14, 11, 60, 'topic', 2, 1662342191236);
INSERT INTO `t_user_feed` VALUES (15, 11, 61, 'topic', 2, 1662535147101);
INSERT INTO `t_user_feed` VALUES (16, 11, 62, 'topic', 2, 1663146282829);
INSERT INTO `t_user_feed` VALUES (17, 11, 63, 'topic', 2, 1663895290720);
INSERT INTO `t_user_feed` VALUES (18, 11, 64, 'topic', 2, 1664241476297);
INSERT INTO `t_user_feed` VALUES (19, 11, 65, 'topic', 2, 1665383531234);
INSERT INTO `t_user_feed` VALUES (20, 2, 69, 'topic', 9, 1665650423568);
INSERT INTO `t_user_feed` VALUES (21, 11, 70, 'topic', 2, 1665650932531);
INSERT INTO `t_user_feed` VALUES (22, 11, 71, 'topic', 2, 1666618303614);
INSERT INTO `t_user_feed` VALUES (23, 2, 72, 'topic', 11, 1667182169849);
INSERT INTO `t_user_feed` VALUES (24, 11, 73, 'topic', 2, 1668580292234);
INSERT INTO `t_user_feed` VALUES (25, 11, 74, 'topic', 2, 1668602410695);
INSERT INTO `t_user_feed` VALUES (26, 2, 75, 'topic', 9, 1669280299668);
INSERT INTO `t_user_feed` VALUES (27, 11, 76, 'topic', 2, 1669631568793);
INSERT INTO `t_user_feed` VALUES (28, 11, 77, 'topic', 2, 1671518725781);
INSERT INTO `t_user_feed` VALUES (29, 11, 78, 'topic', 2, 1672897512505);
INSERT INTO `t_user_feed` VALUES (30, 11, 79, 'topic', 2, 1674873108771);
INSERT INTO `t_user_feed` VALUES (31, 11, 80, 'topic', 2, 1677113498624);
INSERT INTO `t_user_feed` VALUES (32, 11, 81, 'topic', 2, 1677113813938);
INSERT INTO `t_user_feed` VALUES (33, 11, 82, 'topic', 2, 1679274180301);
INSERT INTO `t_user_feed` VALUES (34, 2, 83, 'topic', 11, 1681719080019);
INSERT INTO `t_user_feed` VALUES (35, 11, 84, 'topic', 2, 1684293622522);
INSERT INTO `t_user_feed` VALUES (36, 11, 85, 'topic', 2, 1684302471353);
INSERT INTO `t_user_feed` VALUES (37, 2, 86, 'topic', 11, 1685612979967);
INSERT INTO `t_user_feed` VALUES (38, 11, 87, 'topic', 2, 1688541816402);
INSERT INTO `t_user_feed` VALUES (39, 11, 88, 'topic', 2, 1689044121217);
INSERT INTO `t_user_feed` VALUES (40, 11, 89, 'topic', 2, 1689556627864);
INSERT INTO `t_user_feed` VALUES (41, 11, 90, 'topic', 2, 1689564669307);
INSERT INTO `t_user_feed` VALUES (42, 11, 91, 'topic', 2, 1691120956400);
INSERT INTO `t_user_feed` VALUES (43, 11, 92, 'topic', 2, 1691463098619);
INSERT INTO `t_user_feed` VALUES (44, 2, 93, 'topic', 11, 1692615001119);
INSERT INTO `t_user_feed` VALUES (45, 11, 94, 'topic', 2, 1694053718364);
INSERT INTO `t_user_feed` VALUES (46, 11, 95, 'topic', 2, 1694504630423);
INSERT INTO `t_user_feed` VALUES (47, 11, 96, 'topic', 2, 1695800396032);
INSERT INTO `t_user_feed` VALUES (48, 11, 97, 'topic', 2, 1696668046768);

-- ----------------------------
-- Table structure for t_user_follow
-- ----------------------------
DROP TABLE IF EXISTS `t_user_follow`;
CREATE TABLE `t_user_follow`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `other_id` bigint(20) NOT NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_user_id`(`user_id`, `other_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_follow
-- ----------------------------
INSERT INTO `t_user_follow` VALUES (11, 2, 9, 0, 1659418570617);
INSERT INTO `t_user_follow` VALUES (12, 2, 11, 0, 1660206872656);
INSERT INTO `t_user_follow` VALUES (13, 11, 2, 0, 1660296154155);
INSERT INTO `t_user_follow` VALUES (14, 2, 16, 0, 1661132924928);
INSERT INTO `t_user_follow` VALUES (15, 10, 9, 0, 1678932706890);
INSERT INTO `t_user_follow` VALUES (16, 11, 9, 0, 1679643184279);

-- ----------------------------
-- Table structure for t_user_like
-- ----------------------------
DROP TABLE IF EXISTS `t_user_like`;
CREATE TABLE `t_user_like`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `entity_type` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `entity_id` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_user_like_unique`(`user_id`, `entity_type`, `entity_id`) USING BTREE,
  INDEX `idx_user_like_entity`(`entity_type`, `entity_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 39 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_like
-- ----------------------------
INSERT INTO `t_user_like` VALUES (11, 2, 'topic', 22, 1659321319653);
INSERT INTO `t_user_like` VALUES (12, 11, 'topic', 25, 1659336065378);
INSERT INTO `t_user_like` VALUES (13, 2, 'topic', 25, 1659336722964);
INSERT INTO `t_user_like` VALUES (14, 10, 'topic', 25, 1659337890221);
INSERT INTO `t_user_like` VALUES (15, 2, 'topic', 30, 1659422210096);
INSERT INTO `t_user_like` VALUES (16, 10, 'topic', 43, 1659928111973);
INSERT INTO `t_user_like` VALUES (17, 10, 'topic', 41, 1659928217937);
INSERT INTO `t_user_like` VALUES (18, 11, 'topic', 47, 1660202207544);
INSERT INTO `t_user_like` VALUES (19, 11, 'topic', 43, 1660202470822);
INSERT INTO `t_user_like` VALUES (20, 8, 'topic', 47, 1660203055420);
INSERT INTO `t_user_like` VALUES (21, 2, 'topic', 47, 1660207059635);
INSERT INTO `t_user_like` VALUES (22, 10, 'comment', 65, 1660209188721);
INSERT INTO `t_user_like` VALUES (23, 15, 'topic', 49, 1660296118130);
INSERT INTO `t_user_like` VALUES (24, 11, 'topic', 49, 1660296137532);
INSERT INTO `t_user_like` VALUES (25, 15, 'topic', 47, 1660296751667);
INSERT INTO `t_user_like` VALUES (26, 10, 'topic', 49, 1660724652990);
INSERT INTO `t_user_like` VALUES (27, 2, 'topic', 51, 1661132904157);
INSERT INTO `t_user_like` VALUES (28, 11, 'topic', 51, 1661220031959);
INSERT INTO `t_user_like` VALUES (29, 10, 'topic', 51, 1661238079389);
INSERT INTO `t_user_like` VALUES (30, 10, 'topic', 57, 1661906586980);
INSERT INTO `t_user_like` VALUES (31, 17, 'topic', 56, 1663309781966);
INSERT INTO `t_user_like` VALUES (32, 9, 'topic', 61, 1665650364373);
INSERT INTO `t_user_like` VALUES (33, 10, 'topic', 71, 1667457705425);
INSERT INTO `t_user_like` VALUES (34, 9, 'topic', 74, 1668681271342);
INSERT INTO `t_user_like` VALUES (35, 11, 'topic', 75, 1669600192515);
INSERT INTO `t_user_like` VALUES (36, 11, 'topic', 74, 1669600232757);
INSERT INTO `t_user_like` VALUES (37, 2, 'topic', 75, 1669629273004);
INSERT INTO `t_user_like` VALUES (38, 9, 'topic', 76, 1669711588427);

-- ----------------------------
-- Table structure for t_user_score_log
-- ----------------------------
DROP TABLE IF EXISTS `t_user_score_log`;
CREATE TABLE `t_user_score_log`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `source_type` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `source_id` varchar(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `type` bigint(20) NULL DEFAULT NULL,
  `score` bigint(20) NULL DEFAULT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `idx_user_score_log_user_id`(`user_id`) USING BTREE,
  INDEX `idx_user_score_score`(`source_type`, `source_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 315 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_score_log
-- ----------------------------
INSERT INTO `t_user_score_log` VALUES (33, 2, 'checkin', '4', '签到20220731', 0, 1, 1659267975104);
INSERT INTO `t_user_score_log` VALUES (34, 2, 'topic', '19', '发表话题', 0, 1, 1659268305843);
INSERT INTO `t_user_score_log` VALUES (35, 2, 'topic', '20', '发表话题', 0, 1, 1659317088210);
INSERT INTO `t_user_score_log` VALUES (36, 2, 'topic', '21', '发表话题', 0, 1, 1659319121278);
INSERT INTO `t_user_score_log` VALUES (37, 2, 'topic', '22', '发表话题', 0, 1, 1659321115054);
INSERT INTO `t_user_score_log` VALUES (38, 7, 'comment', '46', '发表跟帖', 0, 1, 1659321257553);
INSERT INTO `t_user_score_log` VALUES (39, 2, 'topic', '23', '发表话题', 0, 1, 1659332439157);
INSERT INTO `t_user_score_log` VALUES (40, 2, 'topic', '24', '发表话题', 0, 1, 1659332620432);
INSERT INTO `t_user_score_log` VALUES (41, 9, 'comment', '47', '发表跟帖', 0, 1, 1659335472216);
INSERT INTO `t_user_score_log` VALUES (42, 11, 'topic', '25', '发表话题', 0, 1, 1659336055829);
INSERT INTO `t_user_score_log` VALUES (43, 11, 'comment', '48', '发表跟帖', 0, 1, 1659336078201);
INSERT INTO `t_user_score_log` VALUES (44, 11, 'checkin', '5', '签到20220801', 0, 1, 1659336117420);
INSERT INTO `t_user_score_log` VALUES (45, 2, 'topic', '26', '发表话题', 0, 1, 1659336646591);
INSERT INTO `t_user_score_log` VALUES (46, 2, 'topic', '27', '发表话题', 0, 1, 1659339231212);
INSERT INTO `t_user_score_log` VALUES (47, 10, 'checkin', '6', '签到20220801', 0, 1, 1659339247358);
INSERT INTO `t_user_score_log` VALUES (48, 2, 'checkin', '4', '签到20220801', 0, 1, 1659341372158);
INSERT INTO `t_user_score_log` VALUES (49, 2, 'comment', '49', '发表跟帖', 0, 1, 1659343300239);
INSERT INTO `t_user_score_log` VALUES (50, 2, 'checkin', '4', '签到20220802', 0, 1, 1659402549269);
INSERT INTO `t_user_score_log` VALUES (51, 12, 'checkin', '7', '签到20220802', 0, 1, 1659410224896);
INSERT INTO `t_user_score_log` VALUES (52, 9, 'topic', '28', '发表话题', 0, 1, 1659411711764);
INSERT INTO `t_user_score_log` VALUES (53, 2, 'comment', '50', '发表跟帖', 0, 1, 1659412403634);
INSERT INTO `t_user_score_log` VALUES (54, 9, 'comment', '51', '发表跟帖', 0, 1, 1659412631502);
INSERT INTO `t_user_score_log` VALUES (55, 2, 'topic', '29', '发表话题', 0, 1, 1659421045742);
INSERT INTO `t_user_score_log` VALUES (56, 12, 'topic', '30', '发表话题', 0, 1, 1659422060065);
INSERT INTO `t_user_score_log` VALUES (57, 2, 'comment', '52', '发表跟帖', 0, 1, 1659422208207);
INSERT INTO `t_user_score_log` VALUES (58, 12, 'comment', '53', '发表跟帖', 0, 1, 1659424000172);
INSERT INTO `t_user_score_log` VALUES (59, 2, 'comment', '54', '发表跟帖', 0, 1, 1659429220889);
INSERT INTO `t_user_score_log` VALUES (60, 2, 'comment', '55', '发表跟帖', 0, 1, 1659429238324);
INSERT INTO `t_user_score_log` VALUES (61, 2, 'checkin', '4', '签到20220803', 0, 1, 1659489363091);
INSERT INTO `t_user_score_log` VALUES (62, 2, 'topic', '31', '发表话题', 0, 1, 1659491647938);
INSERT INTO `t_user_score_log` VALUES (63, 2, 'topic', '32', '发表话题', 0, 1, 1659506700026);
INSERT INTO `t_user_score_log` VALUES (64, 10, 'checkin', '6', '签到20220803', 0, 1, 1659506838748);
INSERT INTO `t_user_score_log` VALUES (65, 2, 'topic', '33', '发表话题', 0, 1, 1659507548963);
INSERT INTO `t_user_score_log` VALUES (66, 2, 'topic', '34', '发表话题', 0, 1, 1659508055911);
INSERT INTO `t_user_score_log` VALUES (67, 2, 'topic', '35', '发表话题', 0, 1, 1659509601022);
INSERT INTO `t_user_score_log` VALUES (68, 2, 'topic', '36', '发表话题', 0, 1, 1659509824942);
INSERT INTO `t_user_score_log` VALUES (69, 2, 'checkin', '4', '签到20220804', 0, 1, 1659575177349);
INSERT INTO `t_user_score_log` VALUES (70, 2, 'topic', '37', '发表话题', 0, 1, 1659580233116);
INSERT INTO `t_user_score_log` VALUES (71, 2, 'topic', '38', '发表话题', 0, 1, 1659597746634);
INSERT INTO `t_user_score_log` VALUES (72, 2, 'topic', '39', '发表话题', 0, 1, 1659602302995);
INSERT INTO `t_user_score_log` VALUES (73, 12, 'checkin', '7', '签到20220805', 0, 1, 1659661458938);
INSERT INTO `t_user_score_log` VALUES (74, 2, 'checkin', '4', '签到20220805', 0, 1, 1659661585969);
INSERT INTO `t_user_score_log` VALUES (75, 2, 'topic', '40', '发表话题', 0, 1, 1659667631292);
INSERT INTO `t_user_score_log` VALUES (76, 2, 'topic', '41', '发表话题', 0, 1, 1659669431985);
INSERT INTO `t_user_score_log` VALUES (77, 2, 'topic', '42', '发表话题', 0, 1, 1659678181678);
INSERT INTO `t_user_score_log` VALUES (78, 11, 'topic', '43', '发表话题', 0, 1, 1659681073667);
INSERT INTO `t_user_score_log` VALUES (79, 9, 'topic', '44', '发表话题', 0, 1, 1659681626249);
INSERT INTO `t_user_score_log` VALUES (80, 11, 'checkin', '5', '签到20220805', 0, 1, 1659690552480);
INSERT INTO `t_user_score_log` VALUES (81, 2, 'checkin', '4', '签到20220806', 0, 1, 1659756893004);
INSERT INTO `t_user_score_log` VALUES (82, 2, 'checkin', '4', '签到20220808', 0, 1, 1659920955926);
INSERT INTO `t_user_score_log` VALUES (83, 10, 'checkin', '6', '签到20220808', 0, 1, 1659930055343);
INSERT INTO `t_user_score_log` VALUES (84, 10, 'comment', '56', '发表跟帖', 0, 1, 1659930376900);
INSERT INTO `t_user_score_log` VALUES (85, 2, 'comment', '57', '发表跟帖', 0, 1, 1659938161322);
INSERT INTO `t_user_score_log` VALUES (86, 2, 'checkin', '4', '签到20220809', 0, 1, 1660015171770);
INSERT INTO `t_user_score_log` VALUES (87, 2, 'topic', '45', '发表话题', 0, 1, 1660015567169);
INSERT INTO `t_user_score_log` VALUES (88, 2, 'checkin', '4', '签到20220810', 0, 1, 1660094212997);
INSERT INTO `t_user_score_log` VALUES (89, 10, 'checkin', '6', '签到20220810', 0, 1, 1660110369483);
INSERT INTO `t_user_score_log` VALUES (90, 10, 'checkin', '6', '签到20220811', 0, 1, 1660180922405);
INSERT INTO `t_user_score_log` VALUES (91, 2, 'checkin', '4', '签到20220811', 0, 1, 1660181394296);
INSERT INTO `t_user_score_log` VALUES (92, 2, 'topic', '46', '发表话题', 0, 1, 1660186198455);
INSERT INTO `t_user_score_log` VALUES (93, 11, 'topic', '47', '发表话题', 0, 1, 1660202178037);
INSERT INTO `t_user_score_log` VALUES (94, 11, 'checkin', '5', '签到20220811', 0, 1, 1660202212490);
INSERT INTO `t_user_score_log` VALUES (95, 11, 'comment', '58', '发表跟帖', 0, 1, 1660202437163);
INSERT INTO `t_user_score_log` VALUES (96, 11, 'comment', '59', '发表跟帖', 0, 1, 1660202571980);
INSERT INTO `t_user_score_log` VALUES (97, 2, 'comment', '60', '发表跟帖', 0, 1, 1660202931767);
INSERT INTO `t_user_score_log` VALUES (98, 2, 'comment', '61', '发表跟帖', 0, 1, 1660203088239);
INSERT INTO `t_user_score_log` VALUES (99, 11, 'comment', '62', '发表跟帖', 0, 1, 1660203104635);
INSERT INTO `t_user_score_log` VALUES (100, 11, 'comment', '63', '发表跟帖', 0, 1, 1660203121238);
INSERT INTO `t_user_score_log` VALUES (101, 2, 'comment', '64', '发表跟帖', 0, 1, 1660206685399);
INSERT INTO `t_user_score_log` VALUES (102, 10, 'comment', '65', '发表跟帖', 0, 1, 1660209184601);
INSERT INTO `t_user_score_log` VALUES (103, 2, 'checkin', '4', '签到20220812', 0, 1, 1660266540681);
INSERT INTO `t_user_score_log` VALUES (104, 2, 'topic', '48', '发表话题', 0, 1, 1660272251493);
INSERT INTO `t_user_score_log` VALUES (105, 11, 'checkin', '5', '签到20220812', 0, 1, 1660292472460);
INSERT INTO `t_user_score_log` VALUES (106, 11, 'topic', '49', '发表话题', 0, 1, 1660294367451);
INSERT INTO `t_user_score_log` VALUES (107, 2, 'checkin', '4', '签到20220815', 0, 1, 1660526253055);
INSERT INTO `t_user_score_log` VALUES (108, 2, 'checkin', '4', '签到20220816', 0, 1, 1660612360457);
INSERT INTO `t_user_score_log` VALUES (109, 2, 'checkin', '4', '签到20220817', 0, 1, 1660698612272);
INSERT INTO `t_user_score_log` VALUES (110, 2, 'topic', '50', '发表话题', 0, 1, 1660698992395);
INSERT INTO `t_user_score_log` VALUES (111, 10, 'checkin', '6', '签到20220817', 0, 1, 1660724159730);
INSERT INTO `t_user_score_log` VALUES (112, 2, 'checkin', '4', '签到20220818', 0, 1, 1660787127517);
INSERT INTO `t_user_score_log` VALUES (113, 10, 'checkin', '6', '签到20220818', 0, 1, 1660804030982);
INSERT INTO `t_user_score_log` VALUES (114, 11, 'checkin', '5', '签到20220818', 0, 1, 1660809615591);
INSERT INTO `t_user_score_log` VALUES (115, 2, 'checkin', '4', '签到20220819', 0, 1, 1660871437784);
INSERT INTO `t_user_score_log` VALUES (116, 11, 'checkin', '5', '签到20220819', 0, 1, 1660872864371);
INSERT INTO `t_user_score_log` VALUES (117, 16, 'topic', '51', '发表话题', 0, 1, 1660895042990);
INSERT INTO `t_user_score_log` VALUES (118, 10, 'checkin', '6', '签到20220819', 0, 1, 1660903820602);
INSERT INTO `t_user_score_log` VALUES (119, 11, 'checkin', '5', '签到20220822', 0, 1, 1661132888938);
INSERT INTO `t_user_score_log` VALUES (120, 2, 'checkin', '4', '签到20220822', 0, 1, 1661132912109);
INSERT INTO `t_user_score_log` VALUES (121, 11, 'checkin', '5', '签到20220823', 0, 1, 1661220022772);
INSERT INTO `t_user_score_log` VALUES (122, 2, 'checkin', '4', '签到20220823', 0, 1, 1661234949283);
INSERT INTO `t_user_score_log` VALUES (123, 2, 'topic', '52', '发表话题', 0, 1, 1661235598812);
INSERT INTO `t_user_score_log` VALUES (124, 10, 'checkin', '6', '签到20220823', 0, 1, 1661238050725);
INSERT INTO `t_user_score_log` VALUES (125, 2, 'topic', '53', '发表话题', 0, 1, 1661239117872);
INSERT INTO `t_user_score_log` VALUES (126, 2, 'checkin', '4', '签到20220824', 0, 1, 1661303022055);
INSERT INTO `t_user_score_log` VALUES (127, 10, 'checkin', '6', '签到20220824', 0, 1, 1661304429251);
INSERT INTO `t_user_score_log` VALUES (128, 10, 'checkin', '6', '签到20220825', 0, 1, 1661394357555);
INSERT INTO `t_user_score_log` VALUES (129, 2, 'checkin', '4', '签到20220825', 0, 1, 1661396544218);
INSERT INTO `t_user_score_log` VALUES (130, 2, 'checkin', '4', '签到20220826', 0, 1, 1661476124386);
INSERT INTO `t_user_score_log` VALUES (131, 2, 'topic', '54', '发表话题', 0, 1, 1661493923281);
INSERT INTO `t_user_score_log` VALUES (132, 2, 'topic', '55', '发表话题', 0, 1, 1661495280611);
INSERT INTO `t_user_score_log` VALUES (133, 2, 'topic', '56', '发表话题', 0, 1, 1661501255317);
INSERT INTO `t_user_score_log` VALUES (134, 11, 'checkin', '5', '签到20220826', 0, 1, 1661503673375);
INSERT INTO `t_user_score_log` VALUES (135, 10, 'checkin', '6', '签到20220829', 0, 1, 1661739718370);
INSERT INTO `t_user_score_log` VALUES (136, 2, 'checkin', '4', '签到20220829', 0, 1, 1661752033167);
INSERT INTO `t_user_score_log` VALUES (137, 10, 'checkin', '6', '签到20220830', 0, 1, 1661839138850);
INSERT INTO `t_user_score_log` VALUES (138, 2, 'checkin', '4', '签到20220830', 0, 1, 1661842111081);
INSERT INTO `t_user_score_log` VALUES (139, 2, 'topic', '57', '发表话题', 0, 1, 1661842364203);
INSERT INTO `t_user_score_log` VALUES (140, 11, 'checkin', '5', '签到20220830', 0, 1, 1661844443006);
INSERT INTO `t_user_score_log` VALUES (141, 10, 'checkin', '6', '签到20220831', 0, 1, 1661906256894);
INSERT INTO `t_user_score_log` VALUES (142, 2, 'checkin', '4', '签到20220831', 0, 1, 1661907128134);
INSERT INTO `t_user_score_log` VALUES (143, 2, 'topic', '58', '发表话题', 0, 1, 1661931552907);
INSERT INTO `t_user_score_log` VALUES (144, 2, 'checkin', '4', '签到20220901', 0, 1, 1661995346746);
INSERT INTO `t_user_score_log` VALUES (145, 11, 'checkin', '5', '签到20220901', 0, 1, 1662038787848);
INSERT INTO `t_user_score_log` VALUES (146, 11, 'checkin', '5', '签到20220902', 0, 1, 1662083403067);
INSERT INTO `t_user_score_log` VALUES (147, 2, 'topic', '59', '发表话题', 0, 1, 1662086765938);
INSERT INTO `t_user_score_log` VALUES (148, 2, 'checkin', '4', '签到20220902', 0, 1, 1662086796701);
INSERT INTO `t_user_score_log` VALUES (149, 2, 'checkin', '4', '签到20220905', 0, 1, 1662340757469);
INSERT INTO `t_user_score_log` VALUES (150, 2, 'topic', '60', '发表话题', 0, 1, 1662342191256);
INSERT INTO `t_user_score_log` VALUES (151, 10, 'checkin', '6', '签到20220906', 0, 1, 1662423831679);
INSERT INTO `t_user_score_log` VALUES (152, 2, 'checkin', '4', '签到20220906', 0, 1, 1662426851118);
INSERT INTO `t_user_score_log` VALUES (153, 2, 'checkin', '4', '签到20220907', 0, 1, 1662512850174);
INSERT INTO `t_user_score_log` VALUES (154, 10, 'checkin', '6', '签到20220907', 0, 1, 1662531371894);
INSERT INTO `t_user_score_log` VALUES (155, 2, 'topic', '61', '发表话题', 0, 1, 1662535147119);
INSERT INTO `t_user_score_log` VALUES (156, 11, 'checkin', '5', '签到20220907', 0, 1, 1662536805616);
INSERT INTO `t_user_score_log` VALUES (157, 10, 'checkin', '6', '签到20220908', 0, 1, 1662598241027);
INSERT INTO `t_user_score_log` VALUES (158, 2, 'checkin', '4', '签到20220908', 0, 1, 1662599622044);
INSERT INTO `t_user_score_log` VALUES (159, 10, 'checkin', '6', '签到20220909', 0, 1, 1662688374629);
INSERT INTO `t_user_score_log` VALUES (160, 2, 'checkin', '4', '签到20220909', 0, 1, 1662711065025);
INSERT INTO `t_user_score_log` VALUES (161, 2, 'checkin', '4', '签到20220914', 0, 1, 1663122076801);
INSERT INTO `t_user_score_log` VALUES (162, 2, 'topic', '62', '发表话题', 0, 1, 1663146282858);
INSERT INTO `t_user_score_log` VALUES (163, 2, 'checkin', '4', '签到20220915', 0, 1, 1663206750752);
INSERT INTO `t_user_score_log` VALUES (164, 10, 'checkin', '6', '签到20220915', 0, 1, 1663207090864);
INSERT INTO `t_user_score_log` VALUES (165, 2, 'checkin', '4', '签到20220916', 0, 1, 1663297344677);
INSERT INTO `t_user_score_log` VALUES (166, 11, 'checkin', '5', '签到20220916', 0, 1, 1663310556029);
INSERT INTO `t_user_score_log` VALUES (167, 2, 'checkin', '4', '签到20220917', 0, 1, 1663380182358);
INSERT INTO `t_user_score_log` VALUES (168, 2, 'checkin', '4', '签到20220919', 0, 1, 1663549776297);
INSERT INTO `t_user_score_log` VALUES (169, 11, 'checkin', '5', '签到20220919', 0, 1, 1663551131922);
INSERT INTO `t_user_score_log` VALUES (170, 2, 'checkin', '4', '签到20220921', 0, 1, 1663763706398);
INSERT INTO `t_user_score_log` VALUES (171, 10, 'checkin', '6', '签到20220922', 0, 1, 1663808479242);
INSERT INTO `t_user_score_log` VALUES (172, 2, 'checkin', '4', '签到20220922', 0, 1, 1663808966325);
INSERT INTO `t_user_score_log` VALUES (173, 2, 'checkin', '4', '签到20220923', 0, 1, 1663894788481);
INSERT INTO `t_user_score_log` VALUES (174, 2, 'topic', '63', '发表话题', 0, 1, 1663895290745);
INSERT INTO `t_user_score_log` VALUES (175, 10, 'checkin', '6', '签到20220923', 0, 1, 1663897222235);
INSERT INTO `t_user_score_log` VALUES (176, 2, 'checkin', '4', '签到20220927', 0, 1, 1664241183688);
INSERT INTO `t_user_score_log` VALUES (177, 2, 'topic', '64', '发表话题', 0, 1, 1664241476319);
INSERT INTO `t_user_score_log` VALUES (178, 2, 'checkin', '4', '签到20220928', 0, 1, 1664327788036);
INSERT INTO `t_user_score_log` VALUES (179, 2, 'checkin', '4', '签到20220929', 0, 1, 1664421300722);
INSERT INTO `t_user_score_log` VALUES (180, 2, 'checkin', '4', '签到20221009', 0, 1, 1665278261950);
INSERT INTO `t_user_score_log` VALUES (181, 10, 'checkin', '6', '签到20221009', 0, 1, 1665280472799);
INSERT INTO `t_user_score_log` VALUES (182, 2, 'checkin', '4', '签到20221010', 0, 1, 1665383053173);
INSERT INTO `t_user_score_log` VALUES (183, 2, 'topic', '65', '发表话题', 0, 1, 1665383531263);
INSERT INTO `t_user_score_log` VALUES (184, 2, 'checkin', '4', '签到20221012', 0, 1, 1665539119955);
INSERT INTO `t_user_score_log` VALUES (185, 2, 'checkin', '4', '签到20221013', 0, 1, 1665647988978);
INSERT INTO `t_user_score_log` VALUES (186, 19, 'topic', '66', '发表话题', 0, 1, 1665648268484);
INSERT INTO `t_user_score_log` VALUES (187, 19, 'topic', '67', '发表话题', 0, 1, 1665648450274);
INSERT INTO `t_user_score_log` VALUES (188, 19, 'topic', '68', '发表话题', 0, 1, 1665648639715);
INSERT INTO `t_user_score_log` VALUES (189, 19, 'comment', '66', '发表跟帖', 0, 1, 1665648742467);
INSERT INTO `t_user_score_log` VALUES (190, 19, 'checkin', '8', '签到20221013', 0, 1, 1665648816264);
INSERT INTO `t_user_score_log` VALUES (191, 2, 'comment', '67', '发表跟帖', 0, 1, 1665648934230);
INSERT INTO `t_user_score_log` VALUES (192, 9, 'topic', '69', '发表话题', 0, 1, 1665650423589);
INSERT INTO `t_user_score_log` VALUES (193, 2, 'topic', '70', '发表话题', 0, 1, 1665650932552);
INSERT INTO `t_user_score_log` VALUES (194, 2, 'checkin', '4', '签到20221017', 0, 1, 1665977592720);
INSERT INTO `t_user_score_log` VALUES (195, 2, 'checkin', '4', '签到20221018', 0, 1, 1666088716570);
INSERT INTO `t_user_score_log` VALUES (196, 2, 'checkin', '4', '签到20221019', 0, 1, 1666142190741);
INSERT INTO `t_user_score_log` VALUES (197, 10, 'checkin', '6', '签到20221019', 0, 1, 1666168813685);
INSERT INTO `t_user_score_log` VALUES (198, 19, 'comment', '68', '发表跟帖', 0, 1, 1666316173037);
INSERT INTO `t_user_score_log` VALUES (199, 19, 'comment', '69', '发表跟帖', 0, 1, 1666316210940);
INSERT INTO `t_user_score_log` VALUES (200, 10, 'checkin', '6', '签到20221024', 0, 1, 1666574520661);
INSERT INTO `t_user_score_log` VALUES (201, 2, 'checkin', '4', '签到20221024', 0, 1, 1666606459428);
INSERT INTO `t_user_score_log` VALUES (202, 2, 'topic', '71', '发表话题', 0, 1, 1666618303636);
INSERT INTO `t_user_score_log` VALUES (203, 2, 'checkin', '4', '签到20221025', 0, 1, 1666660240582);
INSERT INTO `t_user_score_log` VALUES (204, 2, 'checkin', '4', '签到20221026', 0, 1, 1666746705148);
INSERT INTO `t_user_score_log` VALUES (205, 2, 'checkin', '4', '签到20221027', 0, 1, 1666855574854);
INSERT INTO `t_user_score_log` VALUES (206, 11, 'topic', '72', '发表话题', 0, 1, 1667182169872);
INSERT INTO `t_user_score_log` VALUES (207, 11, 'checkin', '5', '签到20221031', 0, 1, 1667182321386);
INSERT INTO `t_user_score_log` VALUES (208, 2, 'checkin', '4', '签到20221031', 0, 1, 1667182460194);
INSERT INTO `t_user_score_log` VALUES (209, 2, 'checkin', '4', '签到20221103', 0, 1, 1667438137011);
INSERT INTO `t_user_score_log` VALUES (210, 10, 'checkin', '6', '签到20221103', 0, 1, 1667457729121);
INSERT INTO `t_user_score_log` VALUES (211, 2, 'checkin', '4', '签到20221107', 0, 1, 1667791980534);
INSERT INTO `t_user_score_log` VALUES (212, 10, 'checkin', '6', '签到20221108', 0, 1, 1667876348233);
INSERT INTO `t_user_score_log` VALUES (213, 11, 'checkin', '5', '签到20221108', 0, 1, 1667876450580);
INSERT INTO `t_user_score_log` VALUES (214, 2, 'checkin', '4', '签到20221108', 0, 1, 1667889061172);
INSERT INTO `t_user_score_log` VALUES (215, 2, 'checkin', '4', '签到20221109', 0, 1, 1667961269407);
INSERT INTO `t_user_score_log` VALUES (216, 11, 'checkin', '5', '签到20221109', 0, 1, 1667963968626);
INSERT INTO `t_user_score_log` VALUES (217, 10, 'checkin', '6', '签到20221111', 0, 1, 1668130461225);
INSERT INTO `t_user_score_log` VALUES (218, 10, 'checkin', '6', '签到20221115', 0, 1, 1668480567935);
INSERT INTO `t_user_score_log` VALUES (219, 2, 'checkin', '4', '签到20221116', 0, 1, 1668580064629);
INSERT INTO `t_user_score_log` VALUES (220, 2, 'topic', '73', '发表话题', 0, 1, 1668580292256);
INSERT INTO `t_user_score_log` VALUES (221, 10, 'checkin', '6', '签到20221116', 0, 1, 1668581134812);
INSERT INTO `t_user_score_log` VALUES (222, 2, 'topic', '74', '发表话题', 0, 1, 1668602410722);
INSERT INTO `t_user_score_log` VALUES (223, 10, 'checkin', '6', '签到20221117', 0, 1, 1668652546308);
INSERT INTO `t_user_score_log` VALUES (224, 2, 'checkin', '4', '签到20221117', 0, 1, 1668677967786);
INSERT INTO `t_user_score_log` VALUES (225, 10, 'checkin', '6', '签到20221118', 0, 1, 1668734962056);
INSERT INTO `t_user_score_log` VALUES (226, 2, 'checkin', '4', '签到20221118', 0, 1, 1668753056602);
INSERT INTO `t_user_score_log` VALUES (227, 2, 'checkin', '4', '签到20221121', 0, 1, 1669021772644);
INSERT INTO `t_user_score_log` VALUES (228, 2, 'checkin', '4', '签到20221123', 0, 1, 1669166689038);
INSERT INTO `t_user_score_log` VALUES (229, 9, 'topic', '75', '发表话题', 0, 1, 1669280299690);
INSERT INTO `t_user_score_log` VALUES (230, 11, 'comment', '70', '发表跟帖', 0, 1, 1669348623680);
INSERT INTO `t_user_score_log` VALUES (231, 11, 'checkin', '5', '签到20221128', 0, 1, 1669600087586);
INSERT INTO `t_user_score_log` VALUES (232, 2, 'checkin', '4', '签到20221128', 0, 1, 1669629127860);
INSERT INTO `t_user_score_log` VALUES (233, 2, 'comment', '71', '发表跟帖', 0, 1, 1669629355051);
INSERT INTO `t_user_score_log` VALUES (234, 2, 'topic', '76', '发表话题', 0, 1, 1669631568811);
INSERT INTO `t_user_score_log` VALUES (235, 2, 'checkin', '4', '签到20221129', 0, 1, 1669684421301);
INSERT INTO `t_user_score_log` VALUES (236, 9, 'comment', '72', '发表跟帖', 0, 1, 1669711591471);
INSERT INTO `t_user_score_log` VALUES (237, 2, 'checkin', '4', '签到20221130', 0, 1, 1669770959188);
INSERT INTO `t_user_score_log` VALUES (238, 9, 'comment', '73', '发表跟帖', 0, 1, 1669864915239);
INSERT INTO `t_user_score_log` VALUES (239, 2, 'checkin', '4', '签到20221201', 0, 1, 1669889631381);
INSERT INTO `t_user_score_log` VALUES (240, 2, 'checkin', '4', '签到20221202', 0, 1, 1669971172990);
INSERT INTO `t_user_score_log` VALUES (241, 2, 'checkin', '4', '签到20221205', 0, 1, 1670202418688);
INSERT INTO `t_user_score_log` VALUES (242, 2, 'checkin', '4', '签到20221207', 0, 1, 1670383382643);
INSERT INTO `t_user_score_log` VALUES (243, 2, 'checkin', '4', '签到20221208', 0, 1, 1670470293876);
INSERT INTO `t_user_score_log` VALUES (244, 10, 'checkin', '6', '签到20221209', 0, 1, 1670565929463);
INSERT INTO `t_user_score_log` VALUES (245, 2, 'checkin', '4', '签到20221212', 0, 1, 1670811139229);
INSERT INTO `t_user_score_log` VALUES (246, 2, 'checkin', '4', '签到20221220', 0, 1, 1671518339250);
INSERT INTO `t_user_score_log` VALUES (247, 2, 'topic', '77', '发表话题', 0, 1, 1671518725802);
INSERT INTO `t_user_score_log` VALUES (248, 2, 'checkin', '4', '签到20221222', 0, 1, 1671672840512);
INSERT INTO `t_user_score_log` VALUES (249, 2, 'checkin', '4', '签到20221226', 0, 1, 1672017881819);
INSERT INTO `t_user_score_log` VALUES (250, 2, 'checkin', '4', '签到20221229', 0, 1, 1672302792465);
INSERT INTO `t_user_score_log` VALUES (251, 2, 'checkin', '4', '签到20230103', 0, 1, 1672732300404);
INSERT INTO `t_user_score_log` VALUES (252, 2, 'checkin', '4', '签到20230105', 0, 1, 1672884187630);
INSERT INTO `t_user_score_log` VALUES (253, 2, 'topic', '78', '发表话题', 0, 1, 1672897512527);
INSERT INTO `t_user_score_log` VALUES (254, 2, 'checkin', '4', '签到20230110', 0, 1, 1673313140178);
INSERT INTO `t_user_score_log` VALUES (255, 10, 'checkin', '6', '签到20230110', 0, 1, 1673320781153);
INSERT INTO `t_user_score_log` VALUES (256, 2, 'checkin', '4', '签到20230111', 0, 1, 1673401498993);
INSERT INTO `t_user_score_log` VALUES (257, 10, 'checkin', '6', '签到20230113', 0, 1, 1673578127953);
INSERT INTO `t_user_score_log` VALUES (258, 2, 'checkin', '4', '签到20230113', 0, 1, 1673598348643);
INSERT INTO `t_user_score_log` VALUES (259, 12, 'comment', '74', '发表跟帖', 0, 1, 1674010567779);
INSERT INTO `t_user_score_log` VALUES (260, 2, 'checkin', '4', '签到20230128', 0, 1, 1674872953298);
INSERT INTO `t_user_score_log` VALUES (261, 2, 'topic', '79', '发表话题', 0, 1, 1674873108793);
INSERT INTO `t_user_score_log` VALUES (262, 2, 'checkin', '4', '签到20230129', 0, 1, 1674962229008);
INSERT INTO `t_user_score_log` VALUES (263, 2, 'checkin', '4', '签到20230130', 0, 1, 1675046618786);
INSERT INTO `t_user_score_log` VALUES (264, 2, 'checkin', '4', '签到20230202', 0, 1, 1675303832297);
INSERT INTO `t_user_score_log` VALUES (265, 2, 'checkin', '4', '签到20230207', 0, 1, 1675744917965);
INSERT INTO `t_user_score_log` VALUES (266, 2, 'topic', '80', '发表话题', 0, 1, 1677113498647);
INSERT INTO `t_user_score_log` VALUES (267, 2, 'topic', '81', '发表话题', 0, 1, 1677113813959);
INSERT INTO `t_user_score_log` VALUES (268, 2, 'checkin', '4', '签到20230223', 0, 1, 1677115655782);
INSERT INTO `t_user_score_log` VALUES (269, 10, 'checkin', '6', '签到20230309', 0, 1, 1678327882795);
INSERT INTO `t_user_score_log` VALUES (270, 10, 'checkin', '6', '签到20230313', 0, 1, 1678690769623);
INSERT INTO `t_user_score_log` VALUES (271, 10, 'checkin', '6', '签到20230314', 0, 1, 1678782955488);
INSERT INTO `t_user_score_log` VALUES (272, 10, 'checkin', '6', '签到20230316', 0, 1, 1678930398186);
INSERT INTO `t_user_score_log` VALUES (273, 2, 'checkin', '4', '签到20230320', 0, 1, 1679274107917);
INSERT INTO `t_user_score_log` VALUES (274, 2, 'topic', '82', '发表话题', 0, 1, 1679274180322);
INSERT INTO `t_user_score_log` VALUES (275, 11, 'checkin', '5', '签到20230324', 0, 1, 1679643170576);
INSERT INTO `t_user_score_log` VALUES (276, 11, 'topic', '83', '发表话题', 0, 1, 1681719080043);
INSERT INTO `t_user_score_log` VALUES (277, 2, 'checkin', '4', '签到20230426', 0, 1, 1682480084156);
INSERT INTO `t_user_score_log` VALUES (278, 2, 'checkin', '4', '签到20230517', 0, 1, 1684293271515);
INSERT INTO `t_user_score_log` VALUES (279, 2, 'topic', '84', '发表话题', 0, 1, 1684293622629);
INSERT INTO `t_user_score_log` VALUES (280, 2, 'comment', '75', '发表跟帖', 0, 1, 1684293720496);
INSERT INTO `t_user_score_log` VALUES (281, 2, 'topic', '85', '发表话题', 0, 1, 1684302471375);
INSERT INTO `t_user_score_log` VALUES (282, 2, 'checkin', '4', '签到20230518', 0, 1, 1684379840181);
INSERT INTO `t_user_score_log` VALUES (283, 11, 'topic', '86', '发表话题', 0, 1, 1685612979994);
INSERT INTO `t_user_score_log` VALUES (284, 2, 'checkin', '4', '签到20230705', 0, 1, 1688541675916);
INSERT INTO `t_user_score_log` VALUES (285, 2, 'topic', '87', '发表话题', 0, 1, 1688541816428);
INSERT INTO `t_user_score_log` VALUES (286, 2, 'checkin', '4', '签到20230711', 0, 1, 1689043906447);
INSERT INTO `t_user_score_log` VALUES (287, 2, 'topic', '88', '发表话题', 0, 1, 1689044121240);
INSERT INTO `t_user_score_log` VALUES (288, 2, 'checkin', '4', '签到20230717', 0, 1, 1689556202691);
INSERT INTO `t_user_score_log` VALUES (289, 2, 'topic', '89', '发表话题', 0, 1, 1689556627987);
INSERT INTO `t_user_score_log` VALUES (290, 2, 'topic', '90', '发表话题', 0, 1, 1689564669328);
INSERT INTO `t_user_score_log` VALUES (291, 2, 'checkin', '4', '签到20230718', 0, 1, 1689642381436);
INSERT INTO `t_user_score_log` VALUES (292, 2, 'checkin', '4', '签到20230802', 0, 1, 1690946238566);
INSERT INTO `t_user_score_log` VALUES (293, 2, 'checkin', '4', '签到20230803', 0, 1, 1691041044065);
INSERT INTO `t_user_score_log` VALUES (294, 2, 'topic', '91', '发表话题', 0, 1, 1691120956422);
INSERT INTO `t_user_score_log` VALUES (295, 2, 'checkin', '4', '签到20230807', 0, 1, 1691398632396);
INSERT INTO `t_user_score_log` VALUES (296, 2, 'checkin', '4', '签到20230808', 0, 1, 1691462618200);
INSERT INTO `t_user_score_log` VALUES (297, 2, 'topic', '92', '发表话题', 0, 1, 1691463098646);
INSERT INTO `t_user_score_log` VALUES (298, 2, 'comment', '76', '发表跟帖', 0, 1, 1692066142455);
INSERT INTO `t_user_score_log` VALUES (299, 2, 'checkin', '4', '签到20230815', 0, 1, 1692066206078);
INSERT INTO `t_user_score_log` VALUES (300, 11, 'topic', '93', '发表话题', 0, 1, 1692615001141);
INSERT INTO `t_user_score_log` VALUES (301, 2, 'checkin', '4', '签到20230829', 0, 1, 1693298717394);
INSERT INTO `t_user_score_log` VALUES (302, 2, 'checkin', '4', '签到20230904', 0, 1, 1693818680562);
INSERT INTO `t_user_score_log` VALUES (303, 2, 'checkin', '4', '签到20230907', 0, 1, 1694051776010);
INSERT INTO `t_user_score_log` VALUES (304, 2, 'topic', '94', '发表话题', 0, 1, 1694053718390);
INSERT INTO `t_user_score_log` VALUES (305, 2, 'comment', '77', '发表跟帖', 0, 1, 1694053802112);
INSERT INTO `t_user_score_log` VALUES (306, 2, 'checkin', '4', '签到20230908', 0, 1, 1694138804598);
INSERT INTO `t_user_score_log` VALUES (307, 2, 'checkin', '4', '签到20230912', 0, 1, 1694499218975);
INSERT INTO `t_user_score_log` VALUES (308, 2, 'topic', '95', '发表话题', 0, 1, 1694504630451);
INSERT INTO `t_user_score_log` VALUES (309, 2, 'checkin', '4', '签到20230921', 0, 1, 1695258034374);
INSERT INTO `t_user_score_log` VALUES (310, 2, 'checkin', '4', '签到20230927', 0, 1, 1695799949020);
INSERT INTO `t_user_score_log` VALUES (311, 2, 'comment', '78', '发表跟帖', 0, 1, 1695799959959);
INSERT INTO `t_user_score_log` VALUES (312, 2, 'topic', '96', '发表话题', 0, 1, 1695800396056);
INSERT INTO `t_user_score_log` VALUES (313, 2, 'checkin', '4', '签到20231007', 0, 1, 1696667622976);
INSERT INTO `t_user_score_log` VALUES (314, 2, 'topic', '97', '发表话题', 0, 1, 1696668046811);

-- ----------------------------
-- Table structure for t_user_token
-- ----------------------------
DROP TABLE IF EXISTS `t_user_token`;
CREATE TABLE `t_user_token`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `token` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `user_id` bigint(20) NOT NULL,
  `expired_at` bigint(20) NOT NULL,
  `status` bigint(20) NOT NULL,
  `create_time` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `token`(`token`) USING BTREE,
  INDEX `idx_user_token_user_id`(`user_id`) USING BTREE,
  INDEX `idx_user_token_status`(`status`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user_token
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
